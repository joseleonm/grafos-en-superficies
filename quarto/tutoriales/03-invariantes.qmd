---
title: "Tutorial 3: Invariantes Topol√≥gicos"
author: "Jos√© Luis"
date: today
format:
  html:
    code-fold: true
    toc: true
execute:
  eval: false
---

# Invariantes de Ribbon Graphs

Los **invariantes topol√≥gicos** son n√∫meros que caracterizan la superficie ribbon sin depender de c√≥mo la dibujemos.

## Los 7 Invariantes Principales

```{python}
#| eval: false
#| code-fold: false
load('../scripts/ribbongraph_visualizer.sage')

viz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')
inv = viz.invariantes()

for nombre, valor in inv.items():
    print(f"{nombre:30s} = {valor}")
```

```
genus                          = 1
caras_mu                       = 1
vertices                       = 2
aristas                        = 3
componentes_frontera           = 1
euler_char_superficie          = -1
V-E+F(mu)                      = 0
```

## 1. G√©nero (g)

El **g√©nero** es el n√∫mero de "agujeros" de la superficie.

::: {.panel-tabset}

### Definici√≥n

$$g = \text{n√∫mero de agujeros}$$

### Interpretaci√≥n

- g = 0: Esfera (sin agujeros)
- g = 1: Toro (1 agujero)
- g = 2: Toro doble (2 agujeros)
- g ‚â• 3: Superficies de g√©nero superior

### C√°lculo

SageMath calcula el g√©nero usando la f√≥rmula de Euler:

$$g = \frac{2 - \chi - b}{2}$$

donde œá = V - E + F y b es el n√∫mero de fronteras.

:::

## 2. V√©rtices (V)

N√∫mero de v√©rtices del grafo = n√∫mero de ciclos en œÉ.

```{python}
#| eval: false
#| code-fold: false
sigma = Permutation('(1,2,3)(4,5,6)')
V = len(sigma.cycle_tuples())
print(f"V√©rtices: {V}")
# Salida: V√©rtices: 2
```

::: {.callout-note}
Cada ciclo en œÉ representa un v√©rtice del grafo.
:::

## 3. Aristas (E)

N√∫mero de aristas = n√∫mero de 2-ciclos en œÅ.

```{python}
#| eval: false
#| code-fold: false
rho = Permutation('(1,4)(2,5)(3,6)')
E = len(rho.cycle_tuples())
print(f"Aristas: {E}")
# Salida: Aristas: 3
```

::: {.callout-important}
œÅ debe ser una **involuci√≥n** (producto de 2-ciclos disjuntos).
:::

## 4. Caras (F)

N√∫mero de caras = n√∫mero de ciclos en Œº = œÉ¬∑œÅ.

```{python}
#| eval: false
#| code-fold: false
sigma = Permutation('(1,2,3)(4,5,6)')
rho = Permutation('(1,4)(2,5)(3,6)')
mu = sigma * rho
F = len(mu.cycle_tuples())
print(f"Caras: {F}")
print(f"Œº = {mu}")
# Salida:
# Caras: 1
# Œº = (1,5,3,4,2,6)
```

::: {.callout-tip}
## Las caras son los "pol√≠gonos" de la superficie

Cada ciclo de Œº representa una cara. La longitud del ciclo es el n√∫mero de lados.
:::

## 5. Componentes de Frontera (b)

N√∫mero de "bordes" de la superficie.

```{python}
#| eval: false
#| code-fold: false
viz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')
rg = viz.ribbon_graph
b = rg.number_boundaries()
print(f"Fronteras: {b}")
# Salida: Fronteras: 1
```

::: {.callout-note}
Las fronteras se calculan usando el m√©todo `boundary()` de SageMath, que devuelve las componentes como listas de dardos.
:::

## 6. Caracter√≠stica de Euler (œá)

Hay dos formas de calcular œá:

### œá de la Superficie

Para una superficie con frontera:

$$\chi = 2 - 2g - b$$

```{python}
#| eval: false
#| code-fold: false
g = 1  # g√©nero
b = 1  # fronteras
chi_superficie = 2 - 2*g - b
print(f"œá (superficie) = {chi_superficie}")
# Salida: œá (superficie) = -1
```

### œá del Grafo

F√≥rmula cl√°sica de Euler:

$$\chi_{grafo} = V - E + F$$

```{python}
#| eval: false
#| code-fold: false
V, E, F = 2, 3, 1
chi_grafo = V - E + F
print(f"œá (grafo) = {chi_grafo}")
# Salida: œá (grafo) = 0
```

::: {.callout-warning}
## ¬°Son diferentes!

- œá_{superficie} considera la superficie con frontera
- œá_{grafo} es la caracter√≠stica del grafo embebido
:::

## Tabla de Ejemplos

| Ejemplo | œÉ | œÅ | V | E | F | g | b | œá |
|---------|---|---|---|---|---|---|---|---|
| Toro | (1,2,3)(4,5,6) | (1,4)(2,5)(3,6) | 2 | 3 | 1 | 1 | 1 | -1 |
| Self-loops | (1,2,3,4) | (1,2)(3,4) | 1 | 2 | 1 | 0 | 3 | -1 |
| Tri√°ngulo | (1,2)(3,4)(5,6) | (1,3)(2,5)(4,6) | 3 | 3 | 2 | 0 | 2 | 0 |
| Theta | (1,2,3)(4,5,6) | (1,6)(2,4)(3,5) | 2 | 3 | 1 | 1 | 1 | -1 |

## Verificaci√≥n de F√≥rmulas

Para cada ribbon graph, podemos verificar:

```{python}
#| eval: false
#| code-fold: false
def verificar_invariantes(sigma_str, rho_str):
    viz = RibbonGraphVisualizer(sigma_str, rho_str)
    inv = viz.invariantes()

    # Verificar œá = 2 - 2g - b
    chi_calc = 2 - 2*inv['genus'] - inv['componentes_frontera']
    chi_real = inv['euler_char_superficie']

    # Verificar V - E + F
    vef = inv['V-E+F(mu)']

    print(f"Verificaci√≥n:")
    print(f"  œá calculado (2-2g-b): {chi_calc}")
    print(f"  œá real:               {chi_real}")
    print(f"  Coinciden: {chi_calc == chi_real}")
    print(f"  V - E + F:            {vef}")

    return inv

# Probar con ejemplo
verificar_invariantes('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')
```

## Relaci√≥n entre Invariantes

Las relaciones fundamentales:

1. **F√≥rmula de Euler para superficies con frontera:**
   $$\chi = 2 - 2g - b$$

2. **Relaci√≥n con el grafo:**
   $$\chi_{grafo} = V - E + F$$

3. **Conexi√≥n:**
   $$2 - 2g - b = V - E + F + \text{(t√©rminos de ajuste)}$$

::: {.callout-note}
## La diferencia

La diferencia entre œá_{superficie} y œá_{grafo} depende de c√≥mo se cuentan las fronteras.
:::

## Ejercicio

::: {.callout-tip icon=false}
## üìù Ejercicio 3.1

Para el ribbon graph œÉ = (1,2,3,4,5,6), œÅ = (1,2)(3,4)(5,6):

1. Calcula V, E, F
2. Calcula g y b
3. Verifica œá = 2 - 2g - b
4. Verifica V - E + F

<details>
<summary>Ver soluci√≥n</summary>

```sage
viz = RibbonGraphVisualizer('(1,2,3,4,5,6)', '(1,2)(3,4)(5,6)')
inv = viz.invariantes()

# 1. V, E, F
V = inv['vertices']      # 1
E = inv['aristas']       # 3
F = inv['caras_mu']      # ?

# 2. g, b
g = inv['genus']
b = inv['componentes_frontera']

# 3. Verificar œá = 2 - 2g - b
chi = 2 - 2*g - b
print(f"œá = 2 - 2({g}) - {b} = {chi}")

# 4. Verificar V - E + F
vef = V - E + F
print(f"V - E + F = {V} - {E} + {F} = {vef}")
```

Resultado:
- V = 1, E = 3, F = 1
- g = 0, b = 4
- œá = -2
- V - E + F = -1
</details>
:::

## Pr√≥ximos Pasos

Explora m√°s ejemplos en [Notas: Ejemplos Cl√°sicos](../notas/ejemplos.qmd).

## Referencias

- Gross & Tucker, *Topological Graph Theory* (1987)
- [Tutorial 1](01-introduccion.qmd) | [Tutorial 2](02-visualizacion.qmd)
