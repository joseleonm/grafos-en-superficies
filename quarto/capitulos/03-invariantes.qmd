---
title: "3. Invariantes Topológicos"
subtitle: "Cálculo computacional con SageMath"
---

Esta sección es práctica: aprenderemos a usar **SageMath** para calcular los **invariantes topológicos** que clasifican la superficie cerrada donde se aloja el grafo:

- **Característica de Euler:** $\chi$
- **Género:** $g$ (número de agujeros/asas)

## 1. Conteo de Elementos ($V, E, F$)

Recordemos que en un mapa combinatorio:

- $V$: Ciclos de $\sigma$
- $E$: Ciclos de $\rho$ (o $|D|/2$)
- $F$: Ciclos de $\varphi = \rho \sigma$

::: {.callout-note}
## Interpretación: ¿Caras o Fronteras?
En un ribbon graph, los ciclos de la permutación $\varphi$ describen las **componentes de frontera** de la superficie con borde obtenida al engrosar el grafo. Si se **tapan** esas fronteras con discos, esas mismas componentes pasan a ser las **caras** del encaje en la superficie cerrada.

Por ello, SageMath cuenta estos ciclos con `number_boundaries()`. En este curso, $b$ denota el número de componentes de frontera y coincide con $F$ cuando interpretamos el mapa sobre la superficie cerrada ($F=b$).
:::

SageMath nos permite extraer estos valores directamente del objeto `RibbonGraph`.

::: {.callout-tip}
## Verificación con SageMath

Puedes probar estos cálculos en línea usando [SageMathCell](https://sagecell.sagemath.org/).

```python
# Ejemplo: Un toro (1 vértice, 2 lazos)
sigma = PermutationGroupElement('(1,3,2,4)')
rho = PermutationGroupElement('(1,2)(3,4)')
R = RibbonGraph(sigma, rho)

# 1. Extracción de elementos básicos
# V = número de ciclos de sigma
# E = número de ciclos de rho (equivalente a |D|/2)
# F = número de ciclos de φ = ρσ (caras del mapa combinatorio)
phi = rho * sigma  # φ = ρσ (recuerda: multiplicación de izquierda a derecha en Sage)

V = len(sigma.cycle_tuples(singletons=True))
E = len(rho.cycle_tuples(singletons=True))
F = len(phi.cycle_tuples(singletons=True))

print(f"Vértices (V): {V}")
print(f"Aristas  (E): {E}")
print(f"Caras    (F): {F}")
print(f"φ = ρσ: {phi}")
print(f"Ciclos de φ: {phi.cycle_tuples(singletons=True)}")
```
:::

## 2. La Característica de Euler ($\chi$)

La característica de Euler es el invariante más fundamental. Se define combinatoriamente como:

$$ \chi = V - E + F $$

Esta es la característica de Euler de la **superficie cerrada** obtenida al pegar discos en todas las fronteras del grafo.

```python
chi = V - E + F
print(f"Característica de Euler (χ): {chi}")
# Para el toro: 1 - 2 + 1 = 0
```

## 3. El Género ($g$) y la Frontera ($b$)

El género $g$ se calcula siempre a partir de la **superficie cerrada** asociada. La cuenta es la misma, solo cambia la interpretación de $F$ y $b$:

- En el ribbon graph, los ciclos de $\varphi$ son **fronteras**, de modo que $b$ es el número de componentes de frontera.
- Al tapar cada frontera con un disco, esas mismas componentes pasan a ser las **caras** $F$ de la superficie cerrada.

Por lo tanto, en la superficie cerrada se cumple:

$$ \chi = V - E + F = V - E + b \quad \Rightarrow \quad g = \frac{2 - (V - E + b)}{2} $$

SageMath detecta automáticamente el número de componentes de frontera ($b$), y ese mismo valor coincide con $F$ cuando se interpreta el mapa en la superficie cerrada.

```python
# 2. Invariantes derivados
g = R.genus()              # Género de la superficie

print(f"Género (g): {g}")

# Verificación manual de la fórmula
chi = V - E + F
g_calc = (2 - chi) // 2
print(f"\nVerificación de Euler:")
print(f"  χ = V - E + F = {V} - {E} + {F} = {chi}")
print(f"  χ = 2 - 2g = 2 - 2({g}) = {2 - 2*g}")
print(f"  ✓ Fórmula consistente" if chi == 2 - 2*g else f"  ✗ Error en cálculo")
```

::: {.callout-note}
## Nota sobre `number_boundaries()`

En la implementación de `RibbonGraph` de SageMath, el método `number_boundaries()` devuelve el número de caras del mapa. Si interpretamos el mapa como una superficie con borde (antes de pegar los discos de las caras), estas caras son precisamente los bordes. Si lo interpretamos como superficie cerrada (después de pegar), son las caras $F$. La fórmula funciona consistentemente.
:::

## 4. Automatización: Una función de análisis

Como ejercicio de programación en SageMath, vamos a encapsular todo esto en una función reutilizable que nos dé un "reporte topológico" de cualquier sistema de rotación.

Puedes probar la siguiente función en [SageMathCell](https://sagecell.sagemath.org/):

```python
def analizar_topologia(sigma, rho):
    """
    Imprime un reporte de los elementos del grafo y sus invariantes básicos.
    """
    # Convertir strings a permutaciones si es necesario
    if isinstance(sigma, str): sigma = PermutationGroupElement(sigma)
    if isinstance(rho, str): rho = PermutationGroupElement(rho)

    R = RibbonGraph(sigma, rho)
    
    # Contar elementos
    phi = rho * sigma  # φ = ρσ
    V = len(sigma.cycle_tuples(singletons=True))  # Número de ciclos de sigma
    E = len(rho.cycle_tuples(singletons=True))    # Número de ciclos de rho
    F = len(phi.cycle_tuples(singletons=True))    # Número de ciclos de φ (caras)
    
    # Calcular invariantes
    chi = V - E + F
    b = R.number_boundaries()                      # Componentes de frontera
    g = R.genus()                                   # Género
    
    print(f"{'='*55}")
    print(f"Análisis del Mapa Combinatorio")
    print(f"{'='*55}")
    print(f"Permutaciones:")
    print(f"  σ = {sigma}")
    print(f"  ρ = {rho}")
    print(f"  φ = ρσ = {phi}")
    print(f"{'-'*55}")
    print(f"Elementos:")
    print(f"  V (ciclos de σ) = {V}")
    print(f"  E (ciclos de ρ) = {E}")
    print(f"  F (ciclos de φ) = {F}")
    print(f"{'-'*55}")
    print(f"Invariantes Topológicos:")
    print(f"  Euler: χ = {V} - {E} + {F} = {chi}")
    print(f"  Frontera: b = {b}")
    print(f"  Género: g = {g}")
    print(f"{'-'*55}")
    
    # Interpretación
    if g == 0:
        nombre = "Esfera"
    elif g == 1:
        nombre = "Toro"
    else:
        nombre = f"Género {g}"
    
    if b > 0:
        nombre += f" (grafo encajado con {F} cara{'s' if F > 1 else ''})"
    
    print(f"  >> Homeomorfo a: {nombre}")
    print(f"{'='*55}")

# Probamos con el ejemplo del capítulo anterior (Toro con 1 borde)
analizar_topologia('(1,3,2,4)', '(1,2)(3,4)')

print("\n")

# Probamos con K3 en la esfera (sin borde)
analizar_topologia('(1,6)(2,3)(4,5)', '(1,2)(3,4)(5,6)')
```

## 5. Galería de Ejemplos

Veamos cómo se comportan los invariantes en distintos casos.

| $\sigma$ | $\rho$ | $V$ | $E$ | $F$ | $\chi$ | $g$ | Superficie |
|----------|--------|-----|-----|-----|--------|-----|------------|
| $(1,6)(2,3)(4,5)$ | $(1,2)(3,4)(5,6)$ | $3$ | $3$ | $2$ | $2$ | $0$ | Esfera |
| $(1,3,2,4)$ | $(1,2)(3,4)$ | $1$ | $2$ | $1$ | $0$ | $1$ | Toro |
| $(1,2)$ | $(1,2)$ | $1$ | $1$ | $2$ | $2$ | $0$ | Esfera |

---

## Ejercicios

::: {.callout-tip}
## Ejercicio 1: Diseñador de Superficies

Usa la función `analizar_topologia` para encontrar un sistema de rotación que genere una superficie de **género 2** (Bitoro).

*Pista:* Necesitarás al menos 4 aristas (8 semiaristas) para tener suficiente "material" topológico. Intenta modificar $\sigma$ en un bouquet de 4 lazos.
:::

::: {.callout-tip}
## Ejercicio 2: Grafos Completos

Investiga el género de los grafos completos $K_n$.

1. Verifica que $K_3$ tiene género 0.
2. Construye un sistema de rotación para $K_4$ y determina el género de la superficie resultante. ¿Es posible obtener un encaje en la esfera ($g=0$)?
3. ¿Cuál es el género mínimo para $K_5$?
:::

::: {style="text-align: center; margin-top: 3em; color: #94a3b8; font-size: 0.9em;"}
Publicado el 09 de febrero de 2026
:::
