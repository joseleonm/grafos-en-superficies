---
title: "5. Ejemplos"
subtitle: "Verificación computacional de equivalencia de sistemas de rotación"
format:
  html:
    include-in-header:
      text: |
        <script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
        <link rel="stylesheet" type="text/css" href="https://sagecell.sagemath.org/static/sagecell_embed.css">
        <script>
        // Inicializar cuando el documento esté listo
        window.addEventListener('load', function() {
          sagecell.makeSagecell({
            inputLocation: 'div.sage-cell',
            evalButtonText: 'Ejecutar',
            languages: ['sage'],
            hide: []
          });
        });
        </script>
---

En el capítulo anterior vimos cómo sistemas de rotación aparentemente diferentes pueden representar el mismo encaje topológico. Aquí exploraremos casos más complicados donde la equivalencia no es inmediatamente obvia.

## Un ejemplo ilustrativo: ¿Moño vs ojo?

A primera vista, los siguientes dos encajes parecen topológicamente diferentes:

::: {.content-visible when-format="html"}
```{=html}
<style>
.encaje-grid {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 16px;
  align-items: start;
}
.encaje-item {
  text-align: center;
}
.encaje-item img {
  width: 100%;
  height: clamp(220px, 28vw, 320px);
  object-fit: contain;
}
.encaje-item p {
  margin: 0.5rem 0 0;
}
@media (max-width: 680px) {
  .encaje-grid {
    grid-template-columns: 1fr;
  }
}
</style>
<div class="encaje-grid">
  <div class="encaje-item">
    <img src="/imagenes/triangulos.png" alt="sigma1">
    <p>\( \sigma_1=(1,2,3,4)(5,10)(6,9)(8,12)(7,11) \), \( \rho=(1,5)(4,8)(2,6)(3,7)(9,10)(11,12) \)</p>
  </div>
  <div class="encaje-item">
    <img src="/imagenes/ojo.png" alt="sigma2">
    <p>\( \sigma_2=(1,4,3,2)(5,10)(6,9)(8,12)(7,11) \), \( \rho=(1,5)(4,8)(2,6)(3,7)(9,10)(11,12) \)</p>
  </div>
</div>
```
:::

::: {.content-visible when-format="pdf"}
::: {.columns}
::: {.column width="50%" style="text-align:center;"}
![](/imagenes/triangulos.png){width=100% height=5.5cm}
\( \sigma_1=(1,2,3,4)(5,10)(6,9)(8,12)(7,11) \), \( \rho=(1,5)(4,8)(2,6)(3,7)(9,10)(11,12) \)
:::
::: {.column width="50%" style="text-align:center;"}
![](/imagenes/ojo.png){width=100% height=5.5cm}
\( \sigma_2=(1,4,3,2)(5,10)(6,9)(8,12)(7,11) \), \( \rho=(1,5)(4,8)(2,6)(3,7)(9,10)(11,12) \)
:::
:::
:::

<br>

### Intuición geométrica inicial

En una representación **plana** con cara exterior distinguida, la diferencia parece evidente:

- **Figura izquierda (el moño):** La cara exterior colinda con vértices de ambos triángulos. Es posible trazar un camino desde cualquier vértice hacia el infinito sin cruzar ninguna arista.

- **Figura derecha (el ojo):** La cara exterior solo colinda con el triángulo mayor. Los vértices del triángulo menor quedan topológicamente "aislados" en una cara interior, y parece imposible conectarlos con el exterior sin cruzar el ciclo del triángulo mayor.

Esta intuición sugeriría que **no** son equivalentes. Sin embargo...

### ¡La verificación computacional dice lo contrario!

Aunque comparten el mismo emparejamiento $\rho$, y el orden cíclico en el vértice principal está invertido en $\sigma_2$ (comparado con $\sigma_1$), resulta que **sí existe** una biyección de dardos que conjuga uno en el otro.

**Prueba el código directamente aquí** (haz clic en "Ejecutar"):

::: {.content-visible when-format="html"}
```{=html}
<div class="sage-cell">
<script type="text/x-sage">
# Definir los sistemas de rotación
sigma1 = PermutationGroupElement('(1,2,3,4)(5,10)(6,9)(8,12)(7,11)')
sigma2 = PermutationGroupElement('(1,4,3,2)(5,10)(6,9)(8,12)(7,11)')
rho = PermutationGroupElement('(1,5)(4,8)(2,6)(3,7)(9,10)(11,12)')

# Crear ribbon graphs
R1 = RibbonGraph(sigma1, rho)
R2 = RibbonGraph(sigma2, rho)

# Verificar invariantes
phi1 = rho * sigma1
phi2 = rho * sigma2

V1 = len(sigma1.cycle_tuples(singletons=True))
E1 = len(rho.cycle_tuples(singletons=True))
F1 = len(phi1.cycle_tuples(singletons=True))

V2 = len(sigma2.cycle_tuples(singletons=True))
E2 = len(rho.cycle_tuples(singletons=True))
F2 = len(phi2.cycle_tuples(singletons=True))

print("Sistema 1:")
print(f"  V={V1}, E={E1}, F={F1}, χ={V1-E1+F1}, g={R1.genus()}")

print("\nSistema 2:")
print(f"  V={V2}, E={E2}, F={F2}, χ={V2-E2+F2}, g={R2.genus()}")

# Probar el isomorfismo propuesto por el algoritmo
phi = PermutationGroupElement('(1,4)(2,3)(5,8)(6,7)(9,11)(10,12)')

# Verificar conjugación
conjugado_sigma = phi * sigma1 * phi^(-1)
conjugado_rho = phi * rho * phi^(-1)

print("\nVerificación del isomorfismo φ = (1,4)(2,3)(5,8)(6,7)(9,11)(10,12):")
print(f"  φ·σ₁·φ⁻¹ = {conjugado_sigma}")
print(f"  σ₂       = {sigma2}")
print(f"  ¿Iguales? {conjugado_sigma == sigma2}")

print(f"\n  φ·ρ·φ⁻¹  = {conjugado_rho}")
print(f"  ρ        = {rho}")
print(f"  ¿Iguales? {conjugado_rho == rho}")

if conjugado_sigma == sigma2 and conjugado_rho == rho:
    print("\n✓ Los sistemas SON EQUIVALENTES")
    print("  Existe φ que conjuga (σ₁, ρ) en (σ₂, ρ)")
else:
    print("\n✗ Los sistemas NO son equivalentes")
</script>
</div>
```
:::

::: {.content-visible when-format="pdf"}
```python
# Definir los sistemas de rotación
sigma1 = PermutationGroupElement('(1,2,3,4)(5,10)(6,9)(8,12)(7,11)')
sigma2 = PermutationGroupElement('(1,4,3,2)(5,10)(6,9)(8,12)(7,11)')
rho = PermutationGroupElement('(1,5)(4,8)(2,6)(3,7)(9,10)(11,12)')

# Crear ribbon graphs
R1 = RibbonGraph(sigma1, rho)
R2 = RibbonGraph(sigma2, rho)

# Verificar invariantes
phi1 = rho * sigma1
phi2 = rho * sigma2

V1 = len(sigma1.cycle_tuples(singletons=True))
E1 = len(rho.cycle_tuples(singletons=True))
F1 = len(phi1.cycle_tuples(singletons=True))

V2 = len(sigma2.cycle_tuples(singletons=True))
E2 = len(rho.cycle_tuples(singletons=True))
F2 = len(phi2.cycle_tuples(singletons=True))

print("Sistema 1:")
print(f"  V={V1}, E={E1}, F={F1}, χ={V1-E1+F1}, g={R1.genus()}")

print("\nSistema 2:")
print(f"  V={V2}, E={E2}, F={F2}, χ={V2-E2+F2}, g={R2.genus()}")

# Probar el isomorfismo propuesto por el algoritmo
phi = PermutationGroupElement('(1,4)(2,3)(5,8)(6,7)(9,11)(10,12)')

# Verificar conjugación
conjugado_sigma = phi * sigma1 * phi^(-1)
conjugado_rho = phi * rho * phi^(-1)

print("\nVerificación del isomorfismo φ = (1,4)(2,3)(5,8)(6,7)(9,11)(10,12):")
print(f"  φ·σ₁·φ⁻¹ = {conjugado_sigma}")
print(f"  σ₂       = {sigma2}")
print(f"  ¿Iguales? {conjugado_sigma == sigma2}")

print(f"\n  φ·ρ·φ⁻¹  = {conjugado_rho}")
print(f"  ρ        = {rho}")
print(f"  ¿Iguales? {conjugado_rho == rho}")

if conjugado_sigma == sigma2 and conjugado_rho == rho:
    print("\n✓ Los sistemas SON EQUIVALENTES")
    print("  Existe φ que conjuga (σ₁, ρ) en (σ₂, ρ)")
else:
    print("\n✗ Los sistemas NO son equivalentes")
```
:::

### ¿Qué salió mal con la intuición?

La clave está en recordar que **los encajes en superficies cerradas no tienen una "cara exterior" privilegiada**. Cuando vemos una representación plana, estamos eligiendo arbitrariamente una cara para "abrir" y dibujar el resto.

Lo que parece una "obstrucción topológica" en el plano es simplemente un artefacto de nuestra elección de representación. Un homeomorfismo que preserve la orientación puede cambiar completamente cuál cara se convierte en "la exterior" al dibujar.

::: {.callout-warning}
## Lección aprendida

La intuición geométrica en representaciones planas puede ser engañosa. Los invariantes algebraicos ($V, E, F, \chi, g$) y la verificación computacional son herramientas más confiables para determinar equivalencia topológica.
:::

### ¿Cómo funciona el isomorfismo?

La permutación $\phi = (1,4)(2,3)(5,8)(6,7)(9,11)(10,12)$ reetiqueta los dardos de forma que:

1. Invierte el ciclo principal: $(1,2,3,4) \mapsto (1,4,3,2)$
2. Respeta completamente el emparejamiento $\rho$ de aristas
3. Preserva toda la estructura combinatoria del ribbon graph

En este ejemplo, $\phi$ tiene además una lectura geométrica concreta: corresponde a reflejar el moño respecto de un eje vertical que pasa por el vértice central, recuperando el otro dibujo.

Esto demuestra que, aunque los dibujos **se vean** diferentes en el plano, representan el **mismo** encaje topológico cuando se consideran como superficies cerradas.

---

## Buscando ejemplos genuinamente no equivalentes

Para construir sistemas de rotación que **realmente** sean no equivalentes pero tengan el mismo género, necesitaríamos:

- Diferentes números de vértices, aristas, o caras
- Diferente estructura en los ciclos de $\sigma$ o $\rho$ que no pueda conjugarse

### Un ejemplo concreto

La siguiente imagen muestra dos encajes del mismo grafo abstracto: a la izquierda el ribbon graph $(\sigma_1, \rho_1)$ y a la derecha $(\sigma_2, \rho_2)$, donde $\sigma_2 = \sigma_1$ pero $\rho_2$ difiere ligeramente de $\rho_1$.

![](/imagenes/ejemplodiferentes.png){width=60% fig-align="center"}

$$
\sigma_1 = \sigma_2 = (1,2)(3,4,5)(6,7,8)(9,10)(11,12,13)(14,15,16)
$$

$$
\rho_1 = (1,8)(2,3)(4,12)(5,6)(7,15)(9,16)(10,11)(13,14)
$$

$$
\rho_2 = (1,8)(2,3)(4,13)(5,6)(7,15)(9,14)(10,11)(12,16)
$$

Ambos comparten los mismos invariantes globales ($V$, $E$, $F$, $\chi$, $g$) y sin embargo **no son equivalentes**. El diagnóstico más rápido es comparar las **longitudes de los ciclos de $\phi = \rho\sigma$** (las caras). Si los multiconjuntos de longitudes difieren, no puede existir isomorfismo:

::: {.content-visible when-format="html"}
```{=html}
<div class="sage-cell">
<script type="text/x-sage">
sigma1 = PermutationGroupElement('(1,2)(3,4,5)(6,7,8)(9,10)(11,12,13)(14,15,16)')
rho1   = PermutationGroupElement('(1,8)(2,3)(4,12)(5,6)(7,15)(9,16)(10,11)(13,14)')
sigma2 = PermutationGroupElement('(1,2)(3,4,5)(6,7,8)(9,10)(11,12,13)(14,15,16)')
rho2   = PermutationGroupElement('(1,8)(2,3)(4,13)(5,6)(7,15)(9,14)(10,11)(12,16)')

phi1 = rho1 * sigma1
phi2 = rho2 * sigma2

long1 = sorted(len(c) for c in phi1.cycle_tuples(singletons=True))
long2 = sorted(len(c) for c in phi2.cycle_tuples(singletons=True))

R1 = RibbonGraph(sigma1, rho1)
R2 = RibbonGraph(sigma2, rho2)

V1 = len(sigma1.cycle_tuples(singletons=True))
E1 = len(rho1.cycle_tuples(singletons=True))
F1 = len(phi1.cycle_tuples(singletons=True))

V2 = len(sigma2.cycle_tuples(singletons=True))
E2 = len(rho2.cycle_tuples(singletons=True))
F2 = len(phi2.cycle_tuples(singletons=True))

print("Sistema 1: V={}, E={}, F={}, χ={}, g={}".format(V1, E1, F1, V1-E1+F1, R1.genus()))
print("  φ₁ =", phi1)
print("  Longitudes de caras:", long1)

print()
print("Sistema 2: V={}, E={}, F={}, χ={}, g={}".format(V2, E2, F2, V2-E2+F2, R2.genus()))
print("  φ₂ =", phi2)
print("  Longitudes de caras:", long2)

print()
if long1 == long2:
    print("✓ Multiconjuntos iguales → puede haber isomorfismo (no descartado)")
else:
    print("✗ Multiconjuntos distintos → NO puede existir isomorfismo")
    print("  Un isomorfismo conjugaría φ₁ en φ₂, preservando longitudes de ciclos.")
    print("  Como {} ≠ {}, los sistemas son genuinamente no equivalentes.".format(long1, long2))
</script>
</div>
```
:::

::: {.content-visible when-format="pdf"}
```python
sigma1 = PermutationGroupElement('(1,2)(3,4,5)(6,7,8)(9,10)(11,12,13)(14,15,16)')
rho1   = PermutationGroupElement('(1,8)(2,3)(4,12)(5,6)(7,15)(9,16)(10,11)(13,14)')
sigma2 = PermutationGroupElement('(1,2)(3,4,5)(6,7,8)(9,10)(11,12,13)(14,15,16)')
rho2   = PermutationGroupElement('(1,8)(2,3)(4,13)(5,6)(7,15)(9,14)(10,11)(12,16)')

phi1 = rho1 * sigma1
phi2 = rho2 * sigma2

long1 = sorted(len(c) for c in phi1.cycle_tuples(singletons=True))
long2 = sorted(len(c) for c in phi2.cycle_tuples(singletons=True))

# Sistema 1: [3, 3, 5, 5]
# Sistema 2: [3, 3, 4, 6]
# Multiconjuntos distintos → no equivalentes
```
:::

El resultado muestra que las longitudes de caras son $\{3,3,5,5\}$ para el primer sistema y $\{3,3,4,6\}$ para el segundo. Como cualquier isomorfismo preserva las longitudes de ciclos de $\phi$, la diferencia en los multiconjuntos es **condición suficiente** para concluir la no-equivalencia sin necesidad de correr la búsqueda con retroceso completa.

---

## Unicidad en grafos 3-conexos

Nótese que en el ejemplo anterior tenemos un grafo 2-conexo: hay pares de vértices cuya remoción desconecta el grafo, pero ningún vértice individual lo hace. Cuando aumentamos la conectividad hasta 3, sí se pueden garantizar encajes únicos. Esto se conecta con el **Teorema de Whitney**:

::: {.callout-important}
## Teorema de Whitney (1932)

Todo grafo planar 3‑conexo tiene un encaje único en la esfera (único salvo equivalencia topológica, es decir, reflexiones y homeomorfismos).
:::

Este resultado tiene un antecedente importante: en 1922, **Steinitz** demostró que todo grafo planar 3-conexo es el grafo de aristas de algún poliedro convexo, y que dicho poliedro es único salvo proyección. El teorema de Whitney puede verse como la versión combinatoria de ese resultado: la 3-conexidad fija la estructura combinatoria del encaje, del mismo modo en que Steinitz fijó la estructura poliedral.

Aquí "3‑conexo" **no** es "valencia 3"; se refiere a cuántos vértices hay que quitar para desconectar el grafo:

- **1‑conexo:** al quitar 1 vértice el grafo se desconecta (p. ej. una estrella).
- **2‑conexo:** se requieren al menos 2 vértices para desconectarlo (p. ej. un ciclo).
- **3‑conexo:** se requieren al menos 3 vértices para desconectarlo.

Ejemplos visuales de grafos 3‑conexos:

- El esqueleto de un cubo.
- El esqueleto de un tetraedro ($K_4$).
- El esqueleto de un dodecaedro.

En estos casos, el Teorema de Whitney garantiza que el encaje planar es esencialmente único.

---

## Verificar equivalencia: del problema al algoritmo

### La escala del problema

Para verificar si dos sistemas de rotación sobre $n$ dardos son equivalentes, necesitamos encontrar una biyección $\phi:\{1,\ldots,n\}\to\{1,\ldots,n\}$ que satisfaga

$$
\phi \cdot \sigma_1 \cdot \phi^{-1} = \sigma_2
\qquad\text{y}\qquad
\phi \cdot \rho_1 \cdot \phi^{-1} = \rho_2.
$$

El conjunto de todas las biyecciones posibles es el grupo simétrico $S_n$, de tamaño $n!$. Para el ejemplo de los dos encajes no equivalentes que vimos arriba, con $n = 16$ dardos:

$$
16! \;\approx\; 2.09 \times 10^{13}.
$$

Verificando un millón de permutaciones por segundo, recorrer todas llevaría unos **242 días**. Y eso suponiendo que los multiconjuntos de caras hubieran coincidido y no pudiéramos descartar la equivalencia de inmediato. Para los diagramas de Heegaard que veremos a continuación, con $n=48$:

$$
48! \;\approx\; 1.24 \times 10^{61},
$$

completamente fuera del alcance de cualquier computadora concebible.

### El grafo abstracto restringe la búsqueda

La observación clave es que cualquier isomorfismo debe **preservar la estructura del grafo abstracto**. Como $\sigma$ codifica el orden cíclico de los dardos alrededor de cada vértice, una biyección $\phi$ solo puede ser isomorfismo si mapea ciclos de $\sigma_1$ a ciclos de $\sigma_2$ **de la misma longitud**. En otras palabras, $\phi$ actúa como una permutación entre los ciclos de $\sigma$, junto con una rotación dentro de cada ciclo.

Esto restringe drásticamente el espacio de búsqueda. Para el ejemplo con $n=16$ y tipo de ciclo $2^2 \cdot 3^4$ (dos 2-ciclos y cuatro 3-ciclos):

| Elección | Opciones |
|---|---|
| ¿Cuál 2-ciclo se manda a cuál? | $2! = 2$ |
| Rotación dentro de cada 2-ciclo | $2^2 = 4$ |
| ¿Cuál 3-ciclo se manda a cuál? | $4! = 24$ |
| Rotación dentro de cada 3-ciclo | $3^4 = 81$ |
| **Total de candidatos** | $2 \times 4 \times 24 \times 81 = 15{,}552$ |

Son más de **$10^9$ veces menos** candidatos que por fuerza bruta. Cada uno debe aún verificarse contra la condición de $\rho$, pero la reducción es enorme.

### Búsqueda con retroceso y propagación

Podemos reducir aún más el espacio explotando que las condiciones de isomorfismo **propagan restricciones en cadena**. Al fijar la imagen de un solo dardo, $\phi(d_1) = d_2$, las condiciones de isomorfismo imponen de inmediato nuevas asignaciones:

**Propagación por $\sigma$:** La condición $\sigma_1(\phi(d)) = \phi(\sigma_2(d))$ determina las imágenes de todos los dardos en el ciclo de $\sigma_2$ que contiene a $d_1$:

$$
\phi(\sigma_2(d_1)) = \sigma_1(d_2), \quad
\phi(\sigma_2^2(d_1)) = \sigma_1^2(d_2), \quad \ldots
$$

**Propagación por $\rho$:** La condición $\phi(\rho_1(d)) = \rho_2(\phi(d))$ determina el dardo emparejado:

$$
\phi(\rho_1(d_1)) = \rho_2(d_2).
$$

Cada nueva asignación puede desencadenar más propagaciones. Si en algún momento una propagación contradice una asignación anterior, esa rama se **descarta de inmediato** sin seguir explorando. Si se termina de asignar todos los dardos sin contradicción, se ha encontrado un isomorfismo. Si se agotan todas las opciones, queda probado que no existe ninguno.

El procedimiento es una **búsqueda con retroceso**: se construye $\phi$ eligiendo libremente la imagen del siguiente dardo sin asignar, se propagan las consecuencias, y si hay contradicción se retrocede al último punto de elección libre para probar la siguiente opción.

<!-- ::: {.callout-note}
## Por qué es eficiente en la práctica

Para $n=48$ con $\sigma$ formada por ciclos de longitud 4, fijar $\phi(1) = d_2$ determina de inmediato 4 dardos más (el ciclo de $\sigma_2$) y 4 dardos adicionales (sus pares en $\rho_1$). Esos nuevos dardos pertenecen a otros ciclos de $\sigma$, que propagan más asignaciones, y así sucesivamente. En la práctica, una sola elección libre suele determinar más de la mitad del mapeo completo, y la mayoría de las ramas se podan antes de completar el 10% de las asignaciones. El resultado es que un problema con $48! \approx 10^{61}$ candidatos teóricos se resuelve en milisegundos.
::: -->

---

## Diagramas de Heegaard como encajes celulares

Los **diagramas de Heegaard** de variedades de 3 dimensiones con mínimo número de vértices pueden representarse como encajes celulares, y la pregunta de si dos diagramas describen la misma variedad puede reducirse a verificar la equivalencia de sus sistemas de rotación.

**Esfera de Poincaré** - Diagrama de Heegaard como encaje celular:

![](/imagenes/esferaPoincarerotacion.png){width=100% fig-cap="Figura tomada de https://arxiv.org/abs/2510.06651."}

$$
\begin{aligned}
\sigma &= (1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16) \\
       &\phantom{=} (17,18,19,20)(21,22,23,24)(25,26,27,28)(29,30,31,32) \\
       &\phantom{=} (33,34,35,36)(37,38,39,40)(41,42,43,44)(45,46,47,48)
\end{aligned}
$$

$$
\begin{aligned}
\rho &= (1,7)(2,36)(3,25)(4,48)(5,11)(6,40)(8,30)(9,15) \\
     &\phantom{=} (10,42)(12,34)(13,19)(14,38)(16,18)(17,23) \\
     &\phantom{=} (20,22)(21,27)(24,26)(28,32)(29,35)(31,45) \\
     &\phantom{=} (33,39)(37,43)(41,47)(44,46)
\end{aligned}
$$

Este sistema de rotación representa el diagrama de Heegaard de la esfera de Poincaré pensado como un encaje celular.

**Prueba el código directamente aquí** (haz clic en "Ejecutar"):

::: {.content-visible when-format="html"}
```{=html}
<div class="sage-cell">
<script type="text/x-sage">
# Sistema de rotación del diagrama de Heegaard de la esfera de Poincaré
sigma = PermutationGroupElement('(1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16)(17,18,19,20)(21,22,23,24)(25,26,27,28)(29,30,31,32)(33,34,35,36)(37,38,39,40)(41,42,43,44)(45,46,47,48)')
rho = PermutationGroupElement('(1,7)(2,36)(3,25)(4,48)(5,11)(6,40)(8,30)(9,15)(10,42)(12,34)(13,19)(14,38)(16,18)(17,23)(20,22)(21,27)(24,26)(28,32)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)')

# Crear ribbon graph
R = RibbonGraph(sigma, rho)
phi = rho * sigma

# Calcular invariantes
V = len(sigma.cycle_tuples(singletons=True))
E = len(rho.cycle_tuples(singletons=True))
F = len(phi.cycle_tuples(singletons=True))

print(f"Vértices (V): {V}")
print(f"Aristas  (E): {E}")
print(f"Caras    (F): {F}")
print(f"χ = V - E + F: {V - E + F}")
print(f"Género (g): {R.genus()}")

print(f"\nCiclos de φ (caras):")
for i, ciclo in enumerate(phi.cycle_tuples(singletons=True), 1):
    print(f"  Cara {i}: longitud {len(ciclo)}")
</script>
</div>
```
:::

::: {.content-visible when-format="pdf"}
```python
# Sistema de rotación del diagrama de Heegaard de la esfera de Poincaré
sigma = PermutationGroupElement('(1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16)(17,18,19,20)(21,22,23,24)(25,26,27,28)(29,30,31,32)(33,34,35,36)(37,38,39,40)(41,42,43,44)(45,46,47,48)')
rho = PermutationGroupElement('(1,7)(2,36)(3,25)(4,48)(5,11)(6,40)(8,30)(9,15)(10,42)(12,34)(13,19)(14,38)(16,18)(17,23)(20,22)(21,27)(24,26)(28,32)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)')

# Crear ribbon graph
R = RibbonGraph(sigma, rho)
phi = rho * sigma

# Calcular invariantes
V = len(sigma.cycle_tuples(singletons=True))
E = len(rho.cycle_tuples(singletons=True))
F = len(phi.cycle_tuples(singletons=True))

print(f"Vértices (V): {V}")
print(f"Aristas  (E): {E}")
print(f"Caras    (F): {F}")
print(f"χ = V - E + F: {V - E + F}")
print(f"Género (g): {R.genus()}")

print(f"\nCiclos de φ (caras):")
for i, ciclo in enumerate(phi.cycle_tuples(singletons=True), 1):
    print(f"  Cara {i}: longitud {len(ciclo)}")
```
:::


Diagrama Alterno de Heegaard como encaje celular:

![](/imagenes/EsferaPoincare2.png){width=100% fig-cap="Figura adaptada de https://www.sciencedirect.com/science/article/pii/S0550321317303516. Licencia CC BY 4.0 (https://creativecommons.org/licenses/by/4.0/). Cambios: se agrego la numeracion de los dardos para calcular el sistema de rotacion."}

$$
\begin{aligned}
\sigma &= (1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16) \\
       &\phantom{=} (17,18,19,20)(21,22,23,24)(25,26,27,28)(29,30,31,32) \\
       &\phantom{=} (33,34,35,36)(37,38,39,40)(41,42,43,44)(45,46,47,48)
\end{aligned}
$$

$$
\begin{aligned}
\rho &= (1,7)(2,38)(3,25)(4,6)(5,11)(8,10)(9,15)(12,14) \\
     &\phantom{=} (13,19)(16,32)(17,23)(18,36)(20,48)(21,27)(22,40) \\
     &\phantom{=} (24,30)(26,42)(28,34)(29,35)(31,45) \\
     &\phantom{=} (33,39)(37,43)(41,47)(44,46)
\end{aligned}
$$

Este sistema de rotación representa el diagrama de Heegaard de la esfera de Poincaré pensado como un encaje celular.

---

## ¿Son equivalentes los dos diagramas de Heegaard?

Tanto el diagrama original como el alterno tienen la misma $\sigma$. La pregunta es si existe un isomorfismo de ribbon graphs entre ellos. El siguiente código verifica primero que ambos $\rho$ sean válidos, calcula sus invariantes y luego aplica la búsqueda con retroceso para encontrar un isomorfismo $\phi$.

**Prueba el código directamente aquí** (haz clic en "Ejecutar"):

::: {.content-visible when-format="html"}
```{=html}
<div class="sage-cell">
<script type="text/x-sage">
import re, time

# ============================================================
# DEFINICIÓN DE LOS DOS SISTEMAS
# ============================================================
sigma_str = '(1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16)(17,18,19,20)(21,22,23,24)(25,26,27,28)(29,30,31,32)(33,34,35,36)(37,38,39,40)(41,42,43,44)(45,46,47,48)'

rho1_str = '(1,7)(2,36)(3,25)(4,48)(5,11)(6,40)(8,30)(9,15)(10,42)(12,34)(13,19)(14,38)(16,18)(17,23)(20,22)(21,27)(24,26)(28,32)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)'

rho2_str = '(1,7)(2,38)(3,25)(4,6)(5,11)(8,10)(9,15)(12,14)(13,19)(16,32)(17,23)(18,36)(20,48)(21,27)(22,40)(24,30)(26,42)(28,34)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)'

# ============================================================
# VERIFICAR VALIDEZ DE CADA ρ
# ============================================================
def verificar_rho(rho_str, nombre, n=48):
    nums = [int(x) for x in re.findall(r'\d+', rho_str)]
    repetidos = [x for x in set(nums) if nums.count(x) > 1]
    faltantes = sorted(set(range(1, n+1)) - set(nums))
    print(f"{nombre}: {len(nums)//2} aristas")
    if repetidos:
        print(f"  ✗ Números repetidos: {repetidos}")
    else:
        print(f"  ✓ Sin repetidos")
    if faltantes:
        print(f"  ✗ Números faltantes: {faltantes}")
    else:
        print(f"  ✓ Cubre todo {{1,...,{n}}}")
    return not repetidos and not faltantes

print("=" * 55)
print("VERIFICACIÓN DE VALIDEZ")
print("=" * 55)
ok1 = verificar_rho(rho1_str, "ρ₁ (original)")
ok2 = verificar_rho(rho2_str, "ρ₂ (alterno)")

if not (ok1 and ok2):
    print("\n⚠ Uno o ambos sistemas tienen errores. Corrígelos antes de continuar.")
else:
    # ============================================================
    # ALGORITMO DE BACKTRACKING CON PROPAGACIÓN
    # (Condición Sage izq→der: sigma1(phi(d)) = phi(sigma2(d)))
    # ============================================================
    sigma = PermutationGroupElement(sigma_str)
    rho1  = PermutationGroupElement(rho1_str)
    rho2  = PermutationGroupElement(rho2_str)

    n = 48
    cs1_raw = list(sigma.cycle_tuples(singletons=True))
    cs2_raw = list(sigma.cycle_tuples(singletons=True))  # misma sigma
    cr1 = list(rho1.cycle_tuples(singletons=True))
    cr2 = list(rho2.cycle_tuples(singletons=True))

    # Expandir singletons hasta n
    e1 = set(d for c in cs1_raw for d in c)
    cs1 = cs1_raw + [(d,) for d in range(1, n+1) if d not in e1]
    e2 = set(d for c in cs2_raw for d in c)
    cs2 = cs2_raw + [(d,) for d in range(1, n+1) if d not in e2]

    mapeo = {}

    def propagar_sigma(d1, d2):
        cd1 = next((c for c in cs2 if d1 in c), None)
        cd2 = next((c for c in cs1 if d2 in c), None)
        if cd1 is None or cd2 is None or len(cd1) != len(cd2):
            return None
        i1, i2, L = cd1.index(d1), cd2.index(d2), len(cd1)
        nuevos = []
        for i in range(L):
            src, tgt = cd1[(i1+i)%L], cd2[(i2+i)%L]
            if src in mapeo:
                if mapeo[src] != tgt: return None
            else:
                nuevos.append((src, tgt))
        return nuevos

    def propagar_rho(d1, d2):
        r1d1, r2d2 = rho1(d1), rho2(d2)
        if r1d1 in mapeo:
            return None if mapeo[r1d1] != r2d2 else []
        return [(r1d1, r2d2)]

    def extender(pares):
        cola = list(pares)
        while cola:
            d1, d2 = cola.pop(0)
            if d1 in mapeo:
                if mapeo[d1] != d2: return False
                continue
            mapeo[d1] = d2
            ns = propagar_sigma(d1, d2)
            if ns is None: return False
            cola.extend(ns)
            nr = propagar_rho(d1, d2)
            if nr is None: return False
            cola.extend(nr)
        return True

    def backtrack():
        d1 = next((d for d in range(1, n+1) if d not in mapeo), None)
        if d1 is None:
            from sage.groups.perm_gps.permgroup_named import SymmetricGroup
            Sn = SymmetricGroup(n)
            pl = [0]*(n+1)
            for a,b in mapeo.items(): pl[a] = b
            try:
                phi = Sn([pl[i] for i in range(1, n+1)])
                c1 = phi * sigma * phi^(-1) == sigma
                c2 = phi * rho1 * phi^(-1) == rho2
                if c1 and c2: return phi
            except: pass
            return None
        cd1 = next((c for c in cs2 if d1 in c), None)
        tam = len(cd1)
        for d2 in range(1, n+1):
            if d2 in mapeo.values(): continue
            cd2 = next((c for c in cs1 if d2 in c), None)
            if cd2 is None or len(cd2) != tam: continue
            prev = dict(mapeo)
            if extender([(d1, d2)]):
                res = backtrack()
                if res is not None: return res
            mapeo.clear(); mapeo.update(prev)
        return None

    # ============================================================
    # CALCULAR INVARIANTES DE AMBOS SISTEMAS
    # ============================================================
    R1 = RibbonGraph(sigma, rho1)
    R2 = RibbonGraph(sigma, rho2)
    phi1 = rho1 * sigma
    phi2 = rho2 * sigma

    def inv(sg, rh, phi_rho_sigma):
        V = len(sg.cycle_tuples(singletons=True))
        E = len(rh.cycle_tuples(singletons=True))
        F = len(phi_rho_sigma.cycle_tuples(singletons=True))
        return V, E, F

    V1,E1,F1 = inv(sigma, rho1, phi1)
    V2,E2,F2 = inv(sigma, rho2, phi2)

    print("\n" + "=" * 55)
    print("INVARIANTES")
    print("=" * 55)
    print(f"Sistema 1: V={V1}, E={E1}, F={F1}, χ={V1-E1+F1}, g={R1.genus()}")
    print(f"Sistema 2: V={V2}, E={E2}, F={F2}, χ={V2-E2+F2}, g={R2.genus()}")

    inv_coinciden = (V1==V2 and E1==E2 and F1==F2 and R1.genus()==R2.genus())
    if not inv_coinciden:
        print("\n✗ Los invariantes difieren → los sistemas NO son equivalentes")
    else:
        print("✓ Invariantes coinciden → puede haber isomorfismo")
        print("\n" + "=" * 55)
        print("BUSCANDO ISOMORFISMO (búsqueda con retroceso)...")
        print("=" * 55)
        t0 = time.time()
        phi = backtrack()
        elapsed = time.time() - t0
        print(f"Tiempo: {elapsed:.3f} s")
        if phi is not None:
            print(f"\n✓ EQUIVALENTES  φ = {phi}")
        else:
            print("\n✗ NO equivalentes (no existe φ)")
</script>
</div>
```
:::

::: {.content-visible when-format="pdf"}
```python
# Verificar equivalencia de los dos diagramas de Heegaard
# (ver versión interactiva en la web)
sigma_str = '(1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16)(17,18,19,20)(21,22,23,24)(25,26,27,28)(29,30,31,32)(33,34,35,36)(37,38,39,40)(41,42,43,44)(45,46,47,48)'
rho1_str  = '(1,7)(2,36)(3,25)(4,48)(5,11)(6,40)(8,30)(9,15)(10,42)(12,34)(13,19)(14,38)(16,18)(17,23)(20,22)(21,27)(24,26)(28,32)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)'
rho2_str  = '(1,7)(2,38)(3,25)(4,6)(5,11)(8,10)(9,15)(12,14)(13,19)(16,32)(17,23)(18,36)(20,48)(21,27)(22,40)(24,30)(26,42)(28,34)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)'
# ... (código completo disponible en scripts/equivalencia_ribbon_graphs.sage)
```
:::

### La solución encontrada

El algoritmo (que es determinista: siempre recorre el mismo árbol de búsqueda) encuentra el isomorfismo entre los dos diagramas de Heegaard en **menos de 0.1 segundos**. 

$$
\begin{aligned}
\phi &= (1,27)(2,28)(3,25)(4,26)(5,23)(6,24)(7,21)(8,22) \\
     &\phantom{=}(9,19)(10,20)(11,17)(12,18)(13,15)(14,16) \\
     &\phantom{=}(29,39)(30,40)(31,37)(32,38)(33,35)(34,36) \\
     &\phantom{=}(41,47)(42,48)(43,45)(44,46)
\end{aligned}
$$

Esta permutación conjuga simultáneamente $\sigma$ en $\sigma$ y $\rho_1$ en $\rho_2$, probando que los dos diagramas de Heegaard describen el mismo encaje celular.

**Verificación del isomorfismo** (haz clic en "Ejecutar"):

::: {.content-visible when-format="html"}
```{=html}
<div class="sage-cell">
<script type="text/x-sage">
# Verificación del isomorfismo encontrado por la búsqueda con retroceso
sigma = PermutationGroupElement('(1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16)(17,18,19,20)(21,22,23,24)(25,26,27,28)(29,30,31,32)(33,34,35,36)(37,38,39,40)(41,42,43,44)(45,46,47,48)')
rho1  = PermutationGroupElement('(1,7)(2,36)(3,25)(4,48)(5,11)(6,40)(8,30)(9,15)(10,42)(12,34)(13,19)(14,38)(16,18)(17,23)(20,22)(21,27)(24,26)(28,32)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)')
rho2  = PermutationGroupElement('(1,7)(2,38)(3,25)(4,6)(5,11)(8,10)(9,15)(12,14)(13,19)(16,32)(17,23)(18,36)(20,48)(21,27)(22,40)(24,30)(26,42)(28,34)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)')

# Isomorfismo encontrado por el algoritmo
phi = PermutationGroupElement('(1,27)(2,28)(3,25)(4,26)(5,23)(6,24)(7,21)(8,22)(9,19)(10,20)(11,17)(12,18)(13,15)(14,16)(29,39)(30,40)(31,37)(32,38)(33,35)(34,36)(41,47)(42,48)(43,45)(44,46)')

# Verificar las dos condiciones de isomorfismo
cond_sigma = phi * sigma * phi^(-1) == sigma
cond_rho   = phi * rho1  * phi^(-1) == rho2

print("Verificación de φ · σ · φ⁻¹ = σ  :", cond_sigma)
print("Verificación de φ · ρ₁ · φ⁻¹ = ρ₂:", cond_rho)

if cond_sigma and cond_rho:
    print()
    print("✓ CONFIRMADO: los dos diagramas de Heegaard")
    print("  representan el mismo encaje celular.")
    print()
    print("φ =", phi)
</script>
</div>
```
:::

::: {.content-visible when-format="pdf"}
```python
sigma = PermutationGroupElement('(1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16)(17,18,19,20)(21,22,23,24)(25,26,27,28)(29,30,31,32)(33,34,35,36)(37,38,39,40)(41,42,43,44)(45,46,47,48)')
rho1  = PermutationGroupElement('(1,7)(2,36)(3,25)(4,48)(5,11)(6,40)(8,30)(9,15)(10,42)(12,34)(13,19)(14,38)(16,18)(17,23)(20,22)(21,27)(24,26)(28,32)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)')
rho2  = PermutationGroupElement('(1,7)(2,38)(3,25)(4,6)(5,11)(8,10)(9,15)(12,14)(13,19)(16,32)(17,23)(18,36)(20,48)(21,27)(22,40)(24,30)(26,42)(28,34)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)')
phi   = PermutationGroupElement('(1,27)(2,28)(3,25)(4,26)(5,23)(6,24)(7,21)(8,22)(9,19)(10,20)(11,17)(12,18)(13,15)(14,16)(29,39)(30,40)(31,37)(32,38)(33,35)(34,36)(41,47)(42,48)(43,45)(44,46)')

print(phi * sigma * phi^(-1) == sigma)  # True
print(phi * rho1  * phi^(-1) == rho2)   # True
```
:::

---


## Ejercicios

::: {.callout-tip}
## Ejercicio 1: Verificación manual de la equivalencia

Verifica a mano que $\phi = (1,4)(2,3)(5,8)(6,7)(9,11)(10,12)$ es un isomorfismo entre los dos sistemas del ejemplo del moño y el ojo. Para ello comprueba las **dos** condiciones de equivalencia:

1. $\phi \cdot \sigma_1 \cdot \phi^{-1} = \sigma_2$  — aplica la conjugación dardo a dardo.
2. $\phi \cdot \rho \cdot \phi^{-1} = \rho$ — verifica que el emparejamiento de aristas se preserva.

Puedes ayudarte del código SageMath de la sección anterior, pero el objetivo es entender por qué cada transposición en $\phi$ envía correctamente cada ciclo al ciclo correspondiente.
:::

::: {.callout-tip}
## Ejercicio 2: Otro diagrama de Heegaard de la Esfera de Poincaré

La esfera de Poincaré admite varios diagramas de Heegaard. Busca en la literatura (o construye tú mismo) una descripción distinta a las dos presentadas aquí, que use también 12 vértices de valencia 4 (es decir, $n = 48$ dardos con $\sigma$ formada por ciclos de longitud 4).

Una vez tengas el sistema de rotación $(\sigma', \rho')$:

1. Verifica que es válido: $\sigma'$ formada por 12 cuatro-ciclos, $\rho'$ una involución fija sin puntos sobre $\{1,\ldots,48\}$.
2. Calcula sus invariantes ($V, E, F, \chi, g$) y comprueba que coinciden con los de los diagramas ya presentados.
3. Aplica la búsqueda con retroceso para determinar si es equivalente a alguno de los dos diagramas anteriores.
:::

## Resumen

- **Invariantes como filtro rápido:** Las longitudes de los ciclos de $\phi = \rho\sigma$ (las caras) son invariantes bajo isomorfismo. Si los multiconjuntos de longitudes difieren, la no-equivalencia queda probada sin necesidad de buscar $\phi$.
- **La estructura de $\sigma$ restringe la búsqueda:** Todo isomorfismo debe mapear ciclos de $\sigma_1$ a ciclos de $\sigma_2$ de la misma longitud, lo que reduce el espacio de búsqueda de $n!$ a un número mucho menor de candidatos.
- **Búsqueda con retroceso y propagación:** Fijar $\phi(d_1) = d_2$ determina automáticamente los demás dardos del mismo ciclo de $\sigma$ y el dardo emparejado en $\rho$. Las contradicciones se detectan y podan de inmediato, haciendo viable la búsqueda incluso para $n = 48$.
- **Unicidad en grafos 3-conexos:** Por el Teorema de Whitney (1932), todo grafo planar 3-conexo tiene un único encaje en la esfera. Steinitz (1922) había probado el resultado equivalente para poliedros convexos.
- **Diagramas de Heegaard como aplicación:** Los dos diagramas de la Esfera de Poincaré con 12 vértices de valencia 4 resultan ser equivalentes: el algoritmo encuentra en menos de 0.1 segundos el isomorfismo $\phi$ que los conjuga.

::: {style="text-align: center; margin-top: 3em; color: #94a3b8; font-size: 0.9em;"}
Publicado el 13 de febrero de 2026
:::