{
  "hash": "ccc6e88bc34daa1b87c7c66b661cc682",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Tutorial 3: Invariantes Topol√≥gicos\"\nauthor: \"Jos√© Luis\"\ndate: today\nformat:\n  html:\n    code-fold: true\n    toc: true\nexecute:\n  eval: false\n---\n\n# Invariantes de Ribbon Graphs\n\nLos **invariantes topol√≥gicos** son n√∫meros que caracterizan la superficie ribbon sin depender de c√≥mo la dibujemos.\n\n## Los 7 Invariantes Principales\n\n::: {#5f992f70 .cell execution_count=1}\n``` {.python .cell-code code-fold=\"false\"}\nload('../scripts/ribbongraph_visualizer.sage')\n\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\ninv = viz.invariantes()\n\nfor nombre, valor in inv.items():\n    print(f\"{nombre:30s} = {valor}\")\n```\n:::\n\n\n```\ngenus                          = 1\ncaras_mu                       = 1\nvertices                       = 2\naristas                        = 3\ncomponentes_frontera           = 1\neuler_char_superficie          = -1\nV-E+F(mu)                      = 0\n```\n\n## 1. G√©nero (g)\n\nEl **g√©nero** es el n√∫mero de \"agujeros\" de la superficie.\n\n::: {.panel-tabset}\n\n### Definici√≥n\n\n$$g = \\text{n√∫mero de agujeros}$$\n\n### Interpretaci√≥n\n\n- g = 0: Esfera (sin agujeros)\n- g = 1: Toro (1 agujero)\n- g = 2: Toro doble (2 agujeros)\n- g ‚â• 3: Superficies de g√©nero superior\n\n### C√°lculo\n\nSageMath calcula el g√©nero usando la f√≥rmula de Euler:\n\n$$g = \\frac{2 - \\chi - b}{2}$$\n\ndonde œá = V - E + F y b es el n√∫mero de fronteras.\n\n:::\n\n## 2. V√©rtices (V)\n\nN√∫mero de v√©rtices del grafo = n√∫mero de ciclos en œÉ.\n\n::: {#d0bdd04d .cell execution_count=2}\n``` {.python .cell-code code-fold=\"false\"}\nsigma = Permutation('(1,2,3)(4,5,6)')\nV = len(sigma.cycle_tuples())\nprint(f\"V√©rtices: {V}\")\n# Salida: V√©rtices: 2\n```\n:::\n\n\n::: {.callout-note}\nCada ciclo en œÉ representa un v√©rtice del grafo.\n:::\n\n## 3. Aristas (E)\n\nN√∫mero de aristas = n√∫mero de 2-ciclos en œÅ.\n\n::: {#f3aa2ae8 .cell execution_count=3}\n``` {.python .cell-code code-fold=\"false\"}\nrho = Permutation('(1,4)(2,5)(3,6)')\nE = len(rho.cycle_tuples())\nprint(f\"Aristas: {E}\")\n# Salida: Aristas: 3\n```\n:::\n\n\n::: {.callout-important}\nœÅ debe ser una **involuci√≥n** (producto de 2-ciclos disjuntos).\n:::\n\n## 4. Caras (F)\n\nN√∫mero de caras = n√∫mero de ciclos en Œº = œÉ¬∑œÅ.\n\n::: {#22df7490 .cell execution_count=4}\n``` {.python .cell-code code-fold=\"false\"}\nsigma = Permutation('(1,2,3)(4,5,6)')\nrho = Permutation('(1,4)(2,5)(3,6)')\nmu = sigma * rho\nF = len(mu.cycle_tuples())\nprint(f\"Caras: {F}\")\nprint(f\"Œº = {mu}\")\n# Salida:\n# Caras: 1\n# Œº = (1,5,3,4,2,6)\n```\n:::\n\n\n::: {.callout-tip}\n## Las caras son los \"pol√≠gonos\" de la superficie\n\nCada ciclo de Œº representa una cara. La longitud del ciclo es el n√∫mero de lados.\n:::\n\n## 5. Componentes de Frontera (b)\n\nN√∫mero de \"bordes\" de la superficie.\n\n::: {#ec34f01e .cell execution_count=5}\n``` {.python .cell-code code-fold=\"false\"}\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\nrg = viz.ribbon_graph\nb = rg.number_boundaries()\nprint(f\"Fronteras: {b}\")\n# Salida: Fronteras: 1\n```\n:::\n\n\n::: {.callout-note}\nLas fronteras se calculan usando el m√©todo `boundary()` de SageMath, que devuelve las componentes como listas de dardos.\n:::\n\n## 6. Caracter√≠stica de Euler (œá)\n\nHay dos formas de calcular œá:\n\n### œá de la Superficie\n\nPara una superficie con frontera:\n\n$$\\chi = 2 - 2g - b$$\n\n::: {#6a13bc3e .cell execution_count=6}\n``` {.python .cell-code code-fold=\"false\"}\ng = 1  # g√©nero\nb = 1  # fronteras\nchi_superficie = 2 - 2*g - b\nprint(f\"œá (superficie) = {chi_superficie}\")\n# Salida: œá (superficie) = -1\n```\n:::\n\n\n### œá del Grafo\n\nF√≥rmula cl√°sica de Euler:\n\n$$\\chi_{grafo} = V - E + F$$\n\n::: {#4a8eab70 .cell execution_count=7}\n``` {.python .cell-code code-fold=\"false\"}\nV, E, F = 2, 3, 1\nchi_grafo = V - E + F\nprint(f\"œá (grafo) = {chi_grafo}\")\n# Salida: œá (grafo) = 0\n```\n:::\n\n\n::: {.callout-warning}\n## ¬°Son diferentes!\n\n- œá_{superficie} considera la superficie con frontera\n- œá_{grafo} es la caracter√≠stica del grafo embebido\n:::\n\n## Tabla de Ejemplos\n\n| Ejemplo | œÉ | œÅ | V | E | F | g | b | œá |\n|---------|---|---|---|---|---|---|---|---|\n| Toro | (1,2,3)(4,5,6) | (1,4)(2,5)(3,6) | 2 | 3 | 1 | 1 | 1 | -1 |\n| Self-loops | (1,2,3,4) | (1,2)(3,4) | 1 | 2 | 1 | 0 | 3 | -1 |\n| Tri√°ngulo | (1,2)(3,4)(5,6) | (1,3)(2,5)(4,6) | 3 | 3 | 2 | 0 | 2 | 0 |\n| Theta | (1,2,3)(4,5,6) | (1,6)(2,4)(3,5) | 2 | 3 | 1 | 1 | 1 | -1 |\n\n## Verificaci√≥n de F√≥rmulas\n\nPara cada ribbon graph, podemos verificar:\n\n::: {#6df77214 .cell execution_count=8}\n``` {.python .cell-code code-fold=\"false\"}\ndef verificar_invariantes(sigma_str, rho_str):\n    viz = RibbonGraphVisualizer(sigma_str, rho_str)\n    inv = viz.invariantes()\n\n    # Verificar œá = 2 - 2g - b\n    chi_calc = 2 - 2*inv['genus'] - inv['componentes_frontera']\n    chi_real = inv['euler_char_superficie']\n\n    # Verificar V - E + F\n    vef = inv['V-E+F(mu)']\n\n    print(f\"Verificaci√≥n:\")\n    print(f\"  œá calculado (2-2g-b): {chi_calc}\")\n    print(f\"  œá real:               {chi_real}\")\n    print(f\"  Coinciden: {chi_calc == chi_real}\")\n    print(f\"  V - E + F:            {vef}\")\n\n    return inv\n\n# Probar con ejemplo\nverificar_invariantes('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\n```\n:::\n\n\n## Relaci√≥n entre Invariantes\n\nLas relaciones fundamentales:\n\n1. **F√≥rmula de Euler para superficies con frontera:**\n   $$\\chi = 2 - 2g - b$$\n\n2. **Relaci√≥n con el grafo:**\n   $$\\chi_{grafo} = V - E + F$$\n\n3. **Conexi√≥n:**\n   $$2 - 2g - b = V - E + F + \\text{(t√©rminos de ajuste)}$$\n\n::: {.callout-note}\n## La diferencia\n\nLa diferencia entre œá_{superficie} y œá_{grafo} depende de c√≥mo se cuentan las fronteras.\n:::\n\n## Ejercicio\n\n::: {.callout-tip icon=false}\n## üìù Ejercicio 3.1\n\nPara el ribbon graph œÉ = (1,2,3,4,5,6), œÅ = (1,2)(3,4)(5,6):\n\n1. Calcula V, E, F\n2. Calcula g y b\n3. Verifica œá = 2 - 2g - b\n4. Verifica V - E + F\n\n<details>\n<summary>Ver soluci√≥n</summary>\n\n```sage\nviz = RibbonGraphVisualizer('(1,2,3,4,5,6)', '(1,2)(3,4)(5,6)')\ninv = viz.invariantes()\n\n# 1. V, E, F\nV = inv['vertices']      # 1\nE = inv['aristas']       # 3\nF = inv['caras_mu']      # ?\n\n# 2. g, b\ng = inv['genus']\nb = inv['componentes_frontera']\n\n# 3. Verificar œá = 2 - 2g - b\nchi = 2 - 2*g - b\nprint(f\"œá = 2 - 2({g}) - {b} = {chi}\")\n\n# 4. Verificar V - E + F\nvef = V - E + F\nprint(f\"V - E + F = {V} - {E} + {F} = {vef}\")\n```\n\nResultado:\n- V = 1, E = 3, F = 1\n- g = 0, b = 4\n- œá = -2\n- V - E + F = -1\n</details>\n:::\n\n## Pr√≥ximos Pasos\n\nExplora m√°s ejemplos en [Notas: Ejemplos Cl√°sicos](../notas/ejemplos.qmd).\n\n## Referencias\n\n- Gross & Tucker, *Topological Graph Theory* (1987)\n- [Tutorial 1](01-introduccion.qmd) | [Tutorial 2](02-visualizacion.qmd)\n\n",
    "supporting": [
      "03-invariantes_files"
    ],
    "filters": [],
    "includes": {}
  }
}