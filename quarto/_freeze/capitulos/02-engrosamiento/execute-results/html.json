{
  "hash": "a6f59abf137b57ef242286cffc747d04",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"2. Proceso de Engrosamiento\"\nsubtitle: \"De permutaciones a superficies\"\n---\n\n# Proceso de Engrosamiento\n\n## Idea intuitiva\n\nEl **engrosamiento** (o *thickening*) es el procedimiento geométrico que transforma un sistema de rotación $(\\sigma, \\rho)$ en una superficie orientable con un grafo encajado.\n\n::: {.callout-note}\n## Metáfora\n\nImagina que el grafo es un \"esqueleto\" de alambre. El engrosamiento consiste en:\n1. Reemplazar cada vértice puntual por un pequeño **disco**\n2. Reemplazar cada arista (línea) por una **banda** (ribbon)\n3. Pegar las bandas a los bordes de los discos según el orden cíclico de $\\sigma$\n\nEl resultado es una superficie orientable con frontera que se \"retrae\" al grafo original.\n:::\n\n---\n\n## Construcción formal\n\nPara cualquier par $(\\sigma, \\rho)$, el engrosamiento produce una **superficie orientable con frontera** tal que:\n\n1. **Deformación fuerte:** La superficie se retrae fuertemente al grafo (son homotópicamente equivalentes)\n\n2. **Encaje celular:** El grafo queda encajado como un complejo celular en la superficie\n\n3. **Recuperación:** A partir del encaje podemos recuperar $\\sigma$ y $\\rho$\n\n---\n\n## Los 5 pasos de visualización\n\nNuestro sistema de visualización implementa el engrosamiento en 5 pasos progresivos:\n\n### Paso 1: Grafo base\n\nDibujamos el grafo abstracto como puntos (vértices) y líneas (aristas).\n\n- Vértices: puntos pequeños\n- Aristas: líneas rectas\n- Posiciones calculadas con layout circular o spring\n\n### Paso 2: Semiaristas en los bordes\n\nMostramos las semiaristas (darts) como pequeños círculos coloreados en el **borde** de cada vértice.\n\n- Cada semiarista se posiciona en el perímetro del vértice\n- La posición angular refleja el orden cíclico de $\\sigma$\n- Colores distinguen las semiaristas\n\n### Paso 3: Engrosar vértices\n\nReemplazamos los vértices puntuales por **discos** (círculos rellenos).\n\n- Cada vértice se convierte en un disco amarillo\n- El borde del disco muestra las semiaristas\n- El orden cíclico se hace visualmente explícito\n\n### Paso 4: Engrosar aristas (ribbons)\n\nReemplazamos cada arista por una **banda** (polígono de 4 vértices).\n\n- Las bandas son regiones azules que conectan dos discos\n- Cada banda se pega a los puntos donde están las semiaristas correspondientes\n- Las bandas pueden torcerse (self-loops) o cruzarse\n\n### Paso 5: Componentes de frontera\n\nDestacamos las **componentes de frontera** de la superficie.\n\n- Calculamos $\\varphi = \\rho^{-1}\\sigma^{-1}$ (permutación de caras)\n- Cada ciclo de $\\varphi$ es una componente de frontera\n- Las fronteras se dibujan con líneas rojas gruesas\n\n---\n\n## Implementación en SageMath\n\nEl módulo `ribbongraph_visualizer.sage` implementa esta visualización:\n\n::: {#9e66ab2a .cell execution_count=1}\n``` {.python .cell-code}\n# Cargar el módulo (asumiendo que está en el PATH)\nload('ribbongraph_visualizer.sage')\n\n# Crear un sistema de rotación (ejemplo: toro)\nviz = RibbonGraphVisualizer('(1,2,3,4)', '(1,2)(3,4)')\n\n# Mostrar invariantes\nviz.mostrar_invariantes()\n\n# Generar los 5 pasos de visualización\narchivos = viz.generar_secuencia_completa(\n    output_dir='../outputs/imagenes',\n    prefix='toro_'\n)\n\nprint(\"Imágenes generadas:\")\nfor archivo in archivos:\n    print(f\"  - {archivo}\")\n```\n:::\n\n\n**Salida:**\n```\n=== Invariantes del Ribbon Graph ===\nVértices (V): 1\nAristas (E): 2\nCaras (F): 1\nCaracterística de Euler (χ): 0\nGénero (g): 1\nComponentes de frontera (b): 0\n\nImágenes generadas:\n  - ../outputs/imagenes/toro_paso1_base.png\n  - ../outputs/imagenes/toro_paso2_darts.png\n  - ../outputs/imagenes/toro_paso3_vertices.png\n  - ../outputs/imagenes/toro_paso4_ribbons.png\n  - ../outputs/imagenes/toro_paso5_boundary.png\n```\n\n---\n\n## Visualización paso a paso\n\n### Generar solo un paso específico\n\n::: {#97be42b0 .cell execution_count=2}\n``` {.python .cell-code}\nviz = RibbonGraphVisualizer('(1,2,3,4)', '(1,2)(3,4)')\n\n# Solo el grafo base\nviz.paso_1_grafo_base(save_to='paso1.png')\n\n# Solo vértices engrosados\nviz.paso_3_engrosar_vertices(save_to='paso3.png')\n\n# Solo ribbons\nviz.paso_4_engrosar_aristas(save_to='paso4.png')\n```\n:::\n\n\n### Personalizar la visualización\n\n::: {#a05cc2f9 .cell execution_count=3}\n``` {.python .cell-code}\n# Ajustar tamaños\nviz.paso_3_engrosar_vertices(\n    radio_vertice=0.5,      # Discos más grandes\n    save_to='vertices_grandes.png'\n)\n\n# Ajustar grosor de ribbons\nviz.paso_4_engrosar_aristas(\n    ancho_ribbon=0.15,      # Bandas más anchas\n    save_to='ribbons_anchos.png'\n)\n\n# Cambiar fase de rotación para self-loops\nviz = RibbonGraphVisualizer(\n    '(1,2,3,4)',\n    '(1,2)(3,4)',\n    phase=0.3              # Ajuste fino de posiciones\n)\n```\n:::\n\n\n---\n\n## Ejemplo completo: Tres casos\n\n::: {#f7e286f8 .cell execution_count=4}\n``` {.python .cell-code}\n# Ejemplo 1: Toro (género 1, sin frontera)\nprint(\"=== Ejemplo 1: Toro ===\")\nviz1 = RibbonGraphVisualizer('(1,2,3,4)', '(1,2)(3,4)')\nviz1.mostrar_invariantes()\nviz1.generar_secuencia_completa(\n    output_dir='../outputs/imagenes',\n    prefix='ejemplo1_toro_'\n)\n\n# Ejemplo 2: Self-loops con frontera\nprint(\"\\n=== Ejemplo 2: Con frontera ===\")\nviz2 = RibbonGraphVisualizer('(1,2,3)', '(1,2)')\nviz2.mostrar_invariantes()\nviz2.generar_secuencia_completa(\n    output_dir='../outputs/imagenes',\n    prefix='ejemplo2_frontera_'\n)\n\n# Ejemplo 3: Triángulo K3\nprint(\"\\n=== Ejemplo 3: K3 ===\")\nviz3 = RibbonGraphVisualizer('(1,6)(2,3)(4,5)', '(1,2)(3,4)(5,6)')\nviz3.mostrar_invariantes()\nviz3.generar_secuencia_completa(\n    output_dir='../outputs/imagenes',\n    prefix='ejemplo3_k3_'\n)\n```\n:::\n\n\n---\n\n## Interpretación topológica\n\nDespués del engrosamiento, obtenemos:\n\n::: {.callout-important}\n## Resultado del engrosamiento\n\n- Una **superficie orientable** $S$ (posiblemente con frontera)\n- Un **grafo** $G$ encajado en $S$\n- El encaje es **celular**: cada cara es homeomorfa a un disco\n- $S$ se retrae a $G$: son homotópicamente equivalentes\n:::\n\n### Propiedades clave\n\n1. **Orientabilidad:** La superficie siempre es orientable (por construcción)\n\n2. **Frontera:** Si hay componentes de frontera ($b > 0$), la superficie es una superficie con agujeros\n\n3. **Género:** Calculable desde la característica de Euler:\n   $$\\chi = V - E + F = 2 - 2g - b$$\n\n4. **Unicidad:** El sistema $(\\sigma, \\rho)$ determina la superficie salvo homeomorfismo que preserva orientación\n\n---\n\n## Del thickening al pegado de polígonos\n\nUna forma alternativa de visualizar el engrosamiento es mediante **pegado de polígonos**:\n\n### Construcción\n\n1. **Por cada cara:** Tomar un polígono regular con tantos lados como la longitud del ciclo de $\\varphi$\n\n2. **Etiquetar lados:** Los lados del polígono se etiquetan con las semiaristas del ciclo\n\n3. **Pegar por pares:** Los lados se pegan según $\\rho$ (con orientaciones opuestas)\n\n4. **Identificar vértices:** Los vértices de los polígonos se identifican según los ciclos de $\\sigma$\n\n::: {.callout-note}\n## Resultado\n\nEsta construcción produce exactamente la misma superficie que el engrosamiento del grafo.\n:::\n\n---\n\n## Conexión con el Teorema de Heffter-Edmonds\n\nEl engrosamiento es la construcción explícita que prueba una dirección del Teorema de Heffter-Edmonds:\n\n::: {.callout-important}\n## Teorema (Heffter-Edmonds, parte constructiva)\n\nTodo sistema de rotación $(\\sigma, \\rho)$ induce un ribbon graph (y por tanto un encaje celular en una superficie orientable).\n:::\n\nLa dirección recíproca (todo encaje induce un sistema de rotación) se obtiene \"leyendo\" el orden cíclico en cada vértice y el emparejamiento de semiaristas del encaje dado.\n\n---\n\n## Ejercicios\n\n::: {.callout-tip}\n## Ejercicio 1: Visualización\n\nToma el sistema de rotación:\n- $\\sigma = (1,2)(3,4)(5,6)$\n- $\\rho = (1,2)(3,4)(5,6)$\n\na) Usa el visualizador para generar los 5 pasos\nb) ¿Qué grafo obtienes?\nc) ¿Cuál es el género?\nd) ¿Hay frontera?\n:::\n\n::: {.callout-tip}\n## Ejercicio 2: Experimentación\n\nConsidera el bouquet de 3 círculos: un vértice con 3 self-loops (6 semiaristas).\n\na) Experimenta con diferentes $\\sigma$ (manteniendo $\\rho$ fijo)\nb) Genera visualizaciones para cada caso\nc) ¿Cómo varía el género?\nd) ¿Cuántas configuraciones distintas puedes obtener?\n:::\n\n::: {.callout-tip}\n## Ejercicio 3: Modificación del código\n\nModifica `ribbongraph_visualizer.sage` para:\n\na) Cambiar los colores de los discos y ribbons\nb) Agregar un paso 6 que muestre las caras como regiones coloreadas\nc) Exportar los gráficos en formato SVG además de PNG\n:::\n\n---\n\n## Resumen\n\n- El **engrosamiento** transforma $(\\sigma, \\rho)$ en una superficie con grafo encajado\n- Construcción: vértices → discos, aristas → bandas\n- Visualización en 5 pasos progresivos\n- Implementado en `ribbongraph_visualizer.sage`\n- Construcción equivalente: pegado de polígonos\n- Prueba constructiva del Teorema de Heffter-Edmonds\n\nEn el siguiente capítulo veremos cómo calcular los **invariantes topológicos** (caras, género, componentes de frontera) directamente desde las permutaciones, sin necesidad de visualizar la superficie.\n\n",
    "supporting": [
      "02-engrosamiento_files"
    ],
    "filters": [],
    "includes": {}
  }
}