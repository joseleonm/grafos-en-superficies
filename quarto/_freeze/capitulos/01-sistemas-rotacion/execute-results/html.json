{
  "hash": "91928bd6076da3b2c16a0e67986d1e6a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"1. Sistemas de Rotación\"\nsubtitle: \"Modelo combinatorio de grafos encajados\"\n---\n\n# Sistemas de Rotación\n\n## Motivación\n\nQueremos codificar encajes celulares de grafos en superficies orientables **sin dibujar la superficie**, usando sólo datos combinatorios.\n\n- **Entrada:** un grafo abstracto $G$\n- **Dato extra:** un sistema de rotación (orden cíclico local)\n- **Salida:** una superficie orientable donde $G$ queda encajado, más las caras y el género\n\nLa idea es que la información \"local\" (en vértices) determine completamente la estructura \"global\" (la superficie).\n\n---\n\n## Semiaristas (Darts o Half-Edges)\n\nConsideremos un grafo $G$ (no necesariamente encajado en una superficie). Para trabajar con sistemas de rotación, dividimos cada arista en dos **semiaristas** (también llamadas *darts*, *half-edges* o *flags*).\n\nInsertamos un vértice ficticio en el interior de cada arista, creando dos semiaristas que:\n- Comparten la arista original\n- Tienen orientaciones opuestas\n- Se etiquetan con números\n\n::: {.callout-note}\n## Conteo de semiaristas\nSi el grafo tiene $E$ aristas, tendremos $|D| = 2E$ semiaristas en total, donde $D$ es el conjunto de todas las semiaristas.\n:::\n\n---\n\n## Definición: Sistema de Rotación\n\nUn **sistema de rotación** sobre un grafo $G$ se define por un par de permutaciones $(\\sigma, \\rho)$ sobre el conjunto de semiaristas $D$:\n\n### Permutación $\\sigma$ (vértices)\n\n- Es un producto de ciclos disjuntos\n- Hay un ciclo por cada vértice de $G$\n- Cada ciclo describe el **orden cíclico** de las semiaristas incidentes a ese vértice\n- El orden cíclico refleja cómo las aristas se ordenan alrededor del vértice en la superficie\n\n### Permutación $\\rho$ (aristas)\n\n- Es un producto de **2-ciclos** (transposiciones)\n- Cada 2-ciclo empareja las dos semiaristas que forman una arista\n- Es una involución sin puntos fijos: $\\rho^2 = \\mathrm{id}$\n\n::: {.callout-tip}\n## Notación en la literatura\n\n- **Lando–Zvonkin:** usan $\\alpha$ en lugar de $\\rho$\n- **SageMath:** usa `sigma` y `rho` como argumentos de `RibbonGraph`\n- En este texto usamos $\\sigma$ y $\\rho$ para consistencia con Sage\n:::\n\n---\n\n## Ejemplo 1: Un vértice, dos self-loops (el toro)\n\nConsideremos el ejemplo más simple que produce un toro: un grafo con un vértice y dos self-loops.\n\n### Construcción\n\n- **Vértice:** 1\n- **Aristas:** 2 self-loops\n- **Semiaristas:** 4 (etiquetadas 1, 2, 3, 4)\n\n```python\nfrom sage.graphs.ribbon_graph import RibbonGraph\n\n# Orden cíclico alrededor del vértice: 1 → 2 → 3 → 4 → 1\nsigma = '(1,2,3,4)'\n\n# Emparejamiento de semiaristas en aristas:\n# - Arista 1: semiaristas 1 y 2\n# - Arista 2: semiaristas 3 y 4\nrho = '(1,2)(3,4)'\n\n# Crear el ribbon graph\nR = RibbonGraph(sigma, rho)\n\n# Calcular invariantes\nprint(f\"Número de vértices: {R.num_vertices()}\")\nprint(f\"Número de aristas: {R.num_edges()}\")\nprint(f\"Género: {R.genus()}\")\nprint(f\"Componentes de frontera: {R.number_boundaries()}\")\n```\n\n**Salida esperada:**\n```\nNúmero de vértices: 1\nNúmero de aristas: 2\nGénero: 1\nComponentes de frontera: 0\n```\n\nEste sistema de rotación describe un encaje en el toro (género 1, sin frontera).\n\n---\n\n## Ejemplo 2: Triángulo K₃\n\nConsideremos el grafo completo con 3 vértices: $K_3$.\n\n### Construcción\n\n- **Vértices:** 3 (llamémoslos A, B, C)\n- **Aristas:** 3 (AB, BC, CA)\n- **Semiaristas:** 6 (etiquetadas 1, 2, 3, 4, 5, 6)\n\nAsignación de semiaristas:\n- Vértice A: semiaristas 1, 6\n- Vértice B: semiaristas 2, 3\n- Vértice C: semiaristas 4, 5\n\nAristas:\n- AB: semiaristas 1 y 2\n- BC: semiaristas 3 y 4\n- CA: semiaristas 5 y 6\n\n```python\n# Orden cíclico en cada vértice\n# A: 1 → 6\n# B: 2 → 3\n# C: 4 → 5\nsigma = '(1,6)(2,3)(4,5)'\n\n# Emparejamiento\nrho = '(1,2)(3,4)(5,6)'\n\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Género: {R.genus()}\")\nprint(f\"Número de caras: {len(list(R.faces()))}\")\n```\n\n---\n\n## Interpretación geométrica\n\nEl sistema de rotación $(\\sigma, \\rho)$ codifica:\n\n1. **El grafo subyacente**\n   - Los ciclos de $\\sigma$ determinan los vértices\n   - Los 2-ciclos de $\\rho$ determinan las aristas\n   - Podemos reconstruir $G$ desde $(\\sigma, \\rho)$\n\n2. **El orden cíclico local**\n   - Cada ciclo de $\\sigma$ indica cómo se ordenan las semiaristas alrededor de un vértice\n   - Este orden respeta la orientación de la superficie\n\n3. **La estructura global**\n   - Las caras se obtienen con $\\varphi = \\rho^{-1}\\sigma^{-1}$ (veremos esto en el capítulo 3)\n   - El género se calcula con la característica de Euler\n\n---\n\n## Equivalencia con ribbon graphs\n\n::: {.callout-important}\n## Proposición fundamental\n\nTodo sistema de rotación $(\\sigma, \\rho)$ determina únicamente un **ribbon graph** (grafo con bandas), que es un grafo encajado en una superficie orientable con frontera.\n\nRecíprocamente, todo ribbon graph determina un único sistema de rotación.\n:::\n\nEsta equivalencia se establece mediante el **proceso de engrosamiento**, que estudiaremos en el siguiente capítulo.\n\n---\n\n## Construcción en SageMath\n\nSageMath implementa ribbon graphs directamente desde sistemas de rotación:\n\n::: {#b439a851 .cell execution_count=1}\n``` {.python .cell-code}\nfrom sage.graphs.ribbon_graph import RibbonGraph\nfrom sage.groups.perm_gps.permgroup_named import SymmetricGroup\n\n# Método 1: Usar strings (más simple)\nR1 = RibbonGraph('(1,2,3)', '(1,2)(3)')\n\n# Método 2: Usar permutaciones del grupo simétrico\nS = SymmetricGroup(4)\nsigma = S('(1,2,3,4)')\nrho = S('(1,2)(3,4)')\nR2 = RibbonGraph(sigma, rho)\n\n# Método 3: Desde listas de ciclos\nsigma = [[1,2,3,4]]          # Un ciclo\nrho = [[1,2], [3,4]]         # Dos 2-ciclos\nR3 = RibbonGraph(sigma, rho)\n```\n:::\n\n\n---\n\n## Ejercicios\n\n::: {.callout-tip}\n## Ejercicio 1\nConsidera un grafo con un vértice y tres self-loops (tres aristas que comienzan y terminan en el mismo vértice).\n\na) ¿Cuántas semiaristas tiene este sistema?\nb) Escribe un sistema de rotación $(\\sigma, \\rho)$ para este grafo.\nc) Usa Sage para calcular el género de la superficie resultante.\n:::\n\n::: {.callout-tip}\n## Ejercicio 2\nConsidera el \"bouquet\" de dos círculos: un vértice con dos self-loops.\n\na) Experimenta con diferentes órdenes cíclicos en $\\sigma$ (manteniendo $\\rho$ fijo).\nb) ¿Cambia el género?\nc) ¿Qué permanece invariante?\n:::\n\n---\n\n## Resumen\n\n- Un **sistema de rotación** $(\\sigma, \\rho)$ es un par de permutaciones sobre semiaristas\n- $\\sigma$ codifica el orden cíclico alrededor de cada vértice\n- $\\rho$ empareja semiaristas en aristas (involución de 2-ciclos)\n- Equivalencia fundamental: sistemas de rotación ↔ ribbon graphs\n- SageMath: `RibbonGraph(sigma, rho)`\n\nEn el siguiente capítulo veremos cómo convertir estos datos combinatorios en una superficie geométrica mediante el **proceso de engrosamiento**.\n\n",
    "supporting": [
      "01-sistemas-rotacion_files"
    ],
    "filters": [],
    "includes": {}
  }
}