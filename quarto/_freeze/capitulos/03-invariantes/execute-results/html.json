{
  "hash": "c0d937c536a2b9511cd0f0a2841cf583",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"3. Invariantes Topológicos\"\nsubtitle: \"Cálculo desde las permutaciones\"\n---\n\n# Invariantes Topológicos\n\n## Introducción\n\nUna vez que tenemos un sistema de rotación $(\\sigma, \\rho)$, podemos calcular todos los invariantes topológicos de la superficie resultante **sin necesidad de visualizarla**. Los cálculos se hacen directamente sobre las permutaciones.\n\nLos invariantes principales son:\n\n- Número de **vértices** ($V$)\n- Número de **aristas** ($E$)\n- Número de **caras** ($F$)\n- **Característica de Euler** ($\\chi = V - E + F$)\n- **Género** ($g$)\n- **Componentes de frontera** ($b$)\n\n---\n\n## Lectura de caras: la permutación $\\varphi$\n\n### Convención para etiquetar caras\n\nPara identificar las caras del encaje celular, usamos una convención de etiquetado:\n\n::: {.callout-note}\n## Convención de etiquetado\n\nAl recorrer una semiarista desde un vértice, colocamos su etiqueta en el **lado izquierdo** del trazo.\n\nUna semiarista es **incidente** a una cara si su etiqueta queda dentro de esa cara.\n:::\n\nCon esta convención, cada cara queda descrita por un ciclo de semiaristas en sentido **antihorario** (positivo).\n\n### Definición de $\\varphi$\n\nLa **permutación de caras** $\\varphi$ se define como:\n\n$$\n\\varphi = \\rho^{-1}\\sigma^{-1}\n$$\n\nComo $\\rho$ es una involución ($\\rho^2 = \\mathrm{id}$), tenemos $\\rho^{-1} = \\rho$, por lo que también se escribe:\n\n$$\n\\varphi = \\rho\\,\\sigma^{-1}\n$$\n\nForma equivalente:\n$$\n\\sigma\\,\\rho\\,\\varphi = \\mathrm{id}\n$$\n\n::: {.callout-important}\n## Interpretación\n\nLos **ciclos de $\\varphi$** corresponden biunívocamente a las **caras** del encaje celular (o equivalentemente, a las componentes de frontera del ribbon graph).\n:::\n\n---\n\n## Algoritmo de trazado de caras (Face Tracing)\n\nPara recorrer una cara en sentido positivo, desde una semiarista $d$ aplicamos repetidamente:\n\n$$\nd \\longmapsto \\varphi(d) = \\rho^{-1}\\sigma^{-1}(d)\n$$\n\n### Interpretación local\n\nLa regla se puede entender como dos pasos:\n\n1. **$\\rho^{-1}$:** Cruzar la arista (pasar a la semiarista \"opuesta\")\n2. **$\\sigma^{-1}$:** Tomar la semiarista \"anterior\" en el orden cíclico del vértice\n\nUn ciclo cerrado de $\\varphi$ da la frontera completa de una cara. Repitiendo con semiaristas no usadas, obtenemos todas las caras.\n\n---\n\n## Ejemplo: Cálculo manual de $\\varphi$\n\nConsideremos el sistema:\n- $\\sigma = (1,2,3,4)$\n- $\\rho = (1,2)(3,4)$\n\n### Paso 1: Calcular $\\sigma^{-1}$\n\n$\\sigma^{-1} = (4,3,2,1) = (1,4,3,2)$\n\n### Paso 2: Calcular $\\rho^{-1}$\n\nComo $\\rho$ es involución: $\\rho^{-1} = \\rho = (1,2)(3,4)$\n\n### Paso 3: Componer $\\varphi = \\rho\\,\\sigma^{-1}$\n\nAplicamos $\\varphi$ a cada semiarista:\n\n- $\\varphi(1) = \\rho(\\sigma^{-1}(1)) = \\rho(4) = 3$\n- $\\varphi(2) = \\rho(\\sigma^{-1}(2)) = \\rho(1) = 2$\n- $\\varphi(3) = \\rho(\\sigma^{-1}(3)) = \\rho(2) = 1$\n- $\\varphi(4) = \\rho(\\sigma^{-1}(4)) = \\rho(3) = 4$\n\nPor tanto: $\\varphi = (1,3)(2)(4)$\n\nTenemos **3 ciclos**, pero observemos mejor:\n- Ciclo $(1,3)$: cara de longitud 2\n- Ciclo $(2)$: punto fijo (cara de longitud 1)\n- Ciclo $(4)$: punto fijo (cara de longitud 1)\n\nEspera, esto no es correcto. Verifiquemos...\n\n**Corrección:** Al componer permutaciones, debemos leer de derecha a izquierda:\n\n$\\varphi(1) = \\rho(\\sigma^{-1}(1)) = \\rho(4) = 3$\n$\\varphi(3) = \\rho(\\sigma^{-1}(3)) = \\rho(2) = 1$\n\nEntonces: $\\varphi = (1,3,\\ldots)$\n\nContinuando el ciclo:\n$\\varphi(1) = 3$\n$\\varphi(3) = 1$\n\nY para 2:\n$\\varphi(2) = \\rho(\\sigma^{-1}(2)) = \\rho(1) = 2$ ¡Incorrecto!\n\nMejor usemos Sage para los cálculos...\n\n---\n\n## Cálculo en SageMath\n\nSageMath calcula automáticamente todas las caras:\n\n::: {#b7cc0350 .cell execution_count=1}\n``` {.python .cell-code}\nfrom sage.graphs.ribbon_graph import RibbonGraph\n\n# Ejemplo: toro\nR = RibbonGraph('(1,2,3,4)', '(1,2)(3,4)')\n\n# Obtener las caras (componentes de frontera)\ncaras = list(R.faces())\nprint(f\"Número de caras: {len(caras)}\")\nprint(f\"Caras: {caras}\")\n\n# También podemos usar boundary()\nfronteras = R.boundary()\nprint(f\"Componentes de frontera: {fronteras}\")\n```\n:::\n\n\n**Salida:**\n```\nNúmero de caras: 1\nCaras: [[1, 4, 3, 2]]\nComponentes de frontera: [[1, 4, 3, 2]]\n```\n\n---\n\n## Característica de Euler\n\nUna vez conocemos $V$, $E$ y $F$, calculamos la característica de Euler:\n\n$$\n\\chi = V - E + F\n$$\n\n### Cálculo desde las permutaciones\n\n- **$V$** = número de ciclos de $\\sigma$\n- **$E$** = número de 2-ciclos de $\\rho$ = $|D|/2$ (donde $|D|$ es el número de semiaristas)\n- **$F$** = número de ciclos de $\\varphi$\n\n::: {#04efd85a .cell execution_count=2}\n``` {.python .cell-code}\n# Ejemplo\nsigma = '(1,2,3,4)'              # 1 ciclo → V = 1\nrho = '(1,2)(3,4)'               # 2 ciclos → E = 2\n# D = 4 semiaristas\n\nR = RibbonGraph(sigma, rho)\n\nV = R.num_vertices()             # 1\nE = R.num_edges()                # 2\nF = len(list(R.faces()))         # 1\n\nchi = V - E + F\nprint(f\"χ = {V} - {E} + {F} = {chi}\")\n```\n:::\n\n\n**Salida:**\n```\nχ = 1 - 2 + 1 = 0\n```\n\n---\n\n## Género\n\nPara superficies orientables cerradas (sin frontera), la relación es:\n\n$$\n\\chi = 2 - 2g\n$$\n\nDe donde:\n$$\ng = 1 - \\frac{\\chi}{2} = \\frac{2-\\chi}{2}\n$$\n\n### Casos con frontera\n\nPara superficies con frontera, la fórmula se generaliza:\n\n$$\n\\chi = 2 - 2g - b\n$$\n\ndonde $b$ es el número de componentes de frontera.\n\nDe aquí:\n$$\ng = \\frac{2 - \\chi - b}{2}\n$$\n\n::: {#ee7693a4 .cell execution_count=3}\n``` {.python .cell-code}\nR = RibbonGraph('(1,2,3,4)', '(1,2)(3,4)')\n\n# Sage calcula directamente\ng = R.genus()\nb = R.number_boundaries()\n\nprint(f\"Género: {g}\")\nprint(f\"Componentes de frontera: {b}\")\n\n# Verificar con la fórmula\nchi = R.num_vertices() - R.num_edges() + len(list(R.faces()))\ng_calculado = (2 - chi - b) // 2\n\nprint(f\"Verificación: g = (2 - {chi} - {b})/2 = {g_calculado}\")\n```\n:::\n\n\n**Salida:**\n```\nGénero: 1\nComponentes de frontera: 0\nVerificación: g = (2 - 0 - 0)/2 = 1\n```\n\n---\n\n## Tabla de ejemplos\n\n| Ejemplo | $\\sigma$ | $\\rho$ | V | E | F | $\\chi$ | g | b |\n|---------|----------|---------|---|---|---|---------|---|---|\n| Toro | $(1,2,3,4)$ | $(1,2)(3,4)$ | 1 | 2 | 1 | 0 | 1 | 0 |\n| Disco | $(1,2,3)$ | $(1,2)$ | 1 | 1 | 1 | 1 | 0 | 1 |\n| K₃ plano | $(1,6)(2,3)(4,5)$ | $(1,2)(3,4)(5,6)$ | 3 | 3 | 2 | 2 | 0 | 0 |\n| Bouquet 3 | $(1,2,3,4,5,6)$ | $(1,2)(3,4)(5,6)$ | 1 | 3 | 1 | -1 | 1 | 0 |\n\n---\n\n## Implementación: función auxiliar\n\nPodemos crear una función para calcular todos los invariantes:\n\n::: {#20b097b1 .cell execution_count=4}\n``` {.python .cell-code}\ndef calcular_invariantes(sigma, rho):\n    \"\"\"\n    Calcula todos los invariantes topológicos de un sistema de rotación.\n    \"\"\"\n    R = RibbonGraph(sigma, rho)\n\n    V = R.num_vertices()\n    E = R.num_edges()\n    F = len(list(R.faces()))\n    chi = V - E + F\n    g = R.genus()\n    b = R.number_boundaries()\n\n    print(f\"{'='*50}\")\n    print(f\"Sistema de Rotación\")\n    print(f\"{'='*50}\")\n    print(f\"σ = {sigma}\")\n    print(f\"ρ = {rho}\")\n    print(f\"{'-'*50}\")\n    print(f\"Vértices (V):              {V}\")\n    print(f\"Aristas (E):               {E}\")\n    print(f\"Caras (F):                 {F}\")\n    print(f\"Característica de Euler:   χ = {chi}\")\n    print(f\"Género:                    g = {g}\")\n    print(f\"Componentes de frontera:   b = {b}\")\n    print(f\"{'='*50}\")\n    print(f\"Fórmula: χ = 2 - 2g - b = {2 - 2*g - b} ✓\")\n    print(f\"{'='*50}\")\n\n    return {\n        'V': V, 'E': E, 'F': F,\n        'chi': chi, 'g': g, 'b': b\n    }\n\n# Uso\ninv = calcular_invariantes('(1,2,3,4)', '(1,2)(3,4)')\n```\n:::\n\n\n---\n\n## Aplicación: clasificación de superficies\n\nLa característica de Euler y el género permiten **clasificar** completamente las superficies orientables compactas:\n\n::: {.callout-important}\n## Teorema de Clasificación\n\nToda superficie orientable compacta sin frontera es homeomorfa a:\n\n- La **esfera** ($g = 0$, $\\chi = 2$)\n- El **toro** ($g = 1$, $\\chi = 0$)\n- La **suma conexa de $g$ toros** ($g \\geq 2$, $\\chi = 2 - 2g$)\n:::\n\nCon frontera, agregamos \"agujeros\":\n\n- Superficie de género $g$ con $b$ agujeros tiene $\\chi = 2 - 2g - b$\n\n---\n\n## Ejercicios\n\n::: {.callout-tip}\n## Ejercicio 1: Cálculo manual\n\nPara el sistema $\\sigma = (1,2)(3,4)(5,6)$, $\\rho = (1,2)(3,4)(5,6)$:\n\na) Calcula $\\sigma^{-1}$ y $\\rho^{-1}$\nb) Calcula $\\varphi = \\rho\\,\\sigma^{-1}$\nc) ¿Cuántas caras hay?\nd) Calcula $V$, $E$, $F$, $\\chi$, $g$\ne) Verifica con Sage\n:::\n\n::: {.callout-tip}\n## Ejercicio 2: Experimentación\n\nGenera 10 sistemas de rotación aleatorios con 6 semiaristas.\n\na) Calcula sus invariantes\nb) ¿Cuántos géneros distintos obtienes?\nc) ¿Cuál es el género máximo posible con 6 semiaristas?\n:::\n\n::: {.callout-tip}\n## Ejercicio 3: Superficies con frontera\n\nEncuentra sistemas de rotación que produzcan:\n\na) Un disco (g=0, b=1)\nb) Un cilindro (g=0, b=2)\nc) Un anillo en el toro (g=1, b=1)\nd) Verifica tus construcciones con Sage\n:::\n\n---\n\n## Resumen\n\n- La **permutación de caras** es $\\varphi = \\rho^{-1}\\sigma^{-1}$\n- Los ciclos de $\\varphi$ corresponden a las caras (componentes de frontera)\n- **Algoritmo de face tracing:** aplicar $\\varphi$ iteradamente\n- Invariantes básicos: $V$ (ciclos de $\\sigma$), $E$ (ciclos de $\\rho$), $F$ (ciclos de $\\varphi$)\n- **Característica de Euler:** $\\chi = V - E + F$\n- **Género:** $g = \\frac{2 - \\chi - b}{2}$\n- Sage: `R.genus()`, `R.number_boundaries()`, `R.faces()`\n\nEn el siguiente capítulo estudiaremos los **teoremas fundamentales** que establecen la equivalencia entre sistemas de rotación y encajes celulares (Teorema de Heffter-Edmonds) y las propiedades de los mapas combinatorios.\n\n",
    "supporting": [
      "03-invariantes_files"
    ],
    "filters": [],
    "includes": {}
  }
}