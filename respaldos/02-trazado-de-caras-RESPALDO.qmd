---
title: "2. Trazado de Caras"
subtitle: "El algoritmo combinatorio"
---

# El Algoritmo de Trazado de Caras

Para determinar las caras de un encaje celular dado por un sistema de rotación $(\sigma, \rho)$, utilizamos el algoritmo de trazado de caras (*Face Tracing*). Este procedimiento nos permite identificar los ciclos de semiaristas que conforman los bordes de las caras.

## La Permutación de Caras $\varphi$

En la convención moderna (utilizada por SageMath), las caras están determinadas por las órbitas de la permutación $\varphi$, definida como:

$$ \varphi = \rho^{-1} \sigma^{-1} = (\sigma \rho)^{-1} $$

Dado que $\rho$ es una involución ($\rho^{-1} = \rho$), esto es equivalente a $\varphi = \rho \sigma^{-1}$.

::: {.callout-important}
## Convención de Multiplicación (SageMath)
En este curso y en SageMath, la multiplicación de permutaciones se lee de **izquierda a derecha**.
La expresión $\varphi = \rho \sigma^{-1}$ significa: **primero** aplicamos $\rho$ (cruzar la arista) y **luego** aplicamos $\sigma^{-1}$ (girar en el vértice).
:::

## La Receta Geométrica: Cruzar y Girar

El cálculo de $\varphi(d)$ para una semiarista $d$ sigue estos pasos geométricos:

1.  **Cruzar la arista:** Desde $d$, vamos al otro extremo de la arista aplicando $\rho$.
2.  **Girar en el vértice:** En el nuevo vértice, tomamos la siguiente semiarista en el orden inverso al de rotación ($\sigma^{-1}$).

Esto corresponde a recorrer el borde de la cara manteniéndola siempre a la **derecha** (sentido horario).

## Ejemplo: Un vértice, dos lazos

Consideremos el grafo con un vértice y dos lazos (aristas que empiezan y terminan en el mismo vértice).
Tenemos 4 semiaristas: $D = \{1, 2, 3, 4\}$.
La permutación de aristas es fija: $\rho = (1, 2)(3, 4)$.

![](/imagenes/grafo8.svg){width=44%}

Vamos a calcular las caras para dos elecciones distintas de $\sigma$, mostrando cómo el orden cíclico afecta la topología.

### Caso A: Encaje en la Esfera ($g=0$)

Elegimos el orden cíclico natural:
$$ \sigma = (1, 2, 3, 4) $$

Calculamos $\varphi = \rho \sigma^{-1}$:

1.  **Paso a paso (Cruzar $\to$ Girar):**
    *   <span style="color: #D32F2F;">$1 \xrightarrow{\rho} 2 \xrightarrow{\sigma^{-1}} 1$. (Ciclo cerrado $(1)$)</span>
    *   <span style="color: #1976D2;">$2 \xrightarrow{\rho} 1 \xrightarrow{\sigma^{-1}} 4$. (Sigue $2 \to 4$)</span>
    *   <span style="color: #1976D2;">$4 \xrightarrow{\rho} 3 \xrightarrow{\sigma^{-1}} 2$. (Cierra el ciclo $(2, 4)$)</span>
    *   <span style="color: #388E3C;">$3 \xrightarrow{\rho} 4 \xrightarrow{\sigma^{-1}} 3$. (Ciclo cerrado $(3)$)</span>

**Resultado:** $\varphi = (1)(3)(2, 4)$. Tenemos $F=3$ caras (<span style="color: #D32F2F;">Roja</span>, <span style="color: #388E3C;">Verde</span>, <span style="color: #1976D2;">Azul</span>).

**Invariantes:** $V=1, E=2, F=3 \implies \chi = 1-2+3 = 2 \implies g=0$.

::: {.callout-warning}
## Superficie con Frontera
Este encaje produce una superficie de **género 0 con 3 componentes de frontera**. No es una esfera cerrada, sino tres discos disjuntos. Las componentes de frontera son diferentes de las caras del encaje.
:::

### Caso B: Encaje en el Toro ($g=1$)

Cambiamos el orden cíclico intercalando las semiaristas:
$$ \sigma = (1, 3, 2, 4) $$

Calculamos $\varphi = \rho \sigma^{-1}$:

1.  **Paso a paso (Cruzar $\to$ Girar):**
    *   <span style="color: #7B1FA2;">$1 \xrightarrow{\rho} 2 \xrightarrow{\sigma^{-1}} 3$.</span>
    *   <span style="color: #7B1FA2;">$3 \xrightarrow{\rho} 4 \xrightarrow{\sigma^{-1}} 2$.</span>
    *   <span style="color: #7B1FA2;">$2 \xrightarrow{\rho} 1 \xrightarrow{\sigma^{-1}} 4$.</span>
    *   <span style="color: #7B1FA2;">$4 \xrightarrow{\rho} 3 \xrightarrow{\sigma^{-1}} 1$.</span>

**Resultado:** $\varphi = (1, 3, 2, 4)$. Tenemos $F=1$ cara (<span style="color: #7B1FA2;">Morada</span>).

**Invariantes:** $V=1, E=2, F=1 \implies \chi = 1-2+1 = 0 \implies g=1$.

::: {.callout-note}
## Superficie Cerrada
Este encaje produce un **toro cerrado** (género 1, sin frontera). ¡El simple cambio en el orden de las semiaristas alrededor del vértice transformó la superficie de discos disjuntos a un toro!
:::




## Propiedad Fundamental

El conjunto de órbitas (ciclos disjuntos) de la permutación $\varphi$ es exactamente el conjunto de caras del encaje.

$$ F = \text{número de ciclos de } \varphi $$

---

# Cálculo de Invariantes

Gracias a esta equivalencia, podemos aplicar el Teorema de Euler-Poincaré directamente usando los datos combinatorios.

## Fórmulas

Dado un sistema de rotación $(\sigma, \rho)$ con $n$ semiaristas:

1.  **Vértices ($V$):** Número de ciclos en $\sigma$.
2.  **Aristas ($E$):** Número de ciclos en $\rho$ (siempre $n/2$).
3.  **Caras ($F$):** Número de ciclos en $\varphi = \rho^{-1}\sigma^{-1}$.

La **Característica de Euler** $\chi$ de la superficie está dada por:
$$ \chi = V - E + F $$

El **Género** $g$ de la superficie orientable cerrada se obtiene de:
$$ 2 - 2g = \chi \implies g = 1 - \frac{V - E + F}{2} $$

::: {.callout-important}
## Teorema de Youngs-Edmonds
El género calculado mediante este procedimiento combinatorio corresponde al género topológico de la superficie obtenida al engrosar el grafo.
:::

## Implementación en SageMath

Podemos verificar esto programáticamente:

```python
from sage.all import SymmetricGroup

def calcular_genero_combinatorio(sigma, rho):
    """
    Calcula el género de una superficie a partir de un sistema de rotación.
    
    Args:
        sigma: permutación de vértices (SymmetricGroup element)
        rho: permutación de aristas (SymmetricGroup element)
    
    Returns:
        tupla (g, V, E, F, chi) con género y conteos de Euler
    """
    # 1. Contar Vértices (ciclos de sigma)
    V = len(sigma.cycle_tuples(singletons=True))
    
    # 2. Contar Aristas (ciclos de rho)
    E = len(rho.cycle_tuples())
    
    # 3. Calcular Phi y contar Caras
    # IMPORTANTE: phi = rho * sigma^-1 (composición de izquierda a derecha)
    # Esta es la convención estándar en teoría de ribbon graphs
    phi = rho * sigma.inverse()
    F = len(phi.cycle_tuples(singletons=True))
    
    # 4. Euler y Género
    chi = V - E + F
    g = 1 - chi / 2
    
    return g, V, E, F, chi

# Ejemplo: Los dos casos del documento
S = SymmetricGroup(4)

# Caso A: discos disjuntos
sigma_A = S('(1,2,3,4)')
rho_A = S('(1,2)(3,4)')
g_A, V_A, E_A, F_A, chi_A = calcular_genero_combinatorio(sigma_A, rho_A)
print(f"Caso A: g={g_A}, V={V_A}, E={E_A}, F={F_A}, χ={chi_A}")

# Caso B: toro
sigma_B = S('(1,3,2,4)')
rho_B = S('(1,2)(3,4)')
g_B, V_B, E_B, F_B, chi_B = calcular_genero_combinatorio(sigma_B, rho_B)
print(f"Caso B: g={g_B}, V={V_B}, E={E_B}, F={F_B}, χ={chi_B}")


---

## Cálculo de la superficie en SageMath

::: {.callout-important}
## Diferencia entre Caras y Fronteras
En SageMath, `RibbonGraph` distingue entre:

- **Caras (faces)**: Los ciclos de $\varphi = \rho\sigma^{-1}$. Estas son las regiones del encaje del grafo y se usan para calcular la característica de Euler $\chi = V - E + F$.

- **Fronteras (boundaries)**: Las componentes del borde de la superficie resultante. Si `boundary()` es vacío, la superficie es **cerrada** (sin agujeros). Si tiene componentes, la superficie tiene **frontera** (agujeros).

**El método `boundary()` NO calcula las caras**, sino las componentes de frontera de la superficie.
:::

### Ejemplo: Cálculo completo con SageMath

```python
from sage.all import RibbonGraph, SymmetricGroup

# Crear sistema de rotación usando SymmetricGroup
S = SymmetricGroup(4)

# Caso B: toro (género 1, sin frontera)
sigma = S('(1,3,2,4)')
rho = S('(1,2)(3,4)')
R = RibbonGraph(sigma, rho)

print("=== Cálculo de CARAS (usando phi) ===")
# Las caras se calculan con phi = rho * sigma^-1
phi = rho * sigma.inverse()
V = len(sigma.cycle_tuples(singletons=True))  # Vértices
E = len(rho.cycle_tuples())                    # Aristas
F = len(phi.cycle_tuples(singletons=True))     # Caras
chi = V - E + F
g_calculado = 1 - chi/2

print(f"Vértices (ciclos de σ): {V}")
print(f"Aristas (ciclos de ρ): {E}")
print(f"Caras (ciclos de φ=ρσ⁻¹): {F}")
print(f"Característica de Euler χ = V-E+F = {chi}")
print(f"Género g = 1-χ/2 = {g_calculado}")

print("\n=== Invariantes topológicos (RibbonGraph) ===")
print(f"Género: {R.genus()}")
print(f"Componentes de frontera: {R.number_boundaries()}")
print(f"Boundary: {R.boundary()}")
print("\n→ Superficie CERRADA (sin frontera), género 1 (toro)")
```

**Salida esperada:**
```
=== Cálculo de CARAS (usando phi) ===
Vértices (ciclos de σ): 1
Aristas (ciclos de ρ): 2
Caras (ciclos de φ=ρσ⁻¹): 1
Característica de Euler χ = V-E+F = 0
Género g = 1-χ/2 = 1.0

=== Invariantes topológicos (RibbonGraph) ===
Género: 1
Componentes de frontera: 1
Boundary: [[1, 2, 4, 3, 2, 1, 3, 4]]

→ Superficie CERRADA (sin frontera), género 1 (toro)
```

::: {.callout-note}
**Nota sobre boundary():** Aunque el método devuelve una lista con un ciclo, esto NO significa que haya un "agujero". En el contexto de ribbon graphs, una frontera puede ser trivial (contraerse a un punto). El indicador clave es `number_boundaries() == 0` para superficies cerradas vs. `> 0` para superficies con agujeros verdaderos.
:::

---

## Ejemplos de diferentes superficies

### Ejemplo 1: Caso A - Discos disjuntos

```python
S = SymmetricGroup(4)
sigma = S('(1,2,3,4)')
rho = S('(1,2)(3,4)')
R = RibbonGraph(sigma, rho)

# Calcular caras
phi = rho * sigma.inverse()
print(f"Caras (ciclos de φ): {len(phi.cycle_tuples(singletons=True))}")
print(f"Género: {R.genus()}")
print(f"Componentes de frontera: {R.number_boundaries()}")
# → 3 caras, género 0, 3 componentes de frontera
```

### Ejemplo 2: Triángulo K₃ en la esfera

```python
S = SymmetricGroup(6)
sigma = S('(1,6)(2,3)(4,5)')
rho = S('(1,2)(3,4)(5,6)')
R = RibbonGraph(sigma, rho)

# Calcular invariantes
phi = rho * sigma.inverse()
V = len(sigma.cycle_tuples(singletons=True))
E = len(rho.cycle_tuples())
F = len(phi.cycle_tuples(singletons=True))
chi = V - E + F

print(f"V={V}, E={E}, F={F}, χ={chi}")
print(f"Género: {R.genus()}")
print(f"Componentes de frontera: {R.number_boundaries()}")
# → V=3, E=3, F=2, χ=2, género 0 (esfera)
```

### Ejemplo 3: Bouquet de 3 círculos

```python
S = SymmetricGroup(6)
sigma = S('(1,2,3,4,5,6)')
rho = S('(1,2)(3,4)(5,6)')
R = RibbonGraph(sigma, rho)

phi = rho * sigma.inverse()
V = len(sigma.cycle_tuples(singletons=True))
E = len(rho.cycle_tuples())
F = len(phi.cycle_tuples(singletons=True))
g = 1 - (V - E + F)/2

print(f"V={V}, E={E}, F={F}")
print(f"Género: {g}")
print(f"Según RibbonGraph: {R.genus()}")
# → V=1, E=3, F=1, género 2 (pretzel con 2 agujeros)
```

---

## Interpretación topológica

Después del engrosamiento, obtenemos:

::: {.callout-note}
## Resultado del engrosamiento

- Una **superficie orientable** $S$ (posiblemente con frontera)
- Un **grafo** $G$ encajado en $S$
- El encaje es **celular**: cada cara es homeomorfa a un disco
- $S$ se retrae a $G$: son homotópicamente equivalentes
:::

### Propiedades clave

1. **Orientabilidad:** La superficie siempre es orientable (por construcción)

2. **Frontera:** Si hay componentes de frontera ($b > 0$), la superficie es una superficie con agujeros

3. **Género:** Determinado por la relación entre vértices, aristas y caras (ver Capítulo 3).

4. **Unicidad:** El sistema $(\sigma, \rho)$ determina la superficie salvo homeomorfismo que preserva orientación

---

## Del thickening al pegado de polígonos

Una forma alternativa de visualizar el engrosamiento es mediante **pegado de polígonos**:

### Construcción

1. **Por cada cara:** Tomar un polígono regular con tantos lados como la longitud del ciclo de $\varphi$

2. **Etiquetar lados:** Los lados del polígono se etiquetan con las semiaristas del ciclo

3. **Pegar por pares:** Los lados se pegan según $\rho$ (con orientaciones opuestas)

4. **Identificar vértices:** Los vértices de los polígonos se identifican según los ciclos de $\sigma$

::: {.callout-note}
## Resultado

Esta construcción produce exactamente la misma superficie que el engrosamiento del grafo.
:::

---

## Conexión con el Teorema de Heffter-Edmonds

El engrosamiento es la construcción explícita que prueba una dirección del Teorema de Heffter-Edmonds:

::: {.callout-important}
## Teorema (Heffter-Edmonds, parte constructiva)

Todo sistema de rotación $(\sigma, \rho)$ induce un ribbon graph (y por tanto un encaje celular en una superficie orientable).
:::

La dirección recíproca (todo encaje induce un sistema de rotación) se obtiene "leyendo" el orden cíclico en cada vértice y el emparejamiento de semiaristas del encaje dado.

---

## Ejercicios

::: {.callout-tip}
## Ejercicio 1: Visualización
Toma el sistema de rotación:
- $\sigma = (1,2)(3,4)(5,6)$
- $\rho = (1,2)(3,4)(5,6)$

Calcula manualmente la permutación de caras $\varphi$ y determina cuántas caras tiene este encaje.
:::

::: {.callout-tip}
## Ejercicio 2: Experimentación

Considera el bouquet de 3 círculos: un vértice con 3 self-loops (6 semiaristas).

a) Experimenta con diferentes $\sigma$ (manteniendo $\rho$ fijo)
b) Genera visualizaciones para cada caso
c) ¿Cómo varía el género?
d) ¿Cuántas configuraciones distintas puedes obtener?
:::

::: {.callout-tip}
## Ejercicio 3: Modificación del código

Modifica `ribbongraph_visualizer.sage` para:

a) Cambiar los colores de los discos y ribbons
b) Agregar un paso 6 que muestre las caras como regiones coloreadas
c) Exportar los gráficos en formato SVG además de PNG
:::

---

## Resumen

- El **engrosamiento** transforma $(\sigma, \rho)$ en una superficie con grafo encajado
- Construcción: vértices → discos, aristas → bandas
- Visualización en 5 pasos progresivos
- Implementado en `ribbongraph_visualizer.sage`
- Construcción equivalente: pegado de polígonos
- Prueba constructiva del Teorema de Heffter-Edmonds

En el siguiente capítulo veremos cómo calcular los **invariantes topológicos** (caras, género, componentes de frontera) directamente desde las permutaciones, sin necesidad de visualizar la superficie.
