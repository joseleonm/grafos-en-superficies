<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>5. Ejemplos – Sistemas de Rotación y Ribbon Graphs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../capitulos/04-teorema.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-8b4baf804e461d9b72633f0de59a0cac.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-f9c6f0e9917b4ec8832aaecb36f8ee78.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No se han encontrado resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<link rel="stylesheet" type="text/css" href="https://sagecell.sagemath.org/static/sagecell_embed.css">
<script>
// Inicializar cuando el documento esté listo
window.addEventListener('load', function() {
  sagecell.makeSagecell({
    inputLocation: 'div.sage-cell',
    evalButtonText: 'Ejecutar',
    languages: ['sage'],
    hide: []
  });
});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Sistemas de Rotación</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Buscar"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Navegación de palanca" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../index.html" aria-current="page"> <i class="bi bi-house-fill" role="img">
</i> 
<span class="menu-text">Inicio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/01-sistemas-rotacion.html"> 
<span class="menu-text">1. Sistemas de Rotación</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/02-mapas-combinatorios.html"> 
<span class="menu-text">2. Mapas Combinatorios</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/03-invariantes.html"> 
<span class="menu-text">3. Invariantes Topológicos</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/04-teorema.html"> 
<span class="menu-text">4. Equivalencia</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/05-ejemplos.html"> 
<span class="menu-text">5. Ejemplos</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/joseleonm/grafos-en-superficies"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../capitulos/05-ejemplos.html">5. Ejemplos</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Buscar" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link"><i class="bi bi-house-fill" role="img">
</i> 
 <span class="menu-text">Inicio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/01-sistemas-rotacion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Sistemas de Rotación</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/02-mapas-combinatorios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Mapas Combinatorios</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/03-invariantes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. Invariantes Topológicos</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/04-teorema.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4. Equivalencia</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/05-ejemplos.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">5. Ejemplos</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">5. Ejemplos</h1>
<p class="subtitle lead">Verificación computacional de equivalencia de sistemas de rotación</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>En el capítulo anterior vimos cómo sistemas de rotación aparentemente diferentes pueden representar el mismo encaje topológico. Aquí exploraremos casos más complicados donde la equivalencia no es inmediatamente obvia.</p>
<section id="un-ejemplo-ilustrativo-moño-vs-ojo" class="level2">
<h2 class="anchored" data-anchor-id="un-ejemplo-ilustrativo-moño-vs-ojo">Un ejemplo ilustrativo: ¿Moño vs ojo?</h2>
<p>A primera vista, los siguientes dos encajes parecen topológicamente diferentes:</p>
<style>
.encaje-grid {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 16px;
  align-items: start;
}
.encaje-item {
  text-align: center;
}
.encaje-item img {
  width: 100%;
  height: clamp(220px, 28vw, 320px);
  object-fit: contain;
}
.encaje-item p {
  margin: 0.5rem 0 0;
}
@media (max-width: 680px) {
  .encaje-grid {
    grid-template-columns: 1fr;
  }
}
</style>
<div class="encaje-grid">
  <div class="encaje-item">
    <img src="../imagenes/triangulos.png" alt="sigma1">
    <p>\( \sigma_1=(1,2,3,4)(5,10)(6,9)(8,12)(7,11) \), \( \rho=(1,5)(4,8)(2,6)(3,7)(9,10)(11,12) \)</p>
  </div>
  <div class="encaje-item">
    <img src="../imagenes/ojo.png" alt="sigma2">
    <p>\( \sigma_2=(1,4,3,2)(5,10)(6,9)(8,12)(7,11) \), \( \rho=(1,5)(4,8)(2,6)(3,7)(9,10)(11,12) \)</p>
  </div>
</div>
<p><br></p>
<section id="intuición-geométrica-inicial" class="level3">
<h3 class="anchored" data-anchor-id="intuición-geométrica-inicial">Intuición geométrica inicial</h3>
<p>En una representación <strong>plana</strong> con cara exterior distinguida, la diferencia parece evidente:</p>
<ul>
<li><p><strong>Figura izquierda (el moño):</strong> La cara exterior colinda con vértices de ambos triángulos. Es posible trazar un camino desde cualquier vértice hacia el infinito sin cruzar ninguna arista.</p></li>
<li><p><strong>Figura derecha (el ojo):</strong> La cara exterior solo colinda con el triángulo mayor. Los vértices del triángulo menor quedan topológicamente “aislados” en una cara interior, y parece imposible conectarlos con el exterior sin cruzar el ciclo del triángulo mayor.</p></li>
</ul>
<p>Esta intuición sugeriría que <strong>no</strong> son equivalentes. Sin embargo…</p>
</section>
<section id="la-verificación-computacional-dice-lo-contrario" class="level3">
<h3 class="anchored" data-anchor-id="la-verificación-computacional-dice-lo-contrario">¡La verificación computacional dice lo contrario!</h3>
<p>Aunque comparten el mismo emparejamiento <span class="math inline">\(\rho\)</span>, y el orden cíclico en el vértice principal está invertido en <span class="math inline">\(\sigma_2\)</span> (comparado con <span class="math inline">\(\sigma_1\)</span>), resulta que <strong>sí existe</strong> una biyección de dardos que conjuga uno en el otro.</p>
<p><strong>Prueba el código directamente aquí</strong> (haz clic en “Ejecutar”):</p>
<div class="sage-cell">
<script type="text/x-sage">
# Definir los sistemas de rotación
sigma1 = PermutationGroupElement('(1,2,3,4)(5,10)(6,9)(8,12)(7,11)')
sigma2 = PermutationGroupElement('(1,4,3,2)(5,10)(6,9)(8,12)(7,11)')
rho = PermutationGroupElement('(1,5)(4,8)(2,6)(3,7)(9,10)(11,12)')

# Crear ribbon graphs
R1 = RibbonGraph(sigma1, rho)
R2 = RibbonGraph(sigma2, rho)

# Verificar invariantes
phi1 = rho * sigma1
phi2 = rho * sigma2

V1 = len(sigma1.cycle_tuples(singletons=True))
E1 = len(rho.cycle_tuples(singletons=True))
F1 = len(phi1.cycle_tuples(singletons=True))

V2 = len(sigma2.cycle_tuples(singletons=True))
E2 = len(rho.cycle_tuples(singletons=True))
F2 = len(phi2.cycle_tuples(singletons=True))

print("Sistema 1:")
print(f"  V={V1}, E={E1}, F={F1}, χ={V1-E1+F1}, g={R1.genus()}")

print("\nSistema 2:")
print(f"  V={V2}, E={E2}, F={F2}, χ={V2-E2+F2}, g={R2.genus()}")

# Probar el isomorfismo propuesto por el algoritmo
phi = PermutationGroupElement('(1,4)(2,3)(5,8)(6,7)(9,11)(10,12)')

# Verificar conjugación
conjugado_sigma = phi * sigma1 * phi^(-1)
conjugado_rho = phi * rho * phi^(-1)

print("\nVerificación del isomorfismo φ = (1,4)(2,3)(5,8)(6,7)(9,11)(10,12):")
print(f"  φ·σ₁·φ⁻¹ = {conjugado_sigma}")
print(f"  σ₂       = {sigma2}")
print(f"  ¿Iguales? {conjugado_sigma == sigma2}")

print(f"\n  φ·ρ·φ⁻¹  = {conjugado_rho}")
print(f"  ρ        = {rho}")
print(f"  ¿Iguales? {conjugado_rho == rho}")

if conjugado_sigma == sigma2 and conjugado_rho == rho:
    print("\n✓ Los sistemas SON EQUIVALENTES")
    print("  Existe φ que conjuga (σ₁, ρ) en (σ₂, ρ)")
else:
    print("\n✗ Los sistemas NO son equivalentes")
</script>
</div>
</section>
<section id="qué-salió-mal-con-la-intuición" class="level3">
<h3 class="anchored" data-anchor-id="qué-salió-mal-con-la-intuición">¿Qué salió mal con la intuición?</h3>
<p>La clave está en recordar que <strong>los encajes en superficies cerradas no tienen una “cara exterior” privilegiada</strong>. Cuando vemos una representación plana, estamos eligiendo arbitrariamente una cara para “abrir” y dibujar el resto.</p>
<p>Lo que parece una “obstrucción topológica” en el plano es simplemente un artefacto de nuestra elección de representación. Un homeomorfismo que preserve la orientación puede cambiar completamente cuál cara se convierte en “la exterior” al dibujar.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Advertencia</span>Lección aprendida
</div>
</div>
<div class="callout-body-container callout-body">
<p>La intuición geométrica en representaciones planas puede ser engañosa. Los invariantes algebraicos (<span class="math inline">\(V, E, F, \chi, g\)</span>) y la verificación computacional son herramientas más confiables para determinar equivalencia topológica.</p>
</div>
</div>
</section>
<section id="cómo-funciona-el-isomorfismo" class="level3">
<h3 class="anchored" data-anchor-id="cómo-funciona-el-isomorfismo">¿Cómo funciona el isomorfismo?</h3>
<p>La permutación <span class="math inline">\(\phi = (1,4)(2,3)(5,8)(6,7)(9,11)(10,12)\)</span> reetiqueta los dardos de forma que:</p>
<ol type="1">
<li>Invierte el ciclo principal: <span class="math inline">\((1,2,3,4) \mapsto (1,4,3,2)\)</span></li>
<li>Respeta completamente el emparejamiento <span class="math inline">\(\rho\)</span> de aristas</li>
<li>Preserva toda la estructura combinatoria del ribbon graph</li>
</ol>
<p>En este ejemplo, <span class="math inline">\(\phi\)</span> tiene además una lectura geométrica concreta: corresponde a reflejar el moño respecto de un eje vertical que pasa por el vértice central, recuperando el otro dibujo.</p>
<p>Esto demuestra que, aunque los dibujos <strong>se vean</strong> diferentes en el plano, representan el <strong>mismo</strong> encaje topológico cuando se consideran como superficies cerradas.</p>
<hr>
</section>
</section>
<section id="buscando-ejemplos-genuinamente-no-equivalentes" class="level2">
<h2 class="anchored" data-anchor-id="buscando-ejemplos-genuinamente-no-equivalentes">Buscando ejemplos genuinamente no equivalentes</h2>
<p>Para construir sistemas de rotación que <strong>realmente</strong> sean no equivalentes pero tengan el mismo género, necesitaríamos:</p>
<ul>
<li>Diferentes números de vértices, aristas, o caras</li>
<li>Diferente estructura en los ciclos de <span class="math inline">\(\sigma\)</span> o <span class="math inline">\(\rho\)</span> que no pueda conjugarse</li>
</ul>
<section id="un-ejemplo-concreto" class="level3">
<h3 class="anchored" data-anchor-id="un-ejemplo-concreto">Un ejemplo concreto</h3>
<p>La siguiente imagen muestra dos encajes del mismo grafo abstracto: a la izquierda el ribbon graph <span class="math inline">\((\sigma_1, \rho_1)\)</span> y a la derecha <span class="math inline">\((\sigma_2, \rho_2)\)</span>, donde <span class="math inline">\(\sigma_2 = \sigma_1\)</span> pero <span class="math inline">\(\rho_2\)</span> difiere ligeramente de <span class="math inline">\(\rho_1\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../imagenes/ejemplodiferentes.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p><span class="math display">\[
\sigma_1 = \sigma_2 = (1,2)(3,4,5)(6,7,8)(9,10)(11,12,13)(14,15,16)
\]</span></p>
<p><span class="math display">\[
\rho_1 = (1,8)(2,3)(4,12)(5,6)(7,15)(9,16)(10,11)(13,14)
\]</span></p>
<p><span class="math display">\[
\rho_2 = (1,8)(2,3)(4,13)(5,6)(7,15)(9,14)(10,11)(12,16)
\]</span></p>
<p>Ambos comparten los mismos invariantes globales (<span class="math inline">\(V\)</span>, <span class="math inline">\(E\)</span>, <span class="math inline">\(F\)</span>, <span class="math inline">\(\chi\)</span>, <span class="math inline">\(g\)</span>) y sin embargo <strong>no son equivalentes</strong>. El diagnóstico más rápido es comparar las <strong>longitudes de los ciclos de <span class="math inline">\(\phi = \rho\sigma\)</span></strong> (las caras). Si los multiconjuntos de longitudes difieren, no puede existir isomorfismo:</p>
<div class="sage-cell">
<script type="text/x-sage">
sigma1 = PermutationGroupElement('(1,2)(3,4,5)(6,7,8)(9,10)(11,12,13)(14,15,16)')
rho1   = PermutationGroupElement('(1,8)(2,3)(4,12)(5,6)(7,15)(9,16)(10,11)(13,14)')
sigma2 = PermutationGroupElement('(1,2)(3,4,5)(6,7,8)(9,10)(11,12,13)(14,15,16)')
rho2   = PermutationGroupElement('(1,8)(2,3)(4,13)(5,6)(7,15)(9,14)(10,11)(12,16)')

phi1 = rho1 * sigma1
phi2 = rho2 * sigma2

long1 = sorted(len(c) for c in phi1.cycle_tuples(singletons=True))
long2 = sorted(len(c) for c in phi2.cycle_tuples(singletons=True))

R1 = RibbonGraph(sigma1, rho1)
R2 = RibbonGraph(sigma2, rho2)

V1 = len(sigma1.cycle_tuples(singletons=True))
E1 = len(rho1.cycle_tuples(singletons=True))
F1 = len(phi1.cycle_tuples(singletons=True))

V2 = len(sigma2.cycle_tuples(singletons=True))
E2 = len(rho2.cycle_tuples(singletons=True))
F2 = len(phi2.cycle_tuples(singletons=True))

print("Sistema 1: V={}, E={}, F={}, χ={}, g={}".format(V1, E1, F1, V1-E1+F1, R1.genus()))
print("  φ₁ =", phi1)
print("  Longitudes de caras:", long1)

print()
print("Sistema 2: V={}, E={}, F={}, χ={}, g={}".format(V2, E2, F2, V2-E2+F2, R2.genus()))
print("  φ₂ =", phi2)
print("  Longitudes de caras:", long2)

print()
if long1 == long2:
    print("✓ Multiconjuntos iguales → puede haber isomorfismo (no descartado)")
else:
    print("✗ Multiconjuntos distintos → NO puede existir isomorfismo")
    print("  Un isomorfismo conjugaría φ₁ en φ₂, preservando longitudes de ciclos.")
    print("  Como {} ≠ {}, los sistemas son genuinamente no equivalentes.".format(long1, long2))
</script>
</div>
<p>El resultado muestra que las longitudes de caras son <span class="math inline">\(\{3,3,5,5\}\)</span> para el primer sistema y <span class="math inline">\(\{3,3,4,6\}\)</span> para el segundo. Como cualquier isomorfismo preserva las longitudes de ciclos de <span class="math inline">\(\phi\)</span>, la diferencia en los multiconjuntos es <strong>condición suficiente</strong> para concluir la no-equivalencia sin necesidad de correr la búsqueda con retroceso completa.</p>
<hr>
</section>
</section>
<section id="unicidad-en-grafos-3-conexos" class="level2">
<h2 class="anchored" data-anchor-id="unicidad-en-grafos-3-conexos">Unicidad en grafos 3-conexos</h2>
<p>Nótese que en el ejemplo anterior tenemos un grafo 2-conexo: hay pares de vértices cuya remoción desconecta el grafo, pero ningún vértice individual lo hace. Cuando aumentamos la conectividad hasta 3, sí se pueden garantizar encajes únicos. Esto se conecta con el <strong>Teorema de Whitney</strong>:</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Importante</span>Teorema de Whitney (1932)
</div>
</div>
<div class="callout-body-container callout-body">
<p>Todo grafo planar 3‑conexo tiene un encaje único en la esfera (único salvo equivalencia topológica, es decir, reflexiones y homeomorfismos).</p>
</div>
</div>
<p>Este resultado tiene un antecedente importante: en 1922, <strong>Steinitz</strong> demostró que todo grafo planar 3-conexo es el grafo de aristas de algún poliedro convexo, y que dicho poliedro es único salvo proyección. El teorema de Whitney puede verse como la versión combinatoria de ese resultado: la 3-conexidad fija la estructura combinatoria del encaje, del mismo modo en que Steinitz fijó la estructura poliedral.</p>
<p>Aquí “3‑conexo” <strong>no</strong> es “valencia 3”; se refiere a cuántos vértices hay que quitar para desconectar el grafo:</p>
<ul>
<li><strong>1‑conexo:</strong> al quitar 1 vértice el grafo se desconecta (p.&nbsp;ej. una estrella).</li>
<li><strong>2‑conexo:</strong> se requieren al menos 2 vértices para desconectarlo (p.&nbsp;ej. un ciclo).</li>
<li><strong>3‑conexo:</strong> se requieren al menos 3 vértices para desconectarlo.</li>
</ul>
<p>Ejemplos visuales de grafos 3‑conexos:</p>
<ul>
<li>El esqueleto de un cubo.</li>
<li>El esqueleto de un tetraedro (<span class="math inline">\(K_4\)</span>).</li>
<li>El esqueleto de un dodecaedro.</li>
</ul>
<p>En estos casos, el Teorema de Whitney garantiza que el encaje planar es esencialmente único.</p>
<hr>
</section>
<section id="verificar-equivalencia-del-problema-al-algoritmo" class="level2">
<h2 class="anchored" data-anchor-id="verificar-equivalencia-del-problema-al-algoritmo">Verificar equivalencia: del problema al algoritmo</h2>
<section id="la-escala-del-problema" class="level3">
<h3 class="anchored" data-anchor-id="la-escala-del-problema">La escala del problema</h3>
<p>Para verificar si dos sistemas de rotación sobre <span class="math inline">\(n\)</span> dardos son equivalentes, necesitamos encontrar una biyección <span class="math inline">\(\phi:\{1,\ldots,n\}\to\{1,\ldots,n\}\)</span> que satisfaga</p>
<p><span class="math display">\[
\phi \cdot \sigma_1 \cdot \phi^{-1} = \sigma_2
\qquad\text{y}\qquad
\phi \cdot \rho_1 \cdot \phi^{-1} = \rho_2.
\]</span></p>
<p>El conjunto de todas las biyecciones posibles es el grupo simétrico <span class="math inline">\(S_n\)</span>, de tamaño <span class="math inline">\(n!\)</span>. Para el ejemplo de los dos encajes no equivalentes que vimos arriba, con <span class="math inline">\(n = 16\)</span> dardos:</p>
<p><span class="math display">\[
16! \;\approx\; 2.09 \times 10^{13}.
\]</span></p>
<p>Verificando un millón de permutaciones por segundo, recorrer todas llevaría unos <strong>242 días</strong>. Y eso suponiendo que los multiconjuntos de caras hubieran coincidido y no pudiéramos descartar la equivalencia de inmediato. Para los diagramas de Heegaard que veremos a continuación, con <span class="math inline">\(n=48\)</span>:</p>
<p><span class="math display">\[
48! \;\approx\; 1.24 \times 10^{61},
\]</span></p>
<p>completamente fuera del alcance de cualquier computadora concebible.</p>
</section>
<section id="el-grafo-abstracto-restringe-la-búsqueda" class="level3">
<h3 class="anchored" data-anchor-id="el-grafo-abstracto-restringe-la-búsqueda">El grafo abstracto restringe la búsqueda</h3>
<p>La observación clave es que cualquier isomorfismo debe <strong>preservar la estructura del grafo abstracto</strong>. Como <span class="math inline">\(\sigma\)</span> codifica el orden cíclico de los dardos alrededor de cada vértice, una biyección <span class="math inline">\(\phi\)</span> solo puede ser isomorfismo si mapea ciclos de <span class="math inline">\(\sigma_1\)</span> a ciclos de <span class="math inline">\(\sigma_2\)</span> <strong>de la misma longitud</strong>. En otras palabras, <span class="math inline">\(\phi\)</span> actúa como una permutación entre los ciclos de <span class="math inline">\(\sigma\)</span>, junto con una rotación dentro de cada ciclo.</p>
<p>Esto restringe drásticamente el espacio de búsqueda. Para el ejemplo con <span class="math inline">\(n=16\)</span> y tipo de ciclo <span class="math inline">\(2^2 \cdot 3^4\)</span> (dos 2-ciclos y cuatro 3-ciclos):</p>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Elección</th>
<th>Opciones</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>¿Cuál 2-ciclo se manda a cuál?</td>
<td><span class="math inline">\(2! = 2\)</span></td>
</tr>
<tr class="even">
<td>Rotación dentro de cada 2-ciclo</td>
<td><span class="math inline">\(2^2 = 4\)</span></td>
</tr>
<tr class="odd">
<td>¿Cuál 3-ciclo se manda a cuál?</td>
<td><span class="math inline">\(4! = 24\)</span></td>
</tr>
<tr class="even">
<td>Rotación dentro de cada 3-ciclo</td>
<td><span class="math inline">\(3^4 = 81\)</span></td>
</tr>
<tr class="odd">
<td><strong>Total de candidatos</strong></td>
<td><span class="math inline">\(2 \times 4 \times 24 \times 81 = 15{,}552\)</span></td>
</tr>
</tbody>
</table>
<p>Son más de <strong><span class="math inline">\(10^9\)</span> veces menos</strong> candidatos que por fuerza bruta. Cada uno debe aún verificarse contra la condición de <span class="math inline">\(\rho\)</span>, pero la reducción es enorme.</p>
</section>
<section id="búsqueda-con-retroceso-y-propagación" class="level3">
<h3 class="anchored" data-anchor-id="búsqueda-con-retroceso-y-propagación">Búsqueda con retroceso y propagación</h3>
<p>Podemos reducir aún más el espacio explotando que las condiciones de isomorfismo <strong>propagan restricciones en cadena</strong>. Al fijar la imagen de un solo dardo, <span class="math inline">\(\phi(d_1) = d_2\)</span>, las condiciones de isomorfismo imponen de inmediato nuevas asignaciones:</p>
<p><strong>Propagación por <span class="math inline">\(\sigma\)</span>:</strong> La condición <span class="math inline">\(\sigma_1(\phi(d)) = \phi(\sigma_2(d))\)</span> determina las imágenes de todos los dardos en el ciclo de <span class="math inline">\(\sigma_2\)</span> que contiene a <span class="math inline">\(d_1\)</span>:</p>
<p><span class="math display">\[
\phi(\sigma_2(d_1)) = \sigma_1(d_2), \quad
\phi(\sigma_2^2(d_1)) = \sigma_1^2(d_2), \quad \ldots
\]</span></p>
<p><strong>Propagación por <span class="math inline">\(\rho\)</span>:</strong> La condición <span class="math inline">\(\phi(\rho_1(d)) = \rho_2(\phi(d))\)</span> determina el dardo emparejado:</p>
<p><span class="math display">\[
\phi(\rho_1(d_1)) = \rho_2(d_2).
\]</span></p>
<p>Cada nueva asignación puede desencadenar más propagaciones. Si en algún momento una propagación contradice una asignación anterior, esa rama se <strong>descarta de inmediato</strong> sin seguir explorando. Si se termina de asignar todos los dardos sin contradicción, se ha encontrado un isomorfismo. Si se agotan todas las opciones, queda probado que no existe ninguno.</p>
<p>El procedimiento es una <strong>búsqueda con retroceso</strong>: se construye <span class="math inline">\(\phi\)</span> eligiendo libremente la imagen del siguiente dardo sin asignar, se propagan las consecuencias, y si hay contradicción se retrocede al último punto de elección libre para probar la siguiente opción.</p>
<!-- ::: {.callout-note}
## Por qué es eficiente en la práctica

Para $n=48$ con $\sigma$ formada por ciclos de longitud 4, fijar $\phi(1) = d_2$ determina de inmediato 4 dardos más (el ciclo de $\sigma_2$) y 4 dardos adicionales (sus pares en $\rho_1$). Esos nuevos dardos pertenecen a otros ciclos de $\sigma$, que propagan más asignaciones, y así sucesivamente. En la práctica, una sola elección libre suele determinar más de la mitad del mapeo completo, y la mayoría de las ramas se podan antes de completar el 10% de las asignaciones. El resultado es que un problema con $48! \approx 10^{61}$ candidatos teóricos se resuelve en milisegundos.
::: -->
<hr>
</section>
</section>
<section id="diagramas-de-heegaard-como-encajes-celulares" class="level2">
<h2 class="anchored" data-anchor-id="diagramas-de-heegaard-como-encajes-celulares">Diagramas de Heegaard como encajes celulares</h2>
<p>Los <strong>diagramas de Heegaard</strong> de variedades de 3 dimensiones con mínimo número de vértices pueden representarse como encajes celulares, y la pregunta de si dos diagramas describen la misma variedad puede reducirse a verificar la equivalencia de sus sistemas de rotación.</p>
<p><strong>Esfera de Poincaré</strong> - Diagrama de Heegaard como encaje celular:</p>
<p><img src="../imagenes/esferaPoincarerotacion.png" class="img-fluid" style="width:100.0%" data-fig-cap="Figura tomada de https://arxiv.org/abs/2510.06651."></p>
<p><span class="math display">\[
\begin{aligned}
\sigma &amp;= (1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16) \\
       &amp;\phantom{=} (17,18,19,20)(21,22,23,24)(25,26,27,28)(29,30,31,32) \\
       &amp;\phantom{=} (33,34,35,36)(37,38,39,40)(41,42,43,44)(45,46,47,48)
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\rho &amp;= (1,7)(2,36)(3,25)(4,48)(5,11)(6,40)(8,30)(9,15) \\
     &amp;\phantom{=} (10,42)(12,34)(13,19)(14,38)(16,18)(17,23) \\
     &amp;\phantom{=} (20,22)(21,27)(24,26)(28,32)(29,35)(31,45) \\
     &amp;\phantom{=} (33,39)(37,43)(41,47)(44,46)
\end{aligned}
\]</span></p>
<p>Este sistema de rotación representa el diagrama de Heegaard de la esfera de Poincaré pensado como un encaje celular.</p>
<p><strong>Prueba el código directamente aquí</strong> (haz clic en “Ejecutar”):</p>
<div class="sage-cell">
<script type="text/x-sage">
# Sistema de rotación del diagrama de Heegaard de la esfera de Poincaré
sigma = PermutationGroupElement('(1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16)(17,18,19,20)(21,22,23,24)(25,26,27,28)(29,30,31,32)(33,34,35,36)(37,38,39,40)(41,42,43,44)(45,46,47,48)')
rho = PermutationGroupElement('(1,7)(2,36)(3,25)(4,48)(5,11)(6,40)(8,30)(9,15)(10,42)(12,34)(13,19)(14,38)(16,18)(17,23)(20,22)(21,27)(24,26)(28,32)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)')

# Crear ribbon graph
R = RibbonGraph(sigma, rho)
phi = rho * sigma

# Calcular invariantes
V = len(sigma.cycle_tuples(singletons=True))
E = len(rho.cycle_tuples(singletons=True))
F = len(phi.cycle_tuples(singletons=True))

print(f"Vértices (V): {V}")
print(f"Aristas  (E): {E}")
print(f"Caras    (F): {F}")
print(f"χ = V - E + F: {V - E + F}")
print(f"Género (g): {R.genus()}")

print(f"\nCiclos de φ (caras):")
for i, ciclo in enumerate(phi.cycle_tuples(singletons=True), 1):
    print(f"  Cara {i}: longitud {len(ciclo)}")
</script>
</div>
<p>Diagrama Alterno de Heegaard como encaje celular:</p>
<p><img src="../imagenes/EsferaPoincare2.png" class="img-fluid" style="width:100.0%" data-fig-cap="Figura adaptada de https://www.sciencedirect.com/science/article/pii/S0550321317303516. Licencia CC BY 4.0 (https://creativecommons.org/licenses/by/4.0/). Cambios: se agrego la numeracion de los dardos para calcular el sistema de rotacion."></p>
<p><span class="math display">\[
\begin{aligned}
\sigma &amp;= (1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16) \\
       &amp;\phantom{=} (17,18,19,20)(21,22,23,24)(25,26,27,28)(29,30,31,32) \\
       &amp;\phantom{=} (33,34,35,36)(37,38,39,40)(41,42,43,44)(45,46,47,48)
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\rho &amp;= (1,7)(2,38)(3,25)(4,6)(5,11)(8,10)(9,15)(12,14) \\
     &amp;\phantom{=} (13,19)(16,32)(17,23)(18,36)(20,48)(21,27)(22,40) \\
     &amp;\phantom{=} (24,30)(26,42)(28,34)(29,35)(31,45) \\
     &amp;\phantom{=} (33,39)(37,43)(41,47)(44,46)
\end{aligned}
\]</span></p>
<p>Este sistema de rotación representa el diagrama de Heegaard de la esfera de Poincaré pensado como un encaje celular.</p>
<hr>
</section>
<section id="son-equivalentes-los-dos-diagramas-de-heegaard" class="level2">
<h2 class="anchored" data-anchor-id="son-equivalentes-los-dos-diagramas-de-heegaard">¿Son equivalentes los dos diagramas de Heegaard?</h2>
<p>Tanto el diagrama original como el alterno tienen la misma <span class="math inline">\(\sigma\)</span>. La pregunta es si existe un isomorfismo de ribbon graphs entre ellos. El siguiente código verifica primero que ambos <span class="math inline">\(\rho\)</span> sean válidos, calcula sus invariantes y luego aplica la búsqueda con retroceso para encontrar un isomorfismo <span class="math inline">\(\phi\)</span>.</p>
<p><strong>Prueba el código directamente aquí</strong> (haz clic en “Ejecutar”):</p>
<div class="sage-cell">
<script type="text/x-sage">
import re, time

# ============================================================
# DEFINICIÓN DE LOS DOS SISTEMAS
# ============================================================
sigma_str = '(1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16)(17,18,19,20)(21,22,23,24)(25,26,27,28)(29,30,31,32)(33,34,35,36)(37,38,39,40)(41,42,43,44)(45,46,47,48)'

rho1_str = '(1,7)(2,36)(3,25)(4,48)(5,11)(6,40)(8,30)(9,15)(10,42)(12,34)(13,19)(14,38)(16,18)(17,23)(20,22)(21,27)(24,26)(28,32)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)'

rho2_str = '(1,7)(2,38)(3,25)(4,6)(5,11)(8,10)(9,15)(12,14)(13,19)(16,32)(17,23)(18,36)(20,48)(21,27)(22,40)(24,30)(26,42)(28,34)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)'

# ============================================================
# VERIFICAR VALIDEZ DE CADA ρ
# ============================================================
def verificar_rho(rho_str, nombre, n=48):
    nums = [int(x) for x in re.findall(r'\d+', rho_str)]
    repetidos = [x for x in set(nums) if nums.count(x) > 1]
    faltantes = sorted(set(range(1, n+1)) - set(nums))
    print(f"{nombre}: {len(nums)//2} aristas")
    if repetidos:
        print(f"  ✗ Números repetidos: {repetidos}")
    else:
        print(f"  ✓ Sin repetidos")
    if faltantes:
        print(f"  ✗ Números faltantes: {faltantes}")
    else:
        print(f"  ✓ Cubre todo {{1,...,{n}}}")
    return not repetidos and not faltantes

print("=" * 55)
print("VERIFICACIÓN DE VALIDEZ")
print("=" * 55)
ok1 = verificar_rho(rho1_str, "ρ₁ (original)")
ok2 = verificar_rho(rho2_str, "ρ₂ (alterno)")

if not (ok1 and ok2):
    print("\n⚠ Uno o ambos sistemas tienen errores. Corrígelos antes de continuar.")
else:
    # ============================================================
    # ALGORITMO DE BACKTRACKING CON PROPAGACIÓN
    # (Condición Sage izq→der: sigma1(phi(d)) = phi(sigma2(d)))
    # ============================================================
    sigma = PermutationGroupElement(sigma_str)
    rho1  = PermutationGroupElement(rho1_str)
    rho2  = PermutationGroupElement(rho2_str)

    n = 48
    cs1_raw = list(sigma.cycle_tuples(singletons=True))
    cs2_raw = list(sigma.cycle_tuples(singletons=True))  # misma sigma
    cr1 = list(rho1.cycle_tuples(singletons=True))
    cr2 = list(rho2.cycle_tuples(singletons=True))

    # Expandir singletons hasta n
    e1 = set(d for c in cs1_raw for d in c)
    cs1 = cs1_raw + [(d,) for d in range(1, n+1) if d not in e1]
    e2 = set(d for c in cs2_raw for d in c)
    cs2 = cs2_raw + [(d,) for d in range(1, n+1) if d not in e2]

    mapeo = {}

    def propagar_sigma(d1, d2):
        cd1 = next((c for c in cs2 if d1 in c), None)
        cd2 = next((c for c in cs1 if d2 in c), None)
        if cd1 is None or cd2 is None or len(cd1) != len(cd2):
            return None
        i1, i2, L = cd1.index(d1), cd2.index(d2), len(cd1)
        nuevos = []
        for i in range(L):
            src, tgt = cd1[(i1+i)%L], cd2[(i2+i)%L]
            if src in mapeo:
                if mapeo[src] != tgt: return None
            else:
                nuevos.append((src, tgt))
        return nuevos

    def propagar_rho(d1, d2):
        r1d1, r2d2 = rho1(d1), rho2(d2)
        if r1d1 in mapeo:
            return None if mapeo[r1d1] != r2d2 else []
        return [(r1d1, r2d2)]

    def extender(pares):
        cola = list(pares)
        while cola:
            d1, d2 = cola.pop(0)
            if d1 in mapeo:
                if mapeo[d1] != d2: return False
                continue
            mapeo[d1] = d2
            ns = propagar_sigma(d1, d2)
            if ns is None: return False
            cola.extend(ns)
            nr = propagar_rho(d1, d2)
            if nr is None: return False
            cola.extend(nr)
        return True

    def backtrack():
        d1 = next((d for d in range(1, n+1) if d not in mapeo), None)
        if d1 is None:
            from sage.groups.perm_gps.permgroup_named import SymmetricGroup
            Sn = SymmetricGroup(n)
            pl = [0]*(n+1)
            for a,b in mapeo.items(): pl[a] = b
            try:
                phi = Sn([pl[i] for i in range(1, n+1)])
                c1 = phi * sigma * phi^(-1) == sigma
                c2 = phi * rho1 * phi^(-1) == rho2
                if c1 and c2: return phi
            except: pass
            return None
        cd1 = next((c for c in cs2 if d1 in c), None)
        tam = len(cd1)
        for d2 in range(1, n+1):
            if d2 in mapeo.values(): continue
            cd2 = next((c for c in cs1 if d2 in c), None)
            if cd2 is None or len(cd2) != tam: continue
            prev = dict(mapeo)
            if extender([(d1, d2)]):
                res = backtrack()
                if res is not None: return res
            mapeo.clear(); mapeo.update(prev)
        return None

    # ============================================================
    # CALCULAR INVARIANTES DE AMBOS SISTEMAS
    # ============================================================
    R1 = RibbonGraph(sigma, rho1)
    R2 = RibbonGraph(sigma, rho2)
    phi1 = rho1 * sigma
    phi2 = rho2 * sigma

    def inv(sg, rh, phi_rho_sigma):
        V = len(sg.cycle_tuples(singletons=True))
        E = len(rh.cycle_tuples(singletons=True))
        F = len(phi_rho_sigma.cycle_tuples(singletons=True))
        return V, E, F

    V1,E1,F1 = inv(sigma, rho1, phi1)
    V2,E2,F2 = inv(sigma, rho2, phi2)

    print("\n" + "=" * 55)
    print("INVARIANTES")
    print("=" * 55)
    print(f"Sistema 1: V={V1}, E={E1}, F={F1}, χ={V1-E1+F1}, g={R1.genus()}")
    print(f"Sistema 2: V={V2}, E={E2}, F={F2}, χ={V2-E2+F2}, g={R2.genus()}")

    inv_coinciden = (V1==V2 and E1==E2 and F1==F2 and R1.genus()==R2.genus())
    if not inv_coinciden:
        print("\n✗ Los invariantes difieren → los sistemas NO son equivalentes")
    else:
        print("✓ Invariantes coinciden → puede haber isomorfismo")
        print("\n" + "=" * 55)
        print("BUSCANDO ISOMORFISMO (búsqueda con retroceso)...")
        print("=" * 55)
        t0 = time.time()
        phi = backtrack()
        elapsed = time.time() - t0
        print(f"Tiempo: {elapsed:.3f} s")
        if phi is not None:
            print(f"\n✓ EQUIVALENTES  φ = {phi}")
        else:
            print("\n✗ NO equivalentes (no existe φ)")
</script>
</div>
<section id="la-solución-encontrada" class="level3">
<h3 class="anchored" data-anchor-id="la-solución-encontrada">La solución encontrada</h3>
<p>El algoritmo (que es determinista: siempre recorre el mismo árbol de búsqueda) encuentra el isomorfismo entre los dos diagramas de Heegaard en <strong>menos de 0.1 segundos</strong>.</p>
<p><span class="math display">\[
\begin{aligned}
\phi &amp;= (1,27)(2,28)(3,25)(4,26)(5,23)(6,24)(7,21)(8,22) \\
     &amp;\phantom{=}(9,19)(10,20)(11,17)(12,18)(13,15)(14,16) \\
     &amp;\phantom{=}(29,39)(30,40)(31,37)(32,38)(33,35)(34,36) \\
     &amp;\phantom{=}(41,47)(42,48)(43,45)(44,46)
\end{aligned}
\]</span></p>
<p>Esta permutación conjuga simultáneamente <span class="math inline">\(\sigma\)</span> en <span class="math inline">\(\sigma\)</span> y <span class="math inline">\(\rho_1\)</span> en <span class="math inline">\(\rho_2\)</span>, probando que los dos diagramas de Heegaard describen el mismo encaje celular.</p>
<p><strong>Verificación del isomorfismo</strong> (haz clic en “Ejecutar”):</p>
<div class="sage-cell">
<script type="text/x-sage">
# Verificación del isomorfismo encontrado por la búsqueda con retroceso
sigma = PermutationGroupElement('(1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16)(17,18,19,20)(21,22,23,24)(25,26,27,28)(29,30,31,32)(33,34,35,36)(37,38,39,40)(41,42,43,44)(45,46,47,48)')
rho1  = PermutationGroupElement('(1,7)(2,36)(3,25)(4,48)(5,11)(6,40)(8,30)(9,15)(10,42)(12,34)(13,19)(14,38)(16,18)(17,23)(20,22)(21,27)(24,26)(28,32)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)')
rho2  = PermutationGroupElement('(1,7)(2,38)(3,25)(4,6)(5,11)(8,10)(9,15)(12,14)(13,19)(16,32)(17,23)(18,36)(20,48)(21,27)(22,40)(24,30)(26,42)(28,34)(29,35)(31,45)(33,39)(37,43)(41,47)(44,46)')

# Isomorfismo encontrado por el algoritmo
phi = PermutationGroupElement('(1,27)(2,28)(3,25)(4,26)(5,23)(6,24)(7,21)(8,22)(9,19)(10,20)(11,17)(12,18)(13,15)(14,16)(29,39)(30,40)(31,37)(32,38)(33,35)(34,36)(41,47)(42,48)(43,45)(44,46)')

# Verificar las dos condiciones de isomorfismo
cond_sigma = phi * sigma * phi^(-1) == sigma
cond_rho   = phi * rho1  * phi^(-1) == rho2

print("Verificación de φ · σ · φ⁻¹ = σ  :", cond_sigma)
print("Verificación de φ · ρ₁ · φ⁻¹ = ρ₂:", cond_rho)

if cond_sigma and cond_rho:
    print()
    print("✓ CONFIRMADO: los dos diagramas de Heegaard")
    print("  representan el mismo encaje celular.")
    print()
    print("φ =", phi)
</script>
</div>
<hr>
</section>
</section>
<section id="ejercicios" class="level2">
<h2 class="anchored" data-anchor-id="ejercicios">Ejercicios</h2>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Ejercicio 1: Verificación manual de la equivalencia
</div>
</div>
<div class="callout-body-container callout-body">
<p>Verifica a mano que <span class="math inline">\(\phi = (1,4)(2,3)(5,8)(6,7)(9,11)(10,12)\)</span> es un isomorfismo entre los dos sistemas del ejemplo del moño y el ojo. Para ello comprueba las <strong>dos</strong> condiciones de equivalencia:</p>
<ol type="1">
<li><span class="math inline">\(\phi \cdot \sigma_1 \cdot \phi^{-1} = \sigma_2\)</span> — aplica la conjugación dardo a dardo.</li>
<li><span class="math inline">\(\phi \cdot \rho \cdot \phi^{-1} = \rho\)</span> — verifica que el emparejamiento de aristas se preserva.</li>
</ol>
<p>Puedes ayudarte del código SageMath de la sección anterior, pero el objetivo es entender por qué cada transposición en <span class="math inline">\(\phi\)</span> envía correctamente cada ciclo al ciclo correspondiente.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Ejercicio 2: Otro diagrama de Heegaard de la Esfera de Poincaré
</div>
</div>
<div class="callout-body-container callout-body">
<p>La esfera de Poincaré admite varios diagramas de Heegaard. Busca en la literatura (o construye tú mismo) una descripción distinta a las dos presentadas aquí, que use también 12 vértices de valencia 4 (es decir, <span class="math inline">\(n = 48\)</span> dardos con <span class="math inline">\(\sigma\)</span> formada por ciclos de longitud 4).</p>
<p>Una vez tengas el sistema de rotación <span class="math inline">\((\sigma', \rho')\)</span>:</p>
<ol type="1">
<li>Verifica que es válido: <span class="math inline">\(\sigma'\)</span> formada por 12 cuatro-ciclos, <span class="math inline">\(\rho'\)</span> una involución fija sin puntos sobre <span class="math inline">\(\{1,\ldots,48\}\)</span>.</li>
<li>Calcula sus invariantes (<span class="math inline">\(V, E, F, \chi, g\)</span>) y comprueba que coinciden con los de los diagramas ya presentados.</li>
<li>Aplica la búsqueda con retroceso para determinar si es equivalente a alguno de los dos diagramas anteriores.</li>
</ol>
</div>
</div>
</section>
<section id="resumen" class="level2">
<h2 class="anchored" data-anchor-id="resumen">Resumen</h2>
<ul>
<li><strong>Invariantes como filtro rápido:</strong> Las longitudes de los ciclos de <span class="math inline">\(\phi = \rho\sigma\)</span> (las caras) son invariantes bajo isomorfismo. Si los multiconjuntos de longitudes difieren, la no-equivalencia queda probada sin necesidad de buscar <span class="math inline">\(\phi\)</span>.</li>
<li><strong>La estructura de <span class="math inline">\(\sigma\)</span> restringe la búsqueda:</strong> Todo isomorfismo debe mapear ciclos de <span class="math inline">\(\sigma_1\)</span> a ciclos de <span class="math inline">\(\sigma_2\)</span> de la misma longitud, lo que reduce el espacio de búsqueda de <span class="math inline">\(n!\)</span> a un número mucho menor de candidatos.</li>
<li><strong>Búsqueda con retroceso y propagación:</strong> Fijar <span class="math inline">\(\phi(d_1) = d_2\)</span> determina automáticamente los demás dardos del mismo ciclo de <span class="math inline">\(\sigma\)</span> y el dardo emparejado en <span class="math inline">\(\rho\)</span>. Las contradicciones se detectan y podan de inmediato, haciendo viable la búsqueda incluso para <span class="math inline">\(n = 48\)</span>.</li>
<li><strong>Unicidad en grafos 3-conexos:</strong> Por el Teorema de Whitney (1932), todo grafo planar 3-conexo tiene un único encaje en la esfera. Steinitz (1922) había probado el resultado equivalente para poliedros convexos.</li>
<li><strong>Diagramas de Heegaard como aplicación:</strong> Los dos diagramas de la Esfera de Poincaré con 12 vértices de valencia 4 resultan ser equivalentes: el algoritmo encuentra en menos de 0.1 segundos el isomorfismo <span class="math inline">\(\phi\)</span> que los conjuga.</li>
</ul>
<div style="text-align: center; margin-top: 3em; color: #94a3b8; font-size: 0.9em;">
<p>Publicado el 13 de febrero de 2026</p>
</div>


</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Volver arriba</a><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reutilización</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.es">CC BY-NC-SA 4.0</a></div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copiado");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copiado");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/joseleonm\.github\.io\/grafos-en-superficies");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
            // default icon
            link.classList.add("external");
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../capitulos/04-teorema.html" class="pagination-link" aria-label="4. Equivalencia">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">4. Equivalencia</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><strong>Sistemas de Rotación y Ribbon Graphs</strong><br> <span style="color: #94a3b8; font-size: 0.9em;">2026 • Teoría de Grafos Topológicos</span></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>