<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>6. Operaciones y Polinomio de Bollobás-Riordan – Sistemas de Rotación y Ribbon Graphs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-8b4baf804e461d9b72633f0de59a0cac.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-f9c6f0e9917b4ec8832aaecb36f8ee78.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No se han encontrado resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<link rel="stylesheet" type="text/css" href="https://sagecell.sagemath.org/static/sagecell_embed.css">
<script>
window.addEventListener('load', function() {
  sagecell.makeSagecell({
    inputLocation: 'div.sage-cell',
    evalButtonText: 'Ejecutar',
    languages: ['sage'],
    hide: []
  });
});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Sistemas de Rotación</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Buscar"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Navegación de palanca" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../index.html" aria-current="page"> <i class="bi bi-house-fill" role="img">
</i> 
<span class="menu-text">Inicio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/01-sistemas-rotacion.html"> 
<span class="menu-text">1. Sistemas de Rotación</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/02-mapas-combinatorios.html"> 
<span class="menu-text">2. Mapas Combinatorios</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/03-invariantes.html"> 
<span class="menu-text">3. Invariantes Topológicos</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/04-teorema.html"> 
<span class="menu-text">4. Equivalencia</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/05-ejemplos.html"> 
<span class="menu-text">5. Ejemplos</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/joseleonm/grafos-en-superficies"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">6. Operaciones y Polinomio de Bollobás-Riordan</li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Buscar" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link"><i class="bi bi-house-fill" role="img">
</i> 
 <span class="menu-text">Inicio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/01-sistemas-rotacion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Sistemas de Rotación</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/02-mapas-combinatorios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Mapas Combinatorios</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/03-invariantes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. Invariantes Topológicos</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/04-teorema.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4. Equivalencia</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/05-ejemplos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5. Ejemplos</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">6. Operaciones y Polinomio de Bollobás-Riordan</h1>
<p class="subtitle lead">Transformaciones sobre ribbon graphs e invariantes polinomiales</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>En los capítulos anteriores aprendimos a construir ribbon graphs, calcular invariantes topológicos y verificar equivalencia entre sistemas de rotación. Este capítulo explora dos temas complementarios: las <strong>operaciones</strong> que transforman un ribbon graph en otro, y el <strong>polinomio de Bollobás-Riordan</strong>, un invariante algebraico que codifica simultáneamente información combinatoria y topológica del encaje.</p>
<hr>
<section id="operaciones-sobre-ribbon-graphs" class="level2">
<h2 class="anchored" data-anchor-id="operaciones-sobre-ribbon-graphs">Operaciones sobre Ribbon Graphs</h2>
<section id="contracción-de-aristas" class="level3">
<h3 class="anchored" data-anchor-id="contracción-de-aristas">Contracción de Aristas</h3>
<p>La <strong>contracción</strong> de una arista fusiona sus dos extremos en un único vértice, preservando el orden cíclico de los darts restantes.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Nota</span>Definición: Contracción
</div>
</div>
<div class="callout-body-container callout-body">
<p>Dado un ribbon graph <span class="math inline">\(G = (\sigma, \rho)\)</span> y una arista no-loop <span class="math inline">\(e = \{d, \rho(d)\}\)</span> cuyos extremos son los vértices <span class="math inline">\(u\)</span> y <span class="math inline">\(v\)</span> (ciclos de <span class="math inline">\(\sigma\)</span>), la contracción <span class="math inline">\(G/e\)</span> tiene:</p>
<ul>
<li><strong>Darts:</strong> todos excepto <span class="math inline">\(d\)</span> y <span class="math inline">\(\rho(d)\)</span></li>
<li><strong>Nueva <span class="math inline">\(\sigma\)</span>:</strong> los ciclos de <span class="math inline">\(u\)</span> y de <span class="math inline">\(v\)</span> se fusionan, intercalando el orden cíclico de <span class="math inline">\(v\)</span> donde estaba <span class="math inline">\(\rho(d)\)</span> dentro del ciclo de <span class="math inline">\(u\)</span>, y eliminando <span class="math inline">\(d\)</span> y <span class="math inline">\(\rho(d)\)</span></li>
<li><strong>Nueva <span class="math inline">\(\rho\)</span>:</strong> igual a <span class="math inline">\(\rho\)</span> restringida a los darts restantes</li>
</ul>
</div>
</div>
<p><strong>Efecto topológico:</strong> Contraer una arista no-loop preserva el número de caras y la característica de Euler: <span class="math display">\[V(G/e) = V-1, \quad E(G/e) = E-1, \quad F(G/e) = F, \quad \chi(G/e) = \chi(G)\]</span></p>
<p>En particular, la contracción de una arista no-loop <strong>preserva el género</strong>.</p>
<p><strong>Ejemplo:</strong> Tomamos el toro con dos vértices del capítulo 3 y contraemos una arista:</p>
<div class="sage-cell">
<script type="text/x-sage">
# Toro con dos vértices (capítulo 3)
# V=2, E=3, F=1  →  género 1
sigma = PermutationGroupElement('(1,3,5)(2,4,6)')
rho   = PermutationGroupElement('(1,2)(3,4)(5,6)')
G = RibbonGraph(sigma, rho)
phi = rho * sigma

print("Toro original:")
print(f"  sigma = {sigma}")
print(f"  rho   = {rho}")
print(f"  phi   = {phi}")
print(f"  V={len(sigma.cycle_tuples(singletons=True))}, "
      f"E={len(rho.cycle_tuples())}, "
      f"F={len(phi.cycle_tuples(singletons=True))}")
print(f"  Género = {G.genus()}")

# Contraer la arista que contiene el dart 1  (arista {1,2})
G2 = G.contract_edge(1)
phi2 = G2.rho() * G2.sigma()

print("\nTras contraer la arista {1,2}:")
print(f"  sigma = {G2.sigma()}")
print(f"  rho   = {G2.rho()}")
print(f"  phi   = {phi2}")
print(f"  V={len(G2.sigma().cycle_tuples(singletons=True))}, "
      f"E={len(G2.rho().cycle_tuples())}, "
      f"F={len(phi2.cycle_tuples(singletons=True))}")
print(f"  Género = {G2.genus()}")
print("\n→ El género se preserva: sigue siendo un toro con 1 vértice y 2 loops.")
</script>
</div>
<p>El resultado es un ribbon graph con un solo vértice y dos loops que todavía representa un toro (género 1). La contracción no cambia la superficie subyacente cuando la arista no es un loop.</p>
<hr>
</section>
<section id="dualidad" class="level3">
<h3 class="anchored" data-anchor-id="dualidad">Dualidad</h3>
<p>La <strong>dual</strong> de un ribbon graph intercambia los roles de los vértices y las caras, preservando las aristas.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Importante</span>Construcción de la Dual
</div>
</div>
<div class="callout-body-container callout-body">
<p>Dado <span class="math inline">\(G = (\sigma, \rho)\)</span> con permutación de caras <span class="math inline">\(\varphi = \rho\sigma\)</span>, la dual es: <span class="math display">\[G^* = (\varphi,\; \rho)\]</span></p>
<p>Los vértices de <span class="math inline">\(G^*\)</span> son las caras de <span class="math inline">\(G\)</span>, las aristas son las mismas, y las caras de <span class="math inline">\(G^*\)</span> son los vértices de <span class="math inline">\(G\)</span>. En fórmulas: <span class="math display">\[V^* = F, \quad E^* = E, \quad F^* = V, \quad g^* = g\]</span></p>
</div>
</div>
<p><strong>Ejemplo con el toro del capítulo 3:</strong></p>
<div class="sage-cell">
<script type="text/x-sage">
# Toro con dos vértices (capítulo 3)
sigma = PermutationGroupElement('(1,3,5)(2,4,6)')
rho   = PermutationGroupElement('(1,2)(3,4)(5,6)')
G = RibbonGraph(sigma, rho)
phi = rho * sigma   # permutación de caras

# Dual: sigma* = phi, rho* = rho (misma rho)
G_dual = RibbonGraph(phi, rho)
phi_dual = rho * phi   # caras de la dual

print("Original:")
print(f"  sigma = {sigma}   → {len(sigma.cycle_tuples(singletons=True))} vértice(s)")
print(f"  phi   = {phi}   → {len(phi.cycle_tuples(singletons=True))} cara(s)")
print(f"  Género = {G.genus()}")

print("\nDual  (sigma* = phi, rho* = rho):")
print(f"  sigma* = {G_dual.sigma()}   → {len(G_dual.sigma().cycle_tuples(singletons=True))} vértice(s)")
print(f"  phi*   = {phi_dual}   → {len(phi_dual.cycle_tuples(singletons=True))} cara(s)")
print(f"  Género = {G_dual.genus()}")

print()
V  = len(sigma.cycle_tuples(singletons=True))
F  = len(phi.cycle_tuples(singletons=True))
Vs = len(G_dual.sigma().cycle_tuples(singletons=True))
Fs = len(phi_dual.cycle_tuples(singletons=True))
print(f"Verificación:  V* = {Vs} = F = {F}  {'✓' if Vs == F else '✗'}")
print(f"               F* = {Fs} = V = {V}  {'✓' if Fs == V else '✗'}")
print(f"               g* = {G_dual.genus()} = g = {G.genus()}  {'✓' if G_dual.genus() == G.genus() else '✗'}")
</script>
</div>
<p>El toro del capítulo 3 tiene <span class="math inline">\(V=2\)</span>, <span class="math inline">\(E=3\)</span>, <span class="math inline">\(F=1\)</span>; su dual tiene <span class="math inline">\(V^*=1\)</span>, <span class="math inline">\(E^*=3\)</span>, <span class="math inline">\(F^*=2\)</span> y el mismo género 1.</p>
<hr>
</section>
<section id="base-de-homología" class="level3">
<h3 class="anchored" data-anchor-id="base-de-homología">Base de Homología</h3>
<p>La base de homología de la superficie subyacente a un ribbon graph se puede calcular directamente con Sage. Para una superficie orientable de género <span class="math inline">\(g\)</span> con <span class="math inline">\(b\)</span> componentes de frontera, el rango del primer grupo de homología es: <span class="math display">\[\mathrm{rank}(H_1(S,\mathbb{Z})) = 2g + b - 1\]</span></p>
<p>El toro del capítulo 3 tiene género 1 y <span class="math inline">\(b=1\)</span> componente de frontera (superficie cerrada), por lo que el rango esperado es <span class="math inline">\(2(1) + 1 - 1 = 2\)</span>:</p>
<div class="sage-cell">
<script type="text/x-sage">
sigma = PermutationGroupElement('(1,3,5)(2,4,6)')
rho   = PermutationGroupElement('(1,2)(3,4)(5,6)')
G = RibbonGraph(sigma, rho)

print(f"Género:    {G.genus()}")
print(f"Fronteras: {G.number_boundaries()}")

base = G.homology_basis()
esperado = 2*G.genus() + G.number_boundaries() - 1
print(f"rank(H_1) = {len(base)}   (esperado 2g+b-1 = {esperado})")
print()
print("Base de homología (secuencias de darts):")
for i, ciclo in enumerate(base, 1):
    print(f"  Ciclo {i}: {ciclo}")
</script>
</div>
<p>Los dos ciclos de la base corresponden a los dos “agujeros” fundamentales del toro: el camino a lo largo del tubo y el camino alrededor del tubo.</p>
<hr>
</section>
</section>
<section id="el-polinomio-de-bollobás-riordan" class="level2">
<h2 class="anchored" data-anchor-id="el-polinomio-de-bollobás-riordan">El Polinomio de Bollobás-Riordan</h2>
<section id="motivación" class="level3">
<h3 class="anchored" data-anchor-id="motivación">Motivación</h3>
<p>El polinomio de Tutte clásico es un invariante potente para grafos abstractos, pero <strong>no detecta la topología del encaje</strong>: dos ribbon graphs con el mismo grafo subyacente y el mismo polinomio de Tutte pueden encajarse en superficies de géneros distintos.</p>
<p>El <strong>polinomio de Bollobás-Riordan</strong> <span class="citation" data-cites="bollobas2002">[@bollobas2002]</span> subsana esta limitación. Introduce una variable <span class="math inline">\(z\)</span> cuyo exponente registra el género del subgrafo encajado. Así, para grafos planos la variable <span class="math inline">\(z\)</span> no aparece, mientras que para encajes en el toro o superficies de género mayor sí lo hace.</p>
<p><strong>Ejemplo ilustrativo:</strong> el grafo theta (dos vértices unidos por tres aristas paralelas) admite dos encajes distintos:</p>
<ul>
<li>En la <strong>esfera</strong> (género 0): <span class="math inline">\(\sigma=(1,3,5)(2,6,4)\)</span>, <span class="math inline">\(\rho=(1,2)(3,4)(5,6)\)</span> → <span class="math inline">\(V=2\)</span>, <span class="math inline">\(E=3\)</span>, <span class="math inline">\(F=3\)</span></li>
<li>En el <strong>toro</strong> (género 1): <span class="math inline">\(\sigma=(1,3,5)(2,4,6)\)</span>, <span class="math inline">\(\rho=(1,2)(3,4)(5,6)\)</span> → <span class="math inline">\(V=2\)</span>, <span class="math inline">\(E=3\)</span>, <span class="math inline">\(F=1\)</span></li>
</ul>
<p>Ambos tienen el mismo grafo abstracto, pero el polinomio de Bollobás-Riordan los distingue.</p>
<hr>
</section>
<section id="definición" class="level3">
<h3 class="anchored" data-anchor-id="definición">Definición</h3>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Importante</span>Polinomio de Bollobás-Riordan
</div>
</div>
<div class="callout-body-container callout-body">
<p>Sea <span class="math inline">\(G = (\sigma, \rho)\)</span> un ribbon graph con <span class="math inline">\(n\)</span> vértices, <span class="math inline">\(m\)</span> aristas y <span class="math inline">\(k(G)\)</span> componentes conexas. El <strong>polinomio de Bollobás-Riordan</strong> es: <span class="math display">\[R(G;\, x, y, z) = \sum_{A \subseteq E} (x-1)^{k(A)-k(G)} \cdot y^{|A|-n+k(A)} \cdot z^{\gamma(A)}\]</span></p>
<p>donde para cada subconjunto de aristas <span class="math inline">\(A \subseteq E\)</span>:</p>
<ul>
<li><span class="math inline">\(k(A)\)</span> = número de componentes conexas del subgrafo <span class="math inline">\((V, A)\)</span></li>
<li><span class="math inline">\(\gamma(A)\)</span> = género del ribbon subgrafo sobre <span class="math inline">\(A\)</span>, dado por <span class="math display">\[\gamma(A) = \frac{2k(A) - n + |A| - \mathrm{bc}(A)}{2}\]</span></li>
<li><span class="math inline">\(\mathrm{bc}(A)\)</span> = ciclos de la permutación de caras <span class="math inline">\(\varphi_A = \rho_A \circ \sigma_A\)</span> sobre los darts <span class="math inline">\(D_A\)</span> de <span class="math inline">\(A\)</span>, <strong>más</strong> los vértices aislados (sin ningún dart en <span class="math inline">\(A\)</span>)</li>
</ul>
</div>
</div>
<p>La permutación <span class="math inline">\(\sigma_A\)</span> en <span class="math inline">\(D_A = \bigcup_{e \in A} \{d, \rho(d)\}\)</span> se obtiene siguiendo <span class="math inline">\(\sigma\)</span> desde cada dart hasta encontrar el siguiente dart que pertenezca a <span class="math inline">\(D_A\)</span>, saltando los que no lo hacen.</p>
</section>
<section id="interpretación-de-los-exponentes" class="level3">
<h3 class="anchored" data-anchor-id="interpretación-de-los-exponentes">Interpretación de los exponentes</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Exponente</th>
<th>Significado</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(k(A) - k(G) \geq 0\)</span></td>
<td>Exceso de componentes respecto al grafo completo; 0 para subgrafos que mantienen la conectividad</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\lvert A\rvert - n + k(A) \geq 0\)</span></td>
<td>Rango del ciclo: 0 para bosques, positivo para subgrafos con ciclos</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\gamma(A) \geq 0\)</span></td>
<td>Género del ribbon subgrafo: 0 si <span class="math inline">\(A\)</span> es planamente encajable, positivo si captura topología no trivial</td>
</tr>
</tbody>
</table>
<p><strong>Evaluaciones especiales:</strong></p>
<ul>
<li><span class="math inline">\(R(G; 1, 1, 1) = 2^m\)</span> cuenta todos los subconjuntos de aristas</li>
<li>Para encajes en la esfera, <span class="math inline">\(z\)</span> no aparece: <span class="math inline">\(R(G; x, y, 0) = T(G; x, y)\)</span> recupera el polinomio de Tutte</li>
<li><span class="math inline">\([z^g]R(G; 1, 1, z)\)</span> cuenta los subgrafos cuyo ribbon subgrafo tiene género <span class="math inline">\(g\)</span></li>
</ul>
<hr>
</section>
<section id="implementación-en-sage" class="level3">
<h3 class="anchored" data-anchor-id="implementación-en-sage">Implementación en Sage</h3>
<p>La fórmula de suma sobre subgrafos es directamente computable. Iteramos sobre los <span class="math inline">\(2^m\)</span> subconjuntos de aristas y acumulamos cada término:</p>
<div class="sage-cell">
<script type="text/x-sage">
def bollobas_riordan(sigma_str, rho_str):
    """
    Calcula el polinomio de Bollobás-Riordan vía suma sobre subgrafos.

    R(G; x,y,z) = Σ_{A⊆E} (x-1)^{k(A)-k(G)} · y^{|A|-n+k(A)} · z^{γ(A)}

    donde γ(A) = (2k(A) - n + |A| - bc(A)) / 2
    y bc(A) = ciclos de φ_A = ρ_A∘σ_A en D_A + vértices aislados.
    """
    sigma = PermutationGroupElement(sigma_str)
    rho   = PermutationGroupElement(rho_str)

    sigma_cycles = sigma.cycle_tuples(singletons=True)
    rho_cycles   = rho.cycle_tuples()

    n = len(sigma_cycles)   # número de vértices
    m = len(rho_cycles)     # número de aristas

    # Mapear dart → índice de vértice
    dart_to_v = {}
    for i, cycle in enumerate(sigma_cycles):
        for d in cycle:
            dart_to_v[d] = i

    # k(A): componentes conexas con Union-Find
    def conn_comp(edge_indices):
        parent = list(range(n))
        def find(x):
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x
        for i in edge_indices:
            d1, d2 = rho_cycles[i]
            pa, pb = find(dart_to_v[d1]), find(dart_to_v[d2])
            if pa != pb:
                parent[pa] = pb
        return len(set(find(i) for i in range(n)))

    kG = conn_comp(range(m))

    P.<x, y, z> = PolynomialRing(ZZ)
    result = P(0)

    for mask in range(2^m):
        A = [i for i in range(m) if mask & (1 << i)]

        # Darts de las aristas en A
        D_A = set()
        for i in A:
            for d in rho_cycles[i]:
                D_A.add(d)

        kA = conn_comp(A)

        # σ_A: para cada dart en D_A, seguir σ hasta el siguiente dart en D_A
        sigma_A = {}
        for d in D_A:
            cur = sigma(d)
            while cur not in D_A:
                cur = sigma(cur)
            sigma_A[d] = cur

        # Ciclos de φ_A = ρ∘σ_A en D_A
        visited = set()
        bc = 0
        for start in D_A:
            if start not in visited:
                bc += 1
                cur = start
                while cur not in visited:
                    visited.add(cur)
                    cur = rho(sigma_A[cur])

        # Añadir vértices aislados (ningún dart suyo está en D_A)
        for cycle in sigma_cycles:
            if not any(d in D_A for d in cycle):
                bc += 1

        gamma = (2*kA - n + len(A) - bc) // 2
        result += (x-1)^(kA - kG) * y^(len(A) - n + kA) * z^gamma

    return result


# ── Verificación 1: toro de 1 vértice y 2 loops ──────────────────────────
# sigma=(1,3,2,4), rho=(1,2)(3,4)
# V=1, E=2, F=1 → género 1 (toro)
# Resultado esperado: 1 + 2y + y²z
print("=== Toro  (1 vértice, 2 loops) ===")
R1 = bollobas_riordan('(1,3,2,4)', '(1,2)(3,4)')
print(f"R = {R1}")
print()

# ── Verificación 2: toro del capítulo 3 ──────────────────────────────────
# sigma=(1,3,5)(2,4,6), rho=(1,2)(3,4)(5,6)
# V=2, E=3, F=1 → género 1 (toro)
print("=== Toro del capítulo 3  (2 vértices, 3 aristas paralelas) ===")
R2 = bollobas_riordan('(1,3,5)(2,4,6)', '(1,2)(3,4)(5,6)')
print(f"R = {R2}")
print()

# ── Verificación 3: loop en la esfera ────────────────────────────────────
# sigma=(1,2), rho=(1,2)
# V=1, E=1, F=2 → género 0 (esfera)
# Sin términos en z
print("=== Loop en la esfera  (género 0) ===")
R3 = bollobas_riordan('(1,2)', '(1,2)')
print(f"R = {R3}")
print()

# ── Grafo theta en la esfera (encaje planar) ─────────────────────────────
# sigma=(1,3,5)(2,6,4), rho=(1,2)(3,4)(5,6)
# V=2, E=3, F=3 → género 0 (esfera)
print("=== Grafo theta en la esfera  (género 0) ===")
R4 = bollobas_riordan('(1,3,5)(2,6,4)', '(1,2)(3,4)(5,6)')
print(f"R = {R4}")
</script>
</div>
<p>Los resultados esperados son:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 27%">
<col style="width: 45%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Ribbon graph</th>
<th style="text-align: center;">Género</th>
<th><span class="math inline">\(R(G;\, x, y, z)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Toro (1 vértice, 2 loops)</td>
<td style="text-align: center;">1</td>
<td><span class="math inline">\(1 + 2y + y^2z\)</span></td>
</tr>
<tr class="even">
<td>Toro del capítulo 3 (2 vértices, 3 aristas)</td>
<td style="text-align: center;">1</td>
<td><span class="math inline">\(x + 2 + 3y + y^2z\)</span></td>
</tr>
<tr class="odd">
<td>Loop en la esfera</td>
<td style="text-align: center;">0</td>
<td><span class="math inline">\(1 + y\)</span></td>
</tr>
<tr class="even">
<td>Grafo theta en la esfera</td>
<td style="text-align: center;">0</td>
<td><span class="math inline">\(x + 2 + 3y + y^2\)</span></td>
</tr>
</tbody>
</table>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>La variable <span class="math inline">\(z\)</span> y el género
</div>
</div>
<div class="callout-body-container callout-body">
<p>Compara los dos últimos renglones de la tabla: el grafo theta en la esfera da <span class="math inline">\(x + 2 + 3y + y^2\)</span> (sin <span class="math inline">\(z\)</span>), mientras que el mismo grafo theta encajado en el toro da <span class="math inline">\(x + 2 + 3y + y^2 z\)</span>. El único cambio es <span class="math inline">\(y^2 \to y^2 z\)</span>, lo que refleja que el subgrafo completo (todas las aristas) tiene género 0 en la esfera y género 1 en el toro.</p>
<p>Para grafos planamente encajados, <span class="math inline">\(\gamma(A) = 0\)</span> para todo <span class="math inline">\(A\)</span>, de modo que <span class="math inline">\(z\)</span> nunca aparece y <span class="math inline">\(R(G; x, y, 0) = T(G; x, y)\)</span> recupera el polinomio de Tutte clásico.</p>
</div>
</div>
<hr>
</section>
<section id="el-polinomio-como-invariante-de-ribbon-graphs" class="level3">
<h3 class="anchored" data-anchor-id="el-polinomio-como-invariante-de-ribbon-graphs">El polinomio como invariante de ribbon graphs</h3>
<p>Un resultado fundamental es que <strong>sistemas de rotación equivalentes tienen el mismo polinomio de Bollobás-Riordan</strong>. Esto se sigue de que la equivalencia es un isomorfismo de ribbon graphs: si <span class="math inline">\(\varphi \sigma_1 \varphi^{-1} = \sigma_2\)</span> y <span class="math inline">\(\varphi \rho \varphi^{-1} = \rho\)</span>, entonces <span class="math inline">\(\varphi\)</span> permuta los subconjuntos de aristas biyectivamente preservando todos los invariantes del que depende <span class="math inline">\(R\)</span>: <span class="math inline">\(k(A)\)</span>, <span class="math inline">\(\gamma(A)\)</span> y <span class="math inline">\(\mathrm{bc}(A)\)</span>.</p>
<p>En el capítulo 5 verificamos que el moño y el ojo son ribbon graphs equivalentes. Por este resultado, sus polinomios de Bollobás-Riordan deben ser iguales. El ejercicio 2 propone verificarlo computacionalmente.</p>
<hr>
</section>
</section>
<section id="ejercicios" class="level2">
<h2 class="anchored" data-anchor-id="ejercicios">Ejercicios</h2>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Ejercicio 1: Dualidad iterada
</div>
</div>
<div class="callout-body-container callout-body">
<p>Verifica computacionalmente que la dual del dual coincide con el grafo original. Para el toro del capítulo 3 (<span class="math inline">\(\sigma=(1,3,5)(2,4,6)\)</span>, <span class="math inline">\(\rho=(1,2)(3,4)(5,6)\)</span>):</p>
<ol type="1">
<li>Calcula <span class="math inline">\(G^*=(\varphi, \rho)\)</span> con <span class="math inline">\(\varphi = \rho\sigma\)</span>.</li>
<li>Calcula <span class="math inline">\((G^*)^* = (\varphi^*, \rho)\)</span> con <span class="math inline">\(\varphi^* = \rho \cdot \varphi\)</span> (las caras de <span class="math inline">\(G^*\)</span>).</li>
<li>¿Obtienes el <span class="math inline">\(\sigma\)</span> original o uno equivalente por conjugación?</li>
</ol>
<p>Repite con el moño (<span class="math inline">\(\sigma_1=(1,2,3,4)(5,10)(6,9)(8,12)(7,11)\)</span>, <span class="math inline">\(\rho=(1,5)(4,8)(2,6)(3,7)(9,10)(11,12)\)</span>) y verifica que <span class="math inline">\((G^*)^* \cong G\)</span> en ambos casos.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Ejercicio 2: El moño y el ojo tienen el mismo polinomio
</div>
</div>
<div class="callout-body-container callout-body">
<p>Usa la función <code>bollobas_riordan</code> para calcular <span class="math inline">\(R(\text{moño}; x, y, z)\)</span> y <span class="math inline">\(R(\text{ojo}; x, y, z)\)</span> con los datos:</p>
<p><span class="math display">\[\rho = (1,5)(4,8)(2,6)(3,7)(9,10)(11,12)\]</span> <span class="math display">\[\sigma_1=(1,2,3,4)(5,10)(6,9)(8,12)(7,11), \quad \sigma_2=(1,4,3,2)(5,10)(6,9)(8,12)(7,11)\]</span></p>
<ol type="1">
<li>Verifica que <span class="math inline">\(R(\sigma_1, \rho) = R(\sigma_2, \rho)\)</span> (ambos son equivalentes, luego el polinomio debe coincidir).</li>
<li>¿Aparece <span class="math inline">\(z\)</span> en el polinomio? ¿Qué dice eso del género del encaje?</li>
<li>Compara con <span class="math inline">\(R\)</span> del toro de 1 vértice y 2 loops: ¿son iguales o distintos los polinomios?</li>
</ol>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Ejercicio 3: Encaje planar vs.&nbsp;no planar del grafo theta
</div>
</div>
<div class="callout-body-container callout-body">
<p>El <strong>grafo theta</strong> son dos vértices conectados por tres aristas paralelas. Tiene dos encajes celulares cualitativamente distintos:</p>
<ul>
<li><strong>En la esfera</strong>: <span class="math inline">\(\sigma_{\mathrm{esf}} = (1,3,5)(2,6,4)\)</span>, <span class="math inline">\(\rho=(1,2)(3,4)(5,6)\)</span> — tres caras, género 0</li>
<li><strong>En el toro</strong>: <span class="math inline">\(\sigma_{\mathrm{tor}} = (1,3,5)(2,4,6)\)</span>, <span class="math inline">\(\rho=(1,2)(3,4)(5,6)\)</span> — una cara, género 1</li>
</ul>
<ol type="1">
<li>Calcula el polinomio de Bollobás-Riordan de cada encaje.</li>
<li>¿En qué término difieren? ¿Puede el polinomio de Tutte distinguirlos?</li>
<li>Calcula la base de homología de cada ribbon graph y comprueba que el rango es <span class="math inline">\(2g + b - 1\)</span>.</li>
</ol>
</div>
</div>
<hr>
</section>
<section id="resumen" class="level2">
<h2 class="anchored" data-anchor-id="resumen">Resumen</h2>
<ul>
<li>La <strong>contracción</strong> de una arista no-loop preserva el género: <span class="math inline">\(\chi(G/e) = \chi(G)\)</span>.</li>
<li>La <strong>dualidad</strong> intercambia vértices y caras con la misma <span class="math inline">\(\rho\)</span>: <span class="math inline">\(V^*=F\)</span>, <span class="math inline">\(F^*=V\)</span>, <span class="math inline">\(g^*=g\)</span>.</li>
<li>La <strong>base de homología</strong> tiene rango <span class="math inline">\(2g + b - 1\)</span>, contando los ciclos fundamentales de la superficie.</li>
<li>El <strong>polinomio de Bollobás-Riordan</strong> generaliza el de Tutte: la variable <span class="math inline">\(z\)</span> detecta el género de los subgrafos encajados y está ausente en encajes planos.</li>
<li>La fórmula de suma sobre subgrafos es directamente computable en Sage iterando sobre los <span class="math inline">\(2^m\)</span> subconjuntos de aristas.</li>
<li>El polinomio es un <strong>invariante de ribbon graphs</strong>: sistemas de rotación equivalentes dan el mismo polinomio.</li>
</ul>
<p>El polinomio de Bollobás-Riordan es un área activa de investigación con conexiones a teoría de nudos (polinomios de nudos tipo HOMFLY-PT), física matemática (modelos de Potts en superficies), y combinatoria enumerativa de mapas.</p>
<hr>
</section>
<section id="referencias" class="level2">
<h2 class="anchored" data-anchor-id="referencias">Referencias</h2>
<ul>
<li>Bollobás, B., &amp; Riordan, O. (2002). A polynomial of graphs on surfaces. <em>Mathematische Annalen</em>, <strong>323</strong>(1), 81–96.</li>
<li>Chmutov, S. (2009). Generalized duality for graphs on surfaces and the signed Bollobás–Riordan polynomial. <em>Journal of Combinatorial Theory, Series B</em>, <strong>99</strong>(3), 617–638.</li>
<li>Ellis-Monaghan, J. A., &amp; Moffatt, I. (2013). <em>Graphs on Surfaces: Dualities, Polynomials, and Knots</em>. Springer.</li>
<li><a href="https://doc.sagemath.org/html/en/reference/graphs/sage/graphs/ribbon_graph.html">SageMath – Ribbon Graphs</a></li>
</ul>


</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Volver arriba</a><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reutilización</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.es">CC BY-NC-SA 4.0</a></div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copiado");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copiado");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/joseleonm\.github\.io\/grafos-en-superficies");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
            // default icon
            link.classList.add("external");
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><strong>Sistemas de Rotación y Ribbon Graphs</strong><br> <span style="color: #94a3b8; font-size: 0.9em;">2026 • Teoría de Grafos Topológicos</span></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>