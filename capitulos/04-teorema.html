<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>4. Teoremas Clave – Sistemas de Rotación y Ribbon Graphs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../capitulos/03-invariantes.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-8b4baf804e461d9b72633f0de59a0cac.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-dc1ea5b7a8322464832b99c8fca3a205.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No se han encontrado resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@300;400;600;700&amp;family=Fira+Code:wght@400;500;700&amp;display=swap" rel="stylesheet">
<meta name="keywords" content="ribbon graphs, sistemas de rotación, teoría de grafos topológicos, genus, embeddings">
<meta property="og:type" content="website">
<meta property="og:title" content="4. Teoremas Clave – Sistemas de Rotación y Ribbon Graphs">
<meta property="og:description" content="La correspondencia biunívoca entre sistemas de rotación y encajes">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Sistemas de Rotación</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Buscar"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Navegación de palanca" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../index.html" aria-current="page"> <i class="bi bi-house-fill" role="img">
</i> 
<span class="menu-text">Inicio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/01-sistemas-rotacion.html"> 
<span class="menu-text">1. Sistemas de Rotación</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/02-mapas-combinatorios.html"> 
<span class="menu-text">2. Mapas Combinatorios</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/03-invariantes.html"> 
<span class="menu-text">3. Invariantes Topológicos</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capitulos/04-teorema.html"> 
<span class="menu-text">4. Teoremas Clave</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/joseleonm/grafos-en-superficies"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../capitulos/04-teorema.html">4. Teoremas Clave</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Buscar" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link"><i class="bi bi-house-fill" role="img">
</i> 
 <span class="menu-text">Inicio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/01-sistemas-rotacion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Sistemas de Rotación</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/02-mapas-combinatorios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Mapas Combinatorios</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/03-invariantes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. Invariantes Topológicos</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/04-teorema.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">4. Teoremas Clave</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">4. Teoremas Clave</h1>
<p class="subtitle lead">La correspondencia biunívoca entre sistemas de rotación y encajes</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Recordamos que dos encajes de grafos <span class="math inline">\(G_1 \subset S_1\)</span> y <span class="math inline">\(G_2 \subset S_2\)</span> son <strong>equivalentes</strong> si existe un homeomorfismo que preserva la orientación <span class="math inline">\(h: S_1 \to S_2\)</span> tal que <span class="math inline">\(h(G_1) = G_2\)</span>. Esto implica que <span class="math inline">\(h\)</span> induce un isomorfismo entre los grafos abstractos subyacentes.</p>
<p>Además vimos que la <strong>Realización topológica</strong> (sección 2) proporciona una función explícita:</p>
<p><span class="math display">\[
\begin{aligned}
\text{Mapas Combinatorios} \quad &amp;\rightarrow \quad \text{Ribbon graphs}  \\
(D,\sigma, \rho) \quad &amp;\mapsto \quad  (G,\iota)
\end{aligned}
\]</span></p>
<p>Ahora veamos que la inversa de esta asignación está bien definida, salvo reetiquetado de dardos.</p>
<section id="la-esquematización-de-un-grafo-encajado" class="level2">
<h2 class="anchored" data-anchor-id="la-esquematización-de-un-grafo-encajado">La esquematización de un grafo encajado</h2>
<p>Dado un grafo ya encajado en una superficie, se puede “leer” el encaje recorriendo las fronteras de las caras para obtener su mapa combinatorio. Esta es la dirección que se usa para analizar un mapa ya existente.</p>
<p>Para ello, como vimos en la sección 1, se subdivide cada arista del grafo encajado para crear un par de semiaristas (dardos) y se etiquetan. Luego:</p>
<ol type="1">
<li>En cada vértice, la orientación de la superficie induce un orden cíclico único de los dardos incidentes. La colección de estos ciclos disjuntos define la permutación <strong><code>σ</code></strong> (sigma).</li>
<li>Cada arista original corresponde a un par de dardos. La colección de estas parejas (transposiciones) define la permutación <strong><code>ρ</code></strong> (rho).</li>
</ol>
<p>El par <code>(σ, ρ)</code> es el mapa combinatorio o esquema asociado al encaje.</p>
</section>
<section id="ejemplo" class="level2">
<h2 class="anchored" data-anchor-id="ejemplo">Ejemplo</h2>
<p>Consideremos el siguiente grafo encajado en el toro.</p>
<div style="text-align:center">
<p><a href="../imagenes/toro.html"><img src="../imagenes/grafotoro.png" class="img-fluid" style="width:60.0%"></a></p>
</div>
<p>Después de cortarlo alrededor de un meridiano y una longitud fijas, obtenemos su cuadrado fundamental:</p>
<div style="text-align:center">
<p><img src="../imagenes/grafotorodiagrama.png" class="img-fluid" style="width:70.0%"></p>
</div>
<p>Del diagrama con identificaciones ahora se ve claro que el sistema de rotación asociado es: <span class="math display">\[
\begin{aligned}
\sigma&amp;=(1234)(5678)(9\,10\,11\,12) \\
\rho &amp;= (1\,7)(2\,8)(3\,9)(4\,10)(5\,11)(6\,12)
\end{aligned}
\]</span></p>
<p>Este es un sistema de rotación válido y podemos verificar en <a href="https://sagecell.sagemath.org/">SageMathCell</a> que en efecto produce un encaje en el toro con el siguiente código mínimo:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="st">"(1,2,3,4)(5,6,7,8)(9,10,11,12)"</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> <span class="st">"(1,7)(2,8)(3,9)(4,10)(5,11)(6,12)"</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> verifica_toro(sigma, rho):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(sigma, <span class="bu">str</span>): sigma <span class="op">=</span> PermutationGroupElement(sigma)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(rho, <span class="bu">str</span>): rho <span class="op">=</span> PermutationGroupElement(rho)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> RibbonGraph(sigma, rho)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    phi <span class="op">=</span> rho <span class="op">*</span> sigma</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> <span class="bu">len</span>(sigma.cycle_tuples(singletons<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    E <span class="op">=</span> <span class="bu">len</span>(rho.cycle_tuples(singletons<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> <span class="bu">len</span>(phi.cycle_tuples(singletons<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    chi <span class="op">=</span> V <span class="op">-</span> E <span class="op">+</span> F</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> R.genus()</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> R.number_boundaries()</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"V=</span><span class="sc">{</span>V<span class="sc">}</span><span class="ss">, E=</span><span class="sc">{</span>E<span class="sc">}</span><span class="ss">, F=</span><span class="sc">{</span>F<span class="sc">}</span><span class="ss">, χ=</span><span class="sc">{</span>chi<span class="sc">}</span><span class="ss">, b=</span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">, g=</span><span class="sc">{</span>g<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Encaje en el toro (al cerrar las caras)."</span> <span class="cf">if</span> g <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="st">"No es toro."</span>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>verifica_toro(sigma, rho)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<p>Sin embargo, notar que la asignación del mapa combinatorio no es única, pues podríamos reetiquetar los números y se preserva la misma combinatoria. Por eso imponemos la siguiente clase de equivalencia:</p>
<section id="equivalencia-de-sistemas-de-rotación" class="level3">
<h3 class="anchored" data-anchor-id="equivalencia-de-sistemas-de-rotación">Equivalencia de Sistemas de Rotación</h3>
<p>Dos sistemas de rotación <span class="math inline">\((\sigma_1, \rho_1)\)</span> sobre un conjunto de semiaristas <span class="math inline">\(D_1\)</span> y <span class="math inline">\((\sigma_2, \rho_2)\)</span> sobre <span class="math inline">\(D_2\)</span> son <strong>equivalentes</strong> (o isomorfos) si existe una biyección <span class="math inline">\(\tau: D_1 \to D_2\)</span> tal que:</p>
<p><span class="math display">\[
\sigma_2 = \tau \sigma_1 \tau^{-1} \quad \text{y} \quad \rho_2 = \tau \rho_1 \tau^{-1}
\]</span></p>
<p>Esta biyección <span class="math inline">\(\tau\)</span> preserva toda la estructura combinatoria: mapea vértices a vértices (ciclos de <span class="math inline">\(\sigma\)</span>) y aristas a aristas (ciclos de <span class="math inline">\(\rho\)</span>).</p>
</section>
</section>
<section id="el-teorema-de-heffter-edmonds" class="level2">
<h2 class="anchored" data-anchor-id="el-teorema-de-heffter-edmonds">El Teorema de Heffter-Edmonds</h2>
<p>El <strong>Teorema de Heffter-Edmonds</strong> es la piedra angular de la teoría de grafos topológicos. No solo establece que todo sistema de rotación genera una superficie, sino que la correspondencia es estructuralmente perfecta: clasifica los encajes salvo equivalencia.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Importante</span>Teorema de Heffter-Edmonds
</div>
</div>
<div class="callout-body-container callout-body">
<p>Existe una correspondencia biunívoca entre:</p>
<ol type="1">
<li>Clases de equivalencia de <strong>sistemas de rotación</strong> <span class="math inline">\((\sigma, \rho)\)</span>.</li>
<li>Clases de equivalencia de <strong>encajes celulares</strong> de grafos en superficies orientables.</li>
</ol>
<p>Esto significa que el álgebra de las permutaciones <span class="math inline">\((\sigma, \rho)\)</span> captura <strong>toda</strong> la información topológica del encaje, sin pérdida ni ambigüedad.</p>
</div>
</div>
<section id="importancia-histórica-y-práctica" class="level3">
<h3 class="anchored" data-anchor-id="importancia-histórica-y-práctica">Importancia Histórica y Práctica</h3>
<p>Este resultado transforma problemas topológicos en problemas puramente combinatorios:</p>
<ul>
<li><strong>Heffter (1891):</strong> Primeros trabajos sobre encajes de grafos en superficies.</li>
<li><strong>Edmonds (1960):</strong> Formulación moderna en términos de permutaciones.</li>
<li><strong>Ringel (1974):</strong> En su libro <em>Map Color Theorem</em>, presenta una demostración constructiva basada en “esquemas”, enfatizando que la rotación induce directamente las fronteras de las caras.</li>
<li>También conocido como el teorema de representación de superficies</li>
</ul>
<hr>
<p>La inyectividad de la correspondencia (unicidad) se demuestra reconstruyendo el sistema de rotación a partir del encaje. Dado un grafo <span class="math inline">\(G\)</span> encajado celularmente en una superficie orientada <span class="math inline">\(S\)</span>:</p>
<ol type="1">
<li><strong>Lectura Local:</strong> Para cada vértice <span class="math inline">\(v\)</span>, consideramos un entorno pequeño homeomorfo a un disco. La orientación global de <span class="math inline">\(S\)</span> induce una orientación en la frontera de este disco (por ejemplo, sentido antihorario).</li>
<li><strong>Orden Cíclico:</strong> Las aristas incidentes a <span class="math inline">\(v\)</span> cruzan la frontera de este disco en puntos específicos. Al recorrer la frontera en el sentido inducido, leemos la secuencia de aristas. Esto define la permutación <span class="math inline">\(\sigma_v\)</span> de manera única.</li>
<li><strong>Invariancia:</strong> Si dos encajes son equivalentes, existe un homeomorfismo que preserva la orientación entre las superficies. Este homeomorfismo preserva necesariamente el orden cíclico de las aristas en cada vértice. Por lo tanto, dos encajes equivalentes producen el mismo sistema de rotación (salvo reetiquetado).</li>
</ol>
<p>Esta construcción demuestra que el sistema de rotación es un <strong>invariante completo</strong> del encaje.</p>
<hr>
</section>
<section id="ejemplo-encajes-idénticos-de-un-mismo-grafo" class="level3">
<h3 class="anchored" data-anchor-id="ejemplo-encajes-idénticos-de-un-mismo-grafo">Ejemplo: Encajes idénticos de un mismo grafo</h3>
<p>Consideremos algunos encajes del siguiente árbol.</p>
<style>
.uvwx-grid {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 16px;
  align-items: start;
}
.uvwx-item {
  text-align: center;
}
.uvwx-item img {
  width: 100%;
  height: auto;
}
.uvwx-item p {
  margin: 0.5rem 0 0;
}
@media (max-width: 680px) {
  .uvwx-grid {
    grid-template-columns: 1fr;
  }
}
</style>
<div class="uvwx-grid">
  <div class="uvwx-item">
    <img src="../imagenes/uvwx.png" alt="sigma=(1234), rho=(15)(26)(37)(48)">
    <p>\( \sigma_1=(1234) \), \( \rho=(15)(26)(37)(48) \)</p>
  </div>
  <div class="uvwx-item">
    <img src="../imagenes/uvwxrotado.png" alt="sigma=(1234), rho=(15)(26)(37)(48)">
    <p>\( \sigma_2=(1234) \), \( \rho=(15)(26)(37)(48) \)</p>
  </div>
  <div class="uvwx-item">
    <img src="../imagenes/uvwxreflejado.png" alt="sigma=(4321), rho=(15)(26)(37)(48)">
    <p>\( \sigma_3=(4321) \), \( \rho=(15)(26)(37)(48) \)</p>
  </div>
  <div class="uvwx-item">
    <img src="../imagenes/uvwxswap.png" alt="sigma=(1234), rho=(15)(26)(37)(48)">
    <p>\( \sigma_4=(1423) \), \( \rho=(15)(26)(37)(48) \)</p>
  </div>
</div>
<p><br></p>
<p>Podemos verificar en <a href="https://sagecell.sagemath.org/">SageMathCell</a> que en efecto dan un encaje de género 0:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> PermutationGroupElement(<span class="st">'(1,2,3,4)'</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> PermutationGroupElement(<span class="st">'(1,5)(2,6)(3,7)(4,8)'</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> RibbonGraph(sigma, rho)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>phi <span class="op">=</span> rho <span class="op">*</span> sigma</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> <span class="bu">len</span>(sigma.cycle_tuples(singletons<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> <span class="bu">len</span>(rho.cycle_tuples(singletons<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> <span class="bu">len</span>(phi.cycle_tuples(singletons<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Vértices (V): </span><span class="sc">{</span>V<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Aristas  (E): </span><span class="sc">{</span>E<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Caras    (F): </span><span class="sc">{</span>F<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"φ = ρσ: </span><span class="sc">{</span>phi<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Ciclos de φ: </span><span class="sc">{</span>phi<span class="sc">.</span>cycle_tuples(singletons<span class="op">=</span><span class="va">True</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> R.genus()</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> R.number_boundaries()</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Género (g): </span><span class="sc">{</span>g<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Fronteras (b): </span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<p>Los <strong>Sistemas 1 y 2</strong> son idénticos: <span class="math inline">\(\sigma_1=\sigma_2\)</span> y <span class="math inline">\(\rho\)</span> es el mismo. La etiqueta “rotado” solo cambia el dibujo, pero no el orden cíclico de los dardos, así que el sistema combinatorio no cambia.</p>
<p>El <strong>Sistema 3</strong> tiene <span class="math inline">\(\sigma_3=(4321)=\sigma_1^{-1}\)</span>, que corresponde a un reflejo. En este caso son equivalentes porque existe una biyección de dardos que conjuga uno en el otro y además preserva <span class="math inline">\(\rho\)</span>. Toma <span class="math display">\[
\phi=(2\,4)(6\,8).
\]</span> Entonces <span class="math display">\[
\phi\,\sigma_1\,\phi^{-1}=(1\,4\,3\,2)=\sigma_3,
\]</span> y como <span class="math inline">\(\phi\)</span> solo intercambia las parejas <span class="math inline">\((2,4)\)</span> y <span class="math inline">\((6,8)\)</span>, se verifica <span class="math display">\[
\phi\,\rho\,\phi^{-1}=\rho.
\]</span></p>
<p>Para el <strong>Sistema 4</strong> con <span class="math inline">\(\sigma_4=(1\,4\,2\,3)\)</span>, también hay equivalencia con el Sistema 1. Toma <span class="math display">\[
\phi=(2\,4\,3)(6\,8\,7).
\]</span> Entonces <span class="math display">\[
\phi\,\sigma_1\,\phi^{-1}=(1\,4\,2\,3)=\sigma_4,
\]</span> y además <span class="math inline">\(\phi\)</span> preserva <span class="math inline">\(\rho\)</span> porque solo permuta las parejas <span class="math inline">\((2,6)\)</span>, <span class="math inline">\((3,7)\)</span>, <span class="math inline">\((4,8)\)</span> entre sí, así que <span class="math display">\[
\phi\,\rho\,\phi^{-1}=\rho.
\]</span> Por lo tanto, los cuatro sistemas representan el mismo ribbon graph (misma clase de isomorfismo).</p>
<p>A primera vista cuesta distinguir estos encajes porque el grafo es muy simétrico. Probemos un ejemplo más complicado:</p>
</section>
<section id="ejemplo-encajes-diferentes-de-un-mismo-grafo-en-la-misma-superficie" class="level3">
<h3 class="anchored" data-anchor-id="ejemplo-encajes-diferentes-de-un-mismo-grafo-en-la-misma-superficie">Ejemplo: Encajes diferentes de un mismo grafo en la misma superficie</h3>
<style>
.encaje-grid {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 16px;
  align-items: start;
}
.encaje-item {
  text-align: center;
}
.encaje-item img {
  width: 100%;
  height: clamp(220px, 28vw, 320px);
  object-fit: contain;
}
.encaje-item p {
  margin: 0.5rem 0 0;
}
@media (max-width: 680px) {
  .encaje-grid {
    grid-template-columns: 1fr;
  }
}
</style>
<div class="encaje-grid">
  <div class="encaje-item">
    <img src="../imagenes/triangulos.png" alt="sigma1">
    <p>\( \sigma_1=(1,2,3,4)(5,10)(6,9)(8,12)(7,11) \), \( \rho=(1,5)(4,8)(2,6)(3,7)(9,10)(11,12) \)</p>
  </div>
  <div class="encaje-item">
    <img src="../imagenes/ojo.png" alt="sigma2">
    <p>\( \sigma_2=(1,4,3,2)(5,10)(6,9)(8,12)(7,11) \), \( \rho=(1,5)(4,8)(2,6)(3,7)(9,10)(11,12) \)</p>
  </div>
</div>
<p><br></p>
<p>Estos dos mapas <strong>no</strong> son equivalentes: aunque comparten el mismo emparejamiento <span class="math inline">\(\rho\)</span>, el orden cíclico en el vértice principal está invertido en <span class="math inline">\(\sigma_2\)</span>. En este ejemplo esa inversión no puede obtenerse por una biyección de dardos que preserve <span class="math inline">\(\rho\)</span>, así que no existe <span class="math inline">\(\tau\)</span> tal que <span class="math inline">\(\tau\sigma_1\tau^{-1}=\sigma_2\)</span> y <span class="math inline">\(\tau\rho\tau^{-1}=\rho\)</span>. Por tanto, representan encajes no equivalentes.</p>
<p>Dicho de otra forma, en una representación <strong>plana</strong> con cara exterior distinguida, la diferencia se vuelve evidente al inspeccionar esa frontera. En la figura de la izquierda (el moño), la cara exterior colinda con los vértices de ambos triángulos; es posible trazar un camino desde cualquier vértice <span class="math inline">\((u,v,x,w)\)</span> hacia el infinito sin cruzar ninguna arista. En la figura de la derecha (el ojo), la cara exterior solo colinda con el triángulo mayor <span class="math inline">\((u,v)\)</span>: los vértices del triángulo menor <span class="math inline">\((x,w)\)</span> quedan topológicamente aislados en una cara interior, y es imposible conectarlos con el exterior sin cruzar el ciclo del triángulo mayor. Esta obstrucción topológica confirma que no existe un homeomorfismo que transforme un encaje en el otro preservando la orientación.</p>
<p>Nótese que en el ejemplo anterior tenemos un grafo 1-conexo; cuando aumentamos la complejidad del grafo sí se pueden garantizar encajes únicos. Esto se conecta con el <strong>Teorema de Whitney</strong>:</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Importante</span>Teorema de Whitney
</div>
</div>
<div class="callout-body-container callout-body">
<p>Todo grafo planar 3‑conexo tiene un encaje único en la esfera (único salvo equivalencia topológica, es decir, reflexiones y homeomorfismos).</p>
</div>
</div>
<p>Aquí “3‑conexo” <strong>no</strong> es “valencia 3”; se refiere a cuántos vértices hay que quitar para desconectar el grafo:</p>
<ul>
<li><strong>1‑conexo:</strong> al quitar 1 vértice el grafo se desconecta (p.&nbsp;ej. una estrella).</li>
<li><strong>2‑conexo:</strong> se requieren al menos 2 vértices para desconectarlo (p.&nbsp;ej. un ciclo).</li>
<li><strong>3‑conexo:</strong> se requieren al menos 3 vértices para desconectarlo.</li>
</ul>
<p>Ejemplos visuales de grafos 3‑conexos:</p>
<ul>
<li>El esqueleto de un cubo.</li>
<li>El esqueleto de un tetraedro (<span class="math inline">\(K_4\)</span>).</li>
<li>El esqueleto de un dodecaedro.</li>
</ul>
<hr>
</section>
</section>
<section id="ejercicios" class="level2">
<h2 class="anchored" data-anchor-id="ejercicios">Ejercicios</h2>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Ejercicio: Calcule el mapa combinatorio del siguiente grafo encajado.
</div>
</div>
<div class="callout-body-container callout-body">
<p><img src="../imagenes/esferaPoincare.jpg" class="img-fluid" style="width:90.0%"></p>
</div>
</div>
<hr>
</section>
<section id="resumen" class="level2">
<h2 class="anchored" data-anchor-id="resumen">Resumen</h2>
<ul>
<li><strong>Lectura del encaje:</strong> desde un dibujo encajado se obtiene <span class="math inline">\((\sigma,\rho)\)</span> leyendo el orden cíclico de dardos en cada vértice.</li>
<li><strong>Correspondencia fundamental:</strong> sistemas de rotación, ribbon graphs y encajes celulares describen el mismo objeto (Teorema de Heffter‑Edmonds).</li>
<li><strong>Verificación computacional:</strong> se calculan <span class="math inline">\(V,E,F,\chi,g\)</span> con SageMathCell para confirmar el género de ejemplos concretos.</li>
<li><strong>Equivalencia vs.&nbsp;no equivalencia:</strong> se muestran conjugaciones explícitas que identifican encajes y un ejemplo donde la cara exterior distingue dos mapas no equivalentes.</li>
<li><strong>Rigidez en grafos 3‑conexos:</strong> se conecta con el Teorema de Whitney para explicar por qué ciertos encajes son únicos salvo equivalencia.</li>
</ul>


</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Volver arriba</a><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reutilización</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.es">CC BY-NC-SA 4.0</a></div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copiado");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copiado");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/joseleonm\.github\.io\/grafos-en-superficies");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
            // default icon
            link.classList.add("external");
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../capitulos/03-invariantes.html" class="pagination-link" aria-label="3. Invariantes Topológicos">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">3. Invariantes Topológicos</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><strong>Sistemas de Rotación y Ribbon Graphs</strong><br> <span style="color: #94a3b8; font-size: 0.9em;">2026 • Teoría de Grafos Topológicos</span></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>