[
  {
    "objectID": "capitulos/01-sistemas-rotacion.html",
    "href": "capitulos/01-sistemas-rotacion.html",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Queremos codificar encajes celulares de grafos en superficies orientables sin dibujar la superficie, usando sólo datos combinatorios.\n\nEntrada: un grafo abstracto \\(G\\)\nDato extra: un sistema de rotación (orden cíclico local)\nSalida: una superficie orientable donde \\(G\\) queda encajado, más las caras y el género\n\nLa idea es que la información “local” (en vértices) determine completamente la estructura “global” (la superficie).\n\n\n\n\nPara trabajar con sistemas de rotación, descomponemos cada arista del grafo \\(G\\) mediante una partición formal. Insertamos un vértice ficticio (o de paso) en el interior de cada arista, lo que resulta en un conjunto \\(D\\) de semiaristas (también llamadas darts o half-edges).\nEsta construcción garantiza que:\n\nPartición por Arista: Cada arista original queda particionada exactamente en dos semiaristas que comparten el vértice ficticio.\nIncidencia en Vértices Originales: Cada semiarista \\(d \\in D\\) tiene un extremo en un vértice original de \\(G\\) y el otro en un vértice ficticio. Decimos que \\(d\\) está asociada al vértice original donde incide.\nRelación de Adyacencia (Involución): Dos semiaristas son adyacentes si comparten el mismo vértice ficticio. Esto define una permutación \\(\\rho: D \\to D\\) compuesta por trasposiciones (2-ciclos), donde cada ciclo vincula el par de semiaristas que conforman una arista original.\n\n\n\n\n\n\n\nNotaConteo de semiaristas\n\n\n\nSi el grafo tiene \\(E\\) aristas, tendremos \\(|D| = 2E\\) semiaristas en total, donde \\(D\\) es el conjunto de todas las semiaristas.\n\n\n\n\n\nConsideremos el grafo con un vértice y dos aristas.\n\n\n\nVértices: 1\nAristas: 2 aristas\nSemiaristas: 4 (etiquetadas 1, 2, 3, 4)\n\n\n\n\nEtiquetado de semiaristas\n\n\n\n\n\n\n\nUn sistema de rotación sobre un grafo \\(G\\) se define por un par de permutaciones \\((\\sigma, \\rho)\\) sobre el conjunto de semiaristas \\(D\\):\n\n\n\nEs un producto de ciclos disjuntos\nHay un ciclo por cada vértice de \\(G\\)\nCada ciclo describe el orden cíclico de las semiaristas incidentes a ese vértice\nEl orden cíclico refleja cómo las aristas se ordenan alrededor del vértice en la superficie\n\n\n\n\n\nEs un producto de 2-ciclos (transposiciones)\nCada 2-ciclo empareja las dos semiaristas que forman una arista\nEs una involución sin puntos fijos: \\(\\rho^2 = \\mathrm{id}\\)\n\n\n\n\n\n\n\nNotaContexto Histórico y Terminología\n\n\n\nLos sistemas de rotación tienen una rica historia y han sido redescubiertos en múltiples contextos:\n\nOrígenes: Fueron introducidos por Edmonds (1960) y formalizados por Youngs (1963), quien también introdujo sistemas con signo para superficies no orientables. Representaciones similares fueron propuestas independientemente por Jacques, Biggs, y Walsh & Lehman.\nDesarrollo: Tutte y Gross & Alpert extendieron estos sistemas. El encaje celular inducido que revisaremos más adelante es frecuentemente llamado encaje de Heffter-Edmonds.\nSinónimos: En la literatura se encuentran como vortex graphs, constelaciones, mapas combinatorios, fat graphs, ribbon graphs y dessins d’enfants.\n\nNuestra Convención: Adoptamos la notación de SageMath y Lando & Zvonkin, usando el par de permutaciones \\((\\sigma, \\rho)\\) sobre semiaristas y refiriéndonos a la estructura topológica como Ribbon Graph.\n\n\n\n\n\n\n\nRecordando la construcción del ejemplo anterior:\n\n\nVértices: 1\nAristas: 2\nSemiaristas: 4 (etiquetadas 1, 2, 3, 4)\n\nEs importante notar que \\(\\rho\\) está fijo por la construcción del grafo (la elección de qué pares de semiaristas forman cada arista). Por lo tanto, solo podemos variar \\(\\sigma\\).\nComo tenemos 4 semiaristas incidentes al mismo vértice, el número de posibles órdenes cíclicos es \\((4-1)! = 6\\). A continuación listamos todas las posibilidades:\n\n\\(\\sigma = (1, 2, 3, 4)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 2, 4, 3)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 3, 2, 4)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 3, 4, 2)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 4, 2, 3)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 4, 3, 2)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\nCada una de estas elecciones define un sistema de rotación válido. En las siguientes secciones veremos cómo estas permutaciones determinan la topología de la superficie resultante.\n\n\n\n\n\nConsideremos el grafo completo con 3 vértices: \\(K_3\\):\n\n\n\n\nVértices: 3 (A, B, C)\nAristas: 3 (AB, BC, CA)\nSemiaristas: 6 (etiquetadas 1, 2, 3, 4, 5, 6)\n\nAsignación de semiaristas:\n\nVértice A: semiaristas 1, 6\nVértice B: semiaristas 2, 3\nVértice C: semiaristas 4, 5\n\nAristas:\n\nAB: semiaristas 1 y 2\nBC: semiaristas 3 y 4\nCA: semiaristas 5 y 6\n\nPara definir el sistema de rotación, la asignación explícita de semiaristas es necesaria para fijar \\(\\rho\\).\n\n\\(\\rho\\): Queda determinado por los pares que forman las aristas. \\[\\rho = (1, 2)(3, 4)(5, 6)\\]\n\\(\\sigma\\): En este caso, como cada vértice tiene grado 2, existe un único orden cíclico posible para las semiaristas incidentes (\\((a,b)\\) es equivalente a \\((b,a)\\)). \\[\\sigma = (1, 6)(2, 3)(4, 5)\\]\n\nEste sistema describe el encaje estándar de \\(K_3\\) en la esfera (género 0).\n\n\n\n\n\nPara un grafo dado (sin vértices aislados), podemos calcular exactamente cuántos Sistemas de Rotación (que generan superficies orientables) se pueden construir. La fórmula depende enteramente de la conectividad local de los vértices.\n\n\nSi llamamos \\(N(G)\\) al número total de sistemas de rotación para un grafo \\(G\\), tenemos:\n\\[ N(G) = \\prod_{v \\in V(G)} (\\deg(v) - 1)! \\]\nDonde:\n\n\\(\\prod\\): Es el símbolo de producto (multiplicamos el resultado de cada vértice).\n\\(V(G)\\): Es el conjunto de todos los vértices del grafo.\n\\(\\deg(v)\\) (Grado): Es el número de semiaristas que llegan al vértice \\(v\\).\n\\((\\deg(v) - 1)!\\): Es el número de formas de organizar las semiaristas en un círculo (permutaciones cíclicas).\n\n\n\n\n\n\nEl grafo de un vértice y dos lazos:\n\nTenemos 1 vértice con grado \\(4\\).\nCálculo: \\((4-1)! = 6\\) sistemas.\nResultado: Coincide exactamente con la lista de \\(6\\) que vimos anteriormente.\n\nEl Triángulo (\\(K_3\\)):\n\nTenemos 3 vértices, cada uno con grado \\(2\\).\nCálculo: \\((2-1)! \\times (2-1)! \\times (2-1)! = 1\\) sistema.\nResultado: Por eso el \\(K_3\\) es “rígido”; solo puede encajarse de una forma (en la esfera).\n\n\n\n\n\n\nA medida que añadimos vértices y cada uno se conecta con todos los demás, el número de universos topológicos posibles crece de forma estrepitosa:\n\n\n\nGrafo\nVértices\nGrado\nFórmula\nTotal de Sistemas\n\n\n\n\n\\(K_3\\) (Triángulo)\n3\n2\n\\((1!)^3\\)\n1\n\n\n\\(K_4\\) (Tetraedro)\n4\n3\n\\((2!)^4\\)\n16\n\n\n\\(K_5\\) (Pentáculo)\n5\n4\n\\((3!)^5\\)\n7,776\n\n\n\\(K_6\\)\n6\n5\n\\((4!)^6\\)\n191,102,976\n\n\n\\(K_7\\)\n7\n6\n\\((5!)^7\\)\n358,318,080,000,000\n\n\n\n\nNota para la reflexión: ¡Para un simple grafo de 7 vértices, existen más de 358 billones de formas de encajarlo en superficies! La gran mayoría de estas formas resultarán en superficies con muchísimos “agujeros” (género alto), y solo unas pocas tendrán género mínimo (\\(K_7\\) no es planar).\n\n\n\n\n\n\nEl sistema de rotación \\((\\sigma, \\rho)\\) codifica:\n\nEl grafo subyacente\n\nLos ciclos de \\(\\sigma\\) determinan los vértices\nLos 2-ciclos de \\(\\rho\\) determinan las aristas\nPodemos reconstruir \\(G\\) desde \\((\\sigma, \\rho)\\)\n\nEl orden cíclico local\n\nCada ciclo de \\(\\sigma\\) indica cómo se ordenan las semiaristas alrededor de un vértice\nEste orden respeta la orientación de la superficie\n\n\n\n\n\n\nSageMath implementa ribbon graphs directamente desde sistemas de rotación:\nPuedes verificar estos cálculos rápidamente en línea usando SageMathCell.\n\n\nConstruyamos el sistema de rotación más estándar para este grafo:\n# Usamos PermutationGroupElement directamente\nsigma = PermutationGroupElement(\"(1,2,3,4)\")\nrho = PermutationGroupElement(\"(1,2)(3,4)\")\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Objeto creado: {R}\")\nprint(f\"Tipo: {type(R).__name__}\")\n\n# Recuperar las permutaciones almacenadas\nprint(f\"\\nPermutaciones:\")\nprint(f\"  σ = {R.sigma()}\")\nprint(f\"  ρ = {R.rho()}\")\n\n# Contar elementos del grafo\nnum_semiaristas = len(R.sigma().domain())\nnum_vertices = len(R.sigma().cycle_tuples(singletons=True))\nnum_aristas = len(R.rho().cycle_tuples())\n\nprint(f\"\\nEstructura del grafo:\")\nprint(f\"  Semiaristas: {num_semiaristas}\")\nprint(f\"  Vértices: {num_vertices}\")\nprint(f\"  Aristas: {num_aristas}\")\n\n\n\nPodemos etiquetar las semiaristas con cualquier numeración, no necesariamente 1,2,3,…\n# K₃ con numeración consecutiva empezando desde 10\nsigma_k3 = PermutationGroupElement(\"(10,15)(11,12)(13,14)\")\nrho_k3 = PermutationGroupElement(\"(10,11)(12,13)(14,15)\")\nR_k3 = RibbonGraph(sigma_k3, rho_k3)\n\nprint(f\"K₃ con numeración salteada:\")\nprint(f\"  σ = {R_k3.sigma()}\")\nprint(f\"  ρ = {R_k3.rho()}\")\nprint(f\"  Números usados: 10, 11, 12, 13, 14, 15\")\n\n# normalize() renumera del 1 al número de semiaristas\nR_norm = R_k3.normalize()\n\nprint(f\"\\nDespués de normalize():\")\nprint(f\"  σ = {R_norm.sigma()}\")\nprint(f\"  ρ = {R_norm.rho()}\")\nprint(f\"  Números usados: 1, 2, 3, 4, 5, 6\")\n\n# Verificar que la estructura se preserva\nprint(f\"\\nVértices: {len(R_k3.sigma().cycle_tuples())} → {len(R_norm.sigma().cycle_tuples())}\")\nprint(f\"Aristas: {len(R_k3.rho().cycle_tuples())} → {len(R_norm.rho().cycle_tuples())}\")\n\n\n\nPodemos calcular programáticamente cuántos sistemas de rotación existen para un grafo dado:\ndef contar_sistemas(R):\n    \"\"\"\n    Calcula N(G) = ∏(deg(v) - 1)! para un RibbonGraph\n    \"\"\"\n    grados = [len(ciclo) for ciclo in R.sigma().cycle_tuples(singletons=True)]\n    total = 1\n    for g in grados:\n        total *= factorial(g - 1)\n    return total, grados\n\n# Verificar con el Ejemplo 1: Un vértice, dos lazos\nsigma1 = PermutationGroupElement(\"(1,2,3,4)\")\nrho1 = PermutationGroupElement(\"(1,2)(3,4)\")\nR1 = RibbonGraph(sigma1, rho1)\n\ntotal1, grados1 = contar_sistemas(R1)\nprint(f\"Ejemplo 1: Un vértice, dos lazos\")\nprint(f\"  Grados de vértices: {grados1}\")\nprint(f\"  N(G) = (4-1)! = {total1}\")\n\n# Verificar con el Ejemplo 2: K₃\nsigma2 = PermutationGroupElement(\"(1,6)(2,3)(4,5)\")\nrho2 = PermutationGroupElement(\"(1,2)(3,4)(5,6)\")\nR2 = RibbonGraph(sigma2, rho2)\n\ntotal2, grados2 = contar_sistemas(R2)\nprint(f\"\\nEjemplo 2: Triángulo K₃\")\nprint(f\"  Grados de vértices: {grados2}\")\nprint(f\"  N(G) = (1!)³ = {total2}\")\n\n\n\n\n\n\n\n\n\n\n\nTipEjercicio 1\n\n\n\nConsidera un grafo con un vértice y tres self-loops (tres aristas que comienzan y terminan en el mismo vértice).\n\n¿Cuántas semiaristas tiene este sistema?\n¿Cuántos sistemas de rotación posibles existen para este grafo? Usa la fórmula manualmente.\nEscribe en Sage un sistema de rotación \\((\\sigma, \\rho)\\) para este grafo usando PermutationGroupElement.\nUsa la función contar_sistemas(R) del ejemplo para verificar tu cálculo del inciso (b).\n\n\n\n\n\n\n\n\n\nTipEjercicio 2\n\n\n\nExperimentando con numeración y normalización:\n\nCrea un RibbonGraph usando numeración salteada (por ejemplo, usando solo números pares o múltiplos de 5).\nUsa el método .normalize() para obtener la versión canónica.\nVerifica que el número de semiaristas se preserva usando len(R.sigma().domain()).\n¿Qué propiedades del grafo cambian con normalize() y cuáles se preservan?\n\n\n\n\n\n\n\n\n[GGD2011] E. Girondo, G. Gonzalez-Diez, Introduction to Compact Riemann surfaces and Dessins d’enfant, London Mathematical Society, Student Text 79, 2011.\n[LZ2004] S. Lando, A. Zvonkine, Graphs on Surfaces and Their Applications, Springer-Verlag, 2004.\n[Edmonds1960] J. Edmonds, A Combinatorial Representation for Polyhedral Surfaces, Notices Amer. Math. Soc. 7, 1960. (Tesis disponible en UMD)\n[Youngs1963] J. W. T. Youngs, The Genus of a Graph, Journal of Mathematics and Mechanics, Vol. 12, No. 2, 1963. JSTOR\n\n\n\n\n\n\n\nImportanteCambio de Perspectiva: El Mapa es el Territorio\n\n\n\nHasta ahora, hemos hablado de “poner un grafo sobre una superficie”. Sin embargo, en la práctica computacional (y en SageMath), el grafo abstracto y la superficie no existen antes de definir las permutaciones.\nEs fundamental entender que el par combinatorio \\((\\sigma, \\rho)\\) ES el objeto.\nNo “buscamos” un encaje para un sistema de rotación. El sistema de rotación construye su propia superficie única e inevitable.\nEn la siguiente sección, veremos cómo estas permutaciones “tejen” la superficie automáticamente, sin necesidad de dibujarla.\n\n\n\nPublicado el 06 de febrero de 2026",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#motivación",
    "href": "capitulos/01-sistemas-rotacion.html#motivación",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Queremos codificar encajes celulares de grafos en superficies orientables sin dibujar la superficie, usando sólo datos combinatorios.\n\nEntrada: un grafo abstracto \\(G\\)\nDato extra: un sistema de rotación (orden cíclico local)\nSalida: una superficie orientable donde \\(G\\) queda encajado, más las caras y el género\n\nLa idea es que la información “local” (en vértices) determine completamente la estructura “global” (la superficie).",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#semiaristas-darts-o-half-edges",
    "href": "capitulos/01-sistemas-rotacion.html#semiaristas-darts-o-half-edges",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Para trabajar con sistemas de rotación, descomponemos cada arista del grafo \\(G\\) mediante una partición formal. Insertamos un vértice ficticio (o de paso) en el interior de cada arista, lo que resulta en un conjunto \\(D\\) de semiaristas (también llamadas darts o half-edges).\nEsta construcción garantiza que:\n\nPartición por Arista: Cada arista original queda particionada exactamente en dos semiaristas que comparten el vértice ficticio.\nIncidencia en Vértices Originales: Cada semiarista \\(d \\in D\\) tiene un extremo en un vértice original de \\(G\\) y el otro en un vértice ficticio. Decimos que \\(d\\) está asociada al vértice original donde incide.\nRelación de Adyacencia (Involución): Dos semiaristas son adyacentes si comparten el mismo vértice ficticio. Esto define una permutación \\(\\rho: D \\to D\\) compuesta por trasposiciones (2-ciclos), donde cada ciclo vincula el par de semiaristas que conforman una arista original.\n\n\n\n\n\n\n\nNotaConteo de semiaristas\n\n\n\nSi el grafo tiene \\(E\\) aristas, tendremos \\(|D| = 2E\\) semiaristas en total, donde \\(D\\) es el conjunto de todas las semiaristas.",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#ejemplo-1-un-vértice-dos-lazos",
    "href": "capitulos/01-sistemas-rotacion.html#ejemplo-1-un-vértice-dos-lazos",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Consideremos el grafo con un vértice y dos aristas.\n\n\n\nVértices: 1\nAristas: 2 aristas\nSemiaristas: 4 (etiquetadas 1, 2, 3, 4)\n\n\n\n\nEtiquetado de semiaristas",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#definición-sistema-de-rotación",
    "href": "capitulos/01-sistemas-rotacion.html#definición-sistema-de-rotación",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Un sistema de rotación sobre un grafo \\(G\\) se define por un par de permutaciones \\((\\sigma, \\rho)\\) sobre el conjunto de semiaristas \\(D\\):\n\n\n\nEs un producto de ciclos disjuntos\nHay un ciclo por cada vértice de \\(G\\)\nCada ciclo describe el orden cíclico de las semiaristas incidentes a ese vértice\nEl orden cíclico refleja cómo las aristas se ordenan alrededor del vértice en la superficie\n\n\n\n\n\nEs un producto de 2-ciclos (transposiciones)\nCada 2-ciclo empareja las dos semiaristas que forman una arista\nEs una involución sin puntos fijos: \\(\\rho^2 = \\mathrm{id}\\)\n\n\n\n\n\n\n\nNotaContexto Histórico y Terminología\n\n\n\nLos sistemas de rotación tienen una rica historia y han sido redescubiertos en múltiples contextos:\n\nOrígenes: Fueron introducidos por Edmonds (1960) y formalizados por Youngs (1963), quien también introdujo sistemas con signo para superficies no orientables. Representaciones similares fueron propuestas independientemente por Jacques, Biggs, y Walsh & Lehman.\nDesarrollo: Tutte y Gross & Alpert extendieron estos sistemas. El encaje celular inducido que revisaremos más adelante es frecuentemente llamado encaje de Heffter-Edmonds.\nSinónimos: En la literatura se encuentran como vortex graphs, constelaciones, mapas combinatorios, fat graphs, ribbon graphs y dessins d’enfants.\n\nNuestra Convención: Adoptamos la notación de SageMath y Lando & Zvonkin, usando el par de permutaciones \\((\\sigma, \\rho)\\) sobre semiaristas y refiriéndonos a la estructura topológica como Ribbon Graph.",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#ejemplo-un-vértice-dos-lazos",
    "href": "capitulos/01-sistemas-rotacion.html#ejemplo-un-vértice-dos-lazos",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Recordando la construcción del ejemplo anterior:\n\n\nVértices: 1\nAristas: 2\nSemiaristas: 4 (etiquetadas 1, 2, 3, 4)\n\nEs importante notar que \\(\\rho\\) está fijo por la construcción del grafo (la elección de qué pares de semiaristas forman cada arista). Por lo tanto, solo podemos variar \\(\\sigma\\).\nComo tenemos 4 semiaristas incidentes al mismo vértice, el número de posibles órdenes cíclicos es \\((4-1)! = 6\\). A continuación listamos todas las posibilidades:\n\n\\(\\sigma = (1, 2, 3, 4)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 2, 4, 3)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 3, 2, 4)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 3, 4, 2)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 4, 2, 3)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 4, 3, 2)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\nCada una de estas elecciones define un sistema de rotación válido. En las siguientes secciones veremos cómo estas permutaciones determinan la topología de la superficie resultante.",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#ejemplo-2-triángulo-k₃",
    "href": "capitulos/01-sistemas-rotacion.html#ejemplo-2-triángulo-k₃",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Consideremos el grafo completo con 3 vértices: \\(K_3\\):\n\n\n\n\nVértices: 3 (A, B, C)\nAristas: 3 (AB, BC, CA)\nSemiaristas: 6 (etiquetadas 1, 2, 3, 4, 5, 6)\n\nAsignación de semiaristas:\n\nVértice A: semiaristas 1, 6\nVértice B: semiaristas 2, 3\nVértice C: semiaristas 4, 5\n\nAristas:\n\nAB: semiaristas 1 y 2\nBC: semiaristas 3 y 4\nCA: semiaristas 5 y 6\n\nPara definir el sistema de rotación, la asignación explícita de semiaristas es necesaria para fijar \\(\\rho\\).\n\n\\(\\rho\\): Queda determinado por los pares que forman las aristas. \\[\\rho = (1, 2)(3, 4)(5, 6)\\]\n\\(\\sigma\\): En este caso, como cada vértice tiene grado 2, existe un único orden cíclico posible para las semiaristas incidentes (\\((a,b)\\) es equivalente a \\((b,a)\\)). \\[\\sigma = (1, 6)(2, 3)(4, 5)\\]\n\nEste sistema describe el encaje estándar de \\(K_3\\) en la esfera (género 0).",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#el-big-bang-combinatorio-cuántos-encajes-existen",
    "href": "capitulos/01-sistemas-rotacion.html#el-big-bang-combinatorio-cuántos-encajes-existen",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Para un grafo dado (sin vértices aislados), podemos calcular exactamente cuántos Sistemas de Rotación (que generan superficies orientables) se pueden construir. La fórmula depende enteramente de la conectividad local de los vértices.\n\n\nSi llamamos \\(N(G)\\) al número total de sistemas de rotación para un grafo \\(G\\), tenemos:\n\\[ N(G) = \\prod_{v \\in V(G)} (\\deg(v) - 1)! \\]\nDonde:\n\n\\(\\prod\\): Es el símbolo de producto (multiplicamos el resultado de cada vértice).\n\\(V(G)\\): Es el conjunto de todos los vértices del grafo.\n\\(\\deg(v)\\) (Grado): Es el número de semiaristas que llegan al vértice \\(v\\).\n\\((\\deg(v) - 1)!\\): Es el número de formas de organizar las semiaristas en un círculo (permutaciones cíclicas).\n\n\n\n\n\n\nEl grafo de un vértice y dos lazos:\n\nTenemos 1 vértice con grado \\(4\\).\nCálculo: \\((4-1)! = 6\\) sistemas.\nResultado: Coincide exactamente con la lista de \\(6\\) que vimos anteriormente.\n\nEl Triángulo (\\(K_3\\)):\n\nTenemos 3 vértices, cada uno con grado \\(2\\).\nCálculo: \\((2-1)! \\times (2-1)! \\times (2-1)! = 1\\) sistema.\nResultado: Por eso el \\(K_3\\) es “rígido”; solo puede encajarse de una forma (en la esfera).\n\n\n\n\n\n\nA medida que añadimos vértices y cada uno se conecta con todos los demás, el número de universos topológicos posibles crece de forma estrepitosa:\n\n\n\nGrafo\nVértices\nGrado\nFórmula\nTotal de Sistemas\n\n\n\n\n\\(K_3\\) (Triángulo)\n3\n2\n\\((1!)^3\\)\n1\n\n\n\\(K_4\\) (Tetraedro)\n4\n3\n\\((2!)^4\\)\n16\n\n\n\\(K_5\\) (Pentáculo)\n5\n4\n\\((3!)^5\\)\n7,776\n\n\n\\(K_6\\)\n6\n5\n\\((4!)^6\\)\n191,102,976\n\n\n\\(K_7\\)\n7\n6\n\\((5!)^7\\)\n358,318,080,000,000\n\n\n\n\nNota para la reflexión: ¡Para un simple grafo de 7 vértices, existen más de 358 billones de formas de encajarlo en superficies! La gran mayoría de estas formas resultarán en superficies con muchísimos “agujeros” (género alto), y solo unas pocas tendrán género mínimo (\\(K_7\\) no es planar).",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#interpretación-geométrica",
    "href": "capitulos/01-sistemas-rotacion.html#interpretación-geométrica",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "El sistema de rotación \\((\\sigma, \\rho)\\) codifica:\n\nEl grafo subyacente\n\nLos ciclos de \\(\\sigma\\) determinan los vértices\nLos 2-ciclos de \\(\\rho\\) determinan las aristas\nPodemos reconstruir \\(G\\) desde \\((\\sigma, \\rho)\\)\n\nEl orden cíclico local\n\nCada ciclo de \\(\\sigma\\) indica cómo se ordenan las semiaristas alrededor de un vértice\nEste orden respeta la orientación de la superficie",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#construcción-en-sagemath",
    "href": "capitulos/01-sistemas-rotacion.html#construcción-en-sagemath",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "SageMath implementa ribbon graphs directamente desde sistemas de rotación:\nPuedes verificar estos cálculos rápidamente en línea usando SageMathCell.\n\n\nConstruyamos el sistema de rotación más estándar para este grafo:\n# Usamos PermutationGroupElement directamente\nsigma = PermutationGroupElement(\"(1,2,3,4)\")\nrho = PermutationGroupElement(\"(1,2)(3,4)\")\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Objeto creado: {R}\")\nprint(f\"Tipo: {type(R).__name__}\")\n\n# Recuperar las permutaciones almacenadas\nprint(f\"\\nPermutaciones:\")\nprint(f\"  σ = {R.sigma()}\")\nprint(f\"  ρ = {R.rho()}\")\n\n# Contar elementos del grafo\nnum_semiaristas = len(R.sigma().domain())\nnum_vertices = len(R.sigma().cycle_tuples(singletons=True))\nnum_aristas = len(R.rho().cycle_tuples())\n\nprint(f\"\\nEstructura del grafo:\")\nprint(f\"  Semiaristas: {num_semiaristas}\")\nprint(f\"  Vértices: {num_vertices}\")\nprint(f\"  Aristas: {num_aristas}\")\n\n\n\nPodemos etiquetar las semiaristas con cualquier numeración, no necesariamente 1,2,3,…\n# K₃ con numeración consecutiva empezando desde 10\nsigma_k3 = PermutationGroupElement(\"(10,15)(11,12)(13,14)\")\nrho_k3 = PermutationGroupElement(\"(10,11)(12,13)(14,15)\")\nR_k3 = RibbonGraph(sigma_k3, rho_k3)\n\nprint(f\"K₃ con numeración salteada:\")\nprint(f\"  σ = {R_k3.sigma()}\")\nprint(f\"  ρ = {R_k3.rho()}\")\nprint(f\"  Números usados: 10, 11, 12, 13, 14, 15\")\n\n# normalize() renumera del 1 al número de semiaristas\nR_norm = R_k3.normalize()\n\nprint(f\"\\nDespués de normalize():\")\nprint(f\"  σ = {R_norm.sigma()}\")\nprint(f\"  ρ = {R_norm.rho()}\")\nprint(f\"  Números usados: 1, 2, 3, 4, 5, 6\")\n\n# Verificar que la estructura se preserva\nprint(f\"\\nVértices: {len(R_k3.sigma().cycle_tuples())} → {len(R_norm.sigma().cycle_tuples())}\")\nprint(f\"Aristas: {len(R_k3.rho().cycle_tuples())} → {len(R_norm.rho().cycle_tuples())}\")\n\n\n\nPodemos calcular programáticamente cuántos sistemas de rotación existen para un grafo dado:\ndef contar_sistemas(R):\n    \"\"\"\n    Calcula N(G) = ∏(deg(v) - 1)! para un RibbonGraph\n    \"\"\"\n    grados = [len(ciclo) for ciclo in R.sigma().cycle_tuples(singletons=True)]\n    total = 1\n    for g in grados:\n        total *= factorial(g - 1)\n    return total, grados\n\n# Verificar con el Ejemplo 1: Un vértice, dos lazos\nsigma1 = PermutationGroupElement(\"(1,2,3,4)\")\nrho1 = PermutationGroupElement(\"(1,2)(3,4)\")\nR1 = RibbonGraph(sigma1, rho1)\n\ntotal1, grados1 = contar_sistemas(R1)\nprint(f\"Ejemplo 1: Un vértice, dos lazos\")\nprint(f\"  Grados de vértices: {grados1}\")\nprint(f\"  N(G) = (4-1)! = {total1}\")\n\n# Verificar con el Ejemplo 2: K₃\nsigma2 = PermutationGroupElement(\"(1,6)(2,3)(4,5)\")\nrho2 = PermutationGroupElement(\"(1,2)(3,4)(5,6)\")\nR2 = RibbonGraph(sigma2, rho2)\n\ntotal2, grados2 = contar_sistemas(R2)\nprint(f\"\\nEjemplo 2: Triángulo K₃\")\nprint(f\"  Grados de vértices: {grados2}\")\nprint(f\"  N(G) = (1!)³ = {total2}\")",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#ejercicios",
    "href": "capitulos/01-sistemas-rotacion.html#ejercicios",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "TipEjercicio 1\n\n\n\nConsidera un grafo con un vértice y tres self-loops (tres aristas que comienzan y terminan en el mismo vértice).\n\n¿Cuántas semiaristas tiene este sistema?\n¿Cuántos sistemas de rotación posibles existen para este grafo? Usa la fórmula manualmente.\nEscribe en Sage un sistema de rotación \\((\\sigma, \\rho)\\) para este grafo usando PermutationGroupElement.\nUsa la función contar_sistemas(R) del ejemplo para verificar tu cálculo del inciso (b).\n\n\n\n\n\n\n\n\n\nTipEjercicio 2\n\n\n\nExperimentando con numeración y normalización:\n\nCrea un RibbonGraph usando numeración salteada (por ejemplo, usando solo números pares o múltiplos de 5).\nUsa el método .normalize() para obtener la versión canónica.\nVerifica que el número de semiaristas se preserva usando len(R.sigma().domain()).\n¿Qué propiedades del grafo cambian con normalize() y cuáles se preservan?",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#referencias",
    "href": "capitulos/01-sistemas-rotacion.html#referencias",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "[GGD2011] E. Girondo, G. Gonzalez-Diez, Introduction to Compact Riemann surfaces and Dessins d’enfant, London Mathematical Society, Student Text 79, 2011.\n[LZ2004] S. Lando, A. Zvonkine, Graphs on Surfaces and Their Applications, Springer-Verlag, 2004.\n[Edmonds1960] J. Edmonds, A Combinatorial Representation for Polyhedral Surfaces, Notices Amer. Math. Soc. 7, 1960. (Tesis disponible en UMD)\n[Youngs1963] J. W. T. Youngs, The Genus of a Graph, Journal of Mathematics and Mechanics, Vol. 12, No. 2, 1963. JSTOR\n\n\n\n\n\n\n\nImportanteCambio de Perspectiva: El Mapa es el Territorio\n\n\n\nHasta ahora, hemos hablado de “poner un grafo sobre una superficie”. Sin embargo, en la práctica computacional (y en SageMath), el grafo abstracto y la superficie no existen antes de definir las permutaciones.\nEs fundamental entender que el par combinatorio \\((\\sigma, \\rho)\\) ES el objeto.\nNo “buscamos” un encaje para un sistema de rotación. El sistema de rotación construye su propia superficie única e inevitable.\nEn la siguiente sección, veremos cómo estas permutaciones “tejen” la superficie automáticamente, sin necesidad de dibujarla.\n\n\n\nPublicado el 06 de febrero de 2026",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/04-teoremas.html",
    "href": "capitulos/04-teoremas.html",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "El Teorema de Heffter-Edmonds es la piedra angular de la teoría de grafos topológicos. No solo establece que todo sistema de rotación genera una superficie, sino que la correspondencia es estructuralmente perfecta: clasifica los encajes salvo equivalencia.\n\n\nAntes de enunciar el teorema en su forma fuerte, debemos precisar qué significa que dos sistemas sean “el mismo” desde el punto de vista combinatorio.\nDos sistemas de rotación \\((\\sigma_1, \\rho_1)\\) sobre un conjunto de semiaristas \\(D_1\\) y \\((\\sigma_2, \\rho_2)\\) sobre \\(D_2\\) son equivalentes (o isomorfos) si existe una biyección \\(\\tau: D_1 \\to D_2\\) tal que:\n\\[\n\\sigma_2 = \\tau \\sigma_1 \\tau^{-1} \\quad \\text{y} \\quad \\rho_2 = \\tau \\rho_1 \\tau^{-1}\n\\]\nEsta biyección \\(\\tau\\) preserva toda la estructura combinatoria: mapea vértices a vértices (ciclos de \\(\\sigma\\)) y aristas a aristas (ciclos de \\(\\rho\\)).\n\n\n\nGeométricamente, dos encajes de grafos \\(G_1 \\subset S_1\\) y \\(G_2 \\subset S_2\\) son equivalentes si existe un homeomorfismo que preserva la orientación \\(h: S_1 \\to S_2\\) tal que \\(h(G_1) = G_2\\). Esto implica que \\(h\\) induce un isomorfismo entre los grafos abstractos subyacentes.\n\n\n\n\n\n\n\n\n\nImportanteTeorema Fuerte de Heffter-Edmonds\n\n\n\nExiste una correspondencia biunívoca natural entre:\n\nClases de equivalencia de sistemas de rotación \\((\\sigma, \\rho)\\).\nClases de equivalencia de encajes celulares de grafos en superficies orientables.\n\nEsto significa que el álgebra de las permutaciones \\((\\sigma, \\rho)\\) captura toda la información topológica del encaje, sin pérdida ni ambigüedad.\n\n\n\n\n\nEste resultado transforma problemas topológicos en problemas puramente combinatorios:\n\nHeffter (1891): Primeros trabajos sobre encajes de grafos en superficies\nEdmonds (1960): Formulación moderna en términos de permutaciones\nTambién conocido como el teorema de representación de superficies\n\n\n\n\n\n\n\n\n\n\n\n\nImportanteProposición fundamental\n\n\n\nExiste una correspondencia biunívoca natural entre:\n\nSistemas de rotación \\((\\sigma, \\rho)\\)\nRibbon graphs\nEncajes celulares en superficies orientables\n\nEstas tres formas de describir el mismo objeto matemático son completamente equivalentes.\n\n\n\n\nLa construcción del trazado de caras (sección 2) proporciona la transformación explícita:\n\\[\n(\\sigma, \\rho) \\quad \\xrightarrow{\\text{engrosamiento}} \\quad \\text{Ribbon graph}\n\\]\n\n\n\nDado un ribbon graph (superficie con grafo encajado):\n\nIdentificar las semiaristas en el borde de cada vértice\nLeer el orden cíclico \\(\\to\\) permutación \\(\\sigma\\)\nEmparejar semiaristas de cada arista \\(\\to\\) permutación \\(\\rho\\)\n\n\n\n\n\n\nComo hemos visto en las secciones anteriores, el sistema \\((\\sigma, \\rho)\\) determina completamente el grafo (\\(V, E\\)) y la topología de la superficie (\\(F, g\\)). Sin embargo, hay una propiedad topológica fundamental que está implícita en esta construcción: la orientabilidad.\n\n\nTodo sistema de rotación \\((\\sigma, \\rho)\\) genera necesariamente una superficie orientable. Esto no es una coincidencia, sino una consecuencia de la definición misma.\n\nOrientación Local: La permutación \\(\\sigma\\) define un orden cíclico estricto en cada vértice. Geométricamente, esto equivale a elegir una dirección de “giro” (por ejemplo, antihorario) en el disco que representa cada vértice.\nConsistencia Global: Al conectar estos vértices mediante aristas (las bandas o ribbons), asumimos implícitamente que no hay torsiones. Conectamos el borde del disco \\(u\\) con el borde del disco \\(v\\) sin voltear la cinta.\nDos Lados: Como resultado, la superficie resultante tiene dos lados bien definidos (“arriba” y “abajo”). Es posible pintar un lado de rojo y otro de azul sin que los colores se mezclen, lo cual es la definición intuitiva de orientabilidad.\n\n\n\n\nPara representar superficies no orientables (como la Banda de Möbius o la Botella de Klein), el modelo de permutaciones \\((\\sigma, \\rho)\\) es insuficiente. Se requiere información adicional:\n\nSistemas de rotación con signo: Se añade una función de firma \\(\\lambda: E \\to \\{+1, -1\\}\\).\nSi una arista tiene signo \\(-1\\), la cinta se “tuerce” al conectar los vértices, invirtiendo la orientación local.\n\nDado que nuestros sistemas de rotación no incluyen esta firma (son “puros”), estamos restringidos exclusivamente al universo de las superficies orientables.\n\n\n\n\n\nUn encaje celular de un grafo en una superficie es equivalente a un complejo celular 2-dimensional donde:\n\n0-celdas = vértices del grafo\n1-celdas = aristas del grafo\n2-celdas = caras del encaje\n\nEl sistema de rotación \\((\\sigma, \\rho)\\) codifica completamente la información combinatoria de este complejo celular.\n\n\n\n\n\n\n# ¿Cuál es el género mínimo en el que K₃ se puede encajar?\nR = RibbonGraph('(1,6)(2,3)(4,5)', '(1,2)(3,4)(5,6)')\nprint(f\"Género de este encaje: {R.genus()}\")\n\n# K₃ es planar, por lo que g = 0 es posible\n\n\n\n# Queremos género 1 (toro)\n# Usamos la fórmula: chi = 2 - 2g - b\n# Para g=1, b=0: chi = 0\n# Necesitamos V - E + F = 0\n\n# Ejemplo: V=1, E=2, F=1\nR = RibbonGraph('(1,2,3,4)', '(1,2)(3,4)')\nprint(f\"χ = {R.num_vertices() - R.num_edges() + len(list(R.faces()))}\")\nprint(f\"g = {R.genus()}\")\n\n\n\n\n\n\n\n\n\n\n\nTipEjercicio 1: Teorema de Heffter-Edmonds\n\n\n\nConsidera el sistema \\(\\sigma = (1,2,3)\\), \\(\\rho = (1,2)(3)\\).\n\n¿Es válido este sistema? (¿\\(\\rho\\) tiene solo 2-ciclos?)\nSi no es válido, corrige \\(\\rho\\)\nCalcula los invariantes del sistema corregido\n\n\n\n\n\n\n\n\n\nTipEjercicio 2: Superficies con frontera\n\n\n\nEncuentra sistemas de rotación que produzcan:\n\nUn anillo (cilindro topológico: g=0, b=2)\nUn toro con un agujero (g=1, b=1)\nUn bitoro con dos agujeros (g=2, b=2)\n\n\n\n\n\n\n\n\nTeorema de Heffter-Edmonds: establece la equivalencia entre sistemas de rotación y encajes celulares\nEquivalencia: sistemas de rotación ↔︎ ribbon graphs ↔︎ encajes celulares\nPropiedades: determinación del grafo, cálculo de invariantes, orientabilidad\nClasificación: superficies orientables compactas caracterizadas por \\((g, b)\\)\n\nEn la siguiente sección veremos una galería de ejemplos clásicos con análisis completo de sus propiedades."
  },
  {
    "objectID": "capitulos/04-teoremas.html#el-teorema-de-heffter-edmonds",
    "href": "capitulos/04-teoremas.html#el-teorema-de-heffter-edmonds",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "El Teorema de Heffter-Edmonds es la piedra angular de la teoría de grafos topológicos. No solo establece que todo sistema de rotación genera una superficie, sino que la correspondencia es estructuralmente perfecta: clasifica los encajes salvo equivalencia.\n\n\nAntes de enunciar el teorema en su forma fuerte, debemos precisar qué significa que dos sistemas sean “el mismo” desde el punto de vista combinatorio.\nDos sistemas de rotación \\((\\sigma_1, \\rho_1)\\) sobre un conjunto de semiaristas \\(D_1\\) y \\((\\sigma_2, \\rho_2)\\) sobre \\(D_2\\) son equivalentes (o isomorfos) si existe una biyección \\(\\tau: D_1 \\to D_2\\) tal que:\n\\[\n\\sigma_2 = \\tau \\sigma_1 \\tau^{-1} \\quad \\text{y} \\quad \\rho_2 = \\tau \\rho_1 \\tau^{-1}\n\\]\nEsta biyección \\(\\tau\\) preserva toda la estructura combinatoria: mapea vértices a vértices (ciclos de \\(\\sigma\\)) y aristas a aristas (ciclos de \\(\\rho\\)).\n\n\n\nGeométricamente, dos encajes de grafos \\(G_1 \\subset S_1\\) y \\(G_2 \\subset S_2\\) son equivalentes si existe un homeomorfismo que preserva la orientación \\(h: S_1 \\to S_2\\) tal que \\(h(G_1) = G_2\\). Esto implica que \\(h\\) induce un isomorfismo entre los grafos abstractos subyacentes.\n\n\n\n\n\n\n\n\n\nImportanteTeorema Fuerte de Heffter-Edmonds\n\n\n\nExiste una correspondencia biunívoca natural entre:\n\nClases de equivalencia de sistemas de rotación \\((\\sigma, \\rho)\\).\nClases de equivalencia de encajes celulares de grafos en superficies orientables.\n\nEsto significa que el álgebra de las permutaciones \\((\\sigma, \\rho)\\) captura toda la información topológica del encaje, sin pérdida ni ambigüedad.\n\n\n\n\n\nEste resultado transforma problemas topológicos en problemas puramente combinatorios:\n\nHeffter (1891): Primeros trabajos sobre encajes de grafos en superficies\nEdmonds (1960): Formulación moderna en términos de permutaciones\nTambién conocido como el teorema de representación de superficies"
  },
  {
    "objectID": "capitulos/04-teoremas.html#equivalencia-con-ribbon-graphs",
    "href": "capitulos/04-teoremas.html#equivalencia-con-ribbon-graphs",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "ImportanteProposición fundamental\n\n\n\nExiste una correspondencia biunívoca natural entre:\n\nSistemas de rotación \\((\\sigma, \\rho)\\)\nRibbon graphs\nEncajes celulares en superficies orientables\n\nEstas tres formas de describir el mismo objeto matemático son completamente equivalentes.\n\n\n\n\nLa construcción del trazado de caras (sección 2) proporciona la transformación explícita:\n\\[\n(\\sigma, \\rho) \\quad \\xrightarrow{\\text{engrosamiento}} \\quad \\text{Ribbon graph}\n\\]\n\n\n\nDado un ribbon graph (superficie con grafo encajado):\n\nIdentificar las semiaristas en el borde de cada vértice\nLeer el orden cíclico \\(\\to\\) permutación \\(\\sigma\\)\nEmparejar semiaristas de cada arista \\(\\to\\) permutación \\(\\rho\\)"
  },
  {
    "objectID": "capitulos/04-teoremas.html#propiedades-la-cuestión-de-la-orientabilidad",
    "href": "capitulos/04-teoremas.html#propiedades-la-cuestión-de-la-orientabilidad",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "Como hemos visto en las secciones anteriores, el sistema \\((\\sigma, \\rho)\\) determina completamente el grafo (\\(V, E\\)) y la topología de la superficie (\\(F, g\\)). Sin embargo, hay una propiedad topológica fundamental que está implícita en esta construcción: la orientabilidad.\n\n\nTodo sistema de rotación \\((\\sigma, \\rho)\\) genera necesariamente una superficie orientable. Esto no es una coincidencia, sino una consecuencia de la definición misma.\n\nOrientación Local: La permutación \\(\\sigma\\) define un orden cíclico estricto en cada vértice. Geométricamente, esto equivale a elegir una dirección de “giro” (por ejemplo, antihorario) en el disco que representa cada vértice.\nConsistencia Global: Al conectar estos vértices mediante aristas (las bandas o ribbons), asumimos implícitamente que no hay torsiones. Conectamos el borde del disco \\(u\\) con el borde del disco \\(v\\) sin voltear la cinta.\nDos Lados: Como resultado, la superficie resultante tiene dos lados bien definidos (“arriba” y “abajo”). Es posible pintar un lado de rojo y otro de azul sin que los colores se mezclen, lo cual es la definición intuitiva de orientabilidad.\n\n\n\n\nPara representar superficies no orientables (como la Banda de Möbius o la Botella de Klein), el modelo de permutaciones \\((\\sigma, \\rho)\\) es insuficiente. Se requiere información adicional:\n\nSistemas de rotación con signo: Se añade una función de firma \\(\\lambda: E \\to \\{+1, -1\\}\\).\nSi una arista tiene signo \\(-1\\), la cinta se “tuerce” al conectar los vértices, invirtiendo la orientación local.\n\nDado que nuestros sistemas de rotación no incluyen esta firma (son “puros”), estamos restringidos exclusivamente al universo de las superficies orientables."
  },
  {
    "objectID": "capitulos/04-teoremas.html#relación-con-complejos-celulares",
    "href": "capitulos/04-teoremas.html#relación-con-complejos-celulares",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "Un encaje celular de un grafo en una superficie es equivalente a un complejo celular 2-dimensional donde:\n\n0-celdas = vértices del grafo\n1-celdas = aristas del grafo\n2-celdas = caras del encaje\n\nEl sistema de rotación \\((\\sigma, \\rho)\\) codifica completamente la información combinatoria de este complejo celular."
  },
  {
    "objectID": "capitulos/04-teoremas.html#ejemplos-de-aplicación",
    "href": "capitulos/04-teoremas.html#ejemplos-de-aplicación",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "# ¿Cuál es el género mínimo en el que K₃ se puede encajar?\nR = RibbonGraph('(1,6)(2,3)(4,5)', '(1,2)(3,4)(5,6)')\nprint(f\"Género de este encaje: {R.genus()}\")\n\n# K₃ es planar, por lo que g = 0 es posible\n\n\n\n# Queremos género 1 (toro)\n# Usamos la fórmula: chi = 2 - 2g - b\n# Para g=1, b=0: chi = 0\n# Necesitamos V - E + F = 0\n\n# Ejemplo: V=1, E=2, F=1\nR = RibbonGraph('(1,2,3,4)', '(1,2)(3,4)')\nprint(f\"χ = {R.num_vertices() - R.num_edges() + len(list(R.faces()))}\")\nprint(f\"g = {R.genus()}\")"
  },
  {
    "objectID": "capitulos/04-teoremas.html#ejercicios",
    "href": "capitulos/04-teoremas.html#ejercicios",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "TipEjercicio 1: Teorema de Heffter-Edmonds\n\n\n\nConsidera el sistema \\(\\sigma = (1,2,3)\\), \\(\\rho = (1,2)(3)\\).\n\n¿Es válido este sistema? (¿\\(\\rho\\) tiene solo 2-ciclos?)\nSi no es válido, corrige \\(\\rho\\)\nCalcula los invariantes del sistema corregido\n\n\n\n\n\n\n\n\n\nTipEjercicio 2: Superficies con frontera\n\n\n\nEncuentra sistemas de rotación que produzcan:\n\nUn anillo (cilindro topológico: g=0, b=2)\nUn toro con un agujero (g=1, b=1)\nUn bitoro con dos agujeros (g=2, b=2)"
  },
  {
    "objectID": "capitulos/04-teoremas.html#resumen",
    "href": "capitulos/04-teoremas.html#resumen",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "Teorema de Heffter-Edmonds: establece la equivalencia entre sistemas de rotación y encajes celulares\nEquivalencia: sistemas de rotación ↔︎ ribbon graphs ↔︎ encajes celulares\nPropiedades: determinación del grafo, cálculo de invariantes, orientabilidad\nClasificación: superficies orientables compactas caracterizadas por \\((g, b)\\)\n\nEn la siguiente sección veremos una galería de ejemplos clásicos con análisis completo de sus propiedades."
  },
  {
    "objectID": "capitulos/03-invariantes.html",
    "href": "capitulos/03-invariantes.html",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Esta sección es práctica: aprenderemos a usar SageMath para calcular los invariantes topológicos que clasifican la superficie cerrada donde se aloja el grafo:",
    "crumbs": [
      "Inicio",
      "3. Invariantes topológicos"
    ]
  },
  {
    "objectID": "capitulos/03-invariantes.html#conteo-de-elementos-v-e-f",
    "href": "capitulos/03-invariantes.html#conteo-de-elementos-v-e-f",
    "title": "3. Invariantes Topológicos",
    "section": "1. Conteo de Elementos (\\(V, E, F\\))",
    "text": "1. Conteo de Elementos (\\(V, E, F\\))\nRecordemos que en un mapa combinatorio:\n\n\\(V\\): Ciclos de \\(\\sigma\\)\n\\(E\\): Ciclos de \\(\\rho\\) (o \\(|D|/2\\))\n\\(F\\): Ciclos de \\(\\varphi = \\rho \\sigma\\)\n\n\n\n\n\n\n\nNotaInterpretación: ¿Caras o Fronteras?\n\n\n\nEn un ribbon graph, los ciclos de la permutación \\(\\varphi\\) describen las componentes de frontera de la superficie con borde obtenida al engrosar el grafo. Si se tapan esas fronteras con discos, esas mismas componentes pasan a ser las caras del encaje en la superficie cerrada.\nPor ello, SageMath cuenta estos ciclos con number_boundaries(). En este curso, \\(b\\) denota el número de componentes de frontera y coincide con \\(F\\) cuando interpretamos el mapa sobre la superficie cerrada (\\(F=b\\)).\n\n\nSageMath nos permite extraer estos valores directamente del objeto RibbonGraph.\n\n\n\n\n\n\nTipVerificación con SageMath\n\n\n\nPuedes probar estos cálculos en línea usando SageMathCell.\n# Ejemplo: Un toro (1 vértice, 2 lazos)\nsigma = PermutationGroupElement('(1,3,2,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# 1. Extracción de elementos básicos\n# V = número de ciclos de sigma\n# E = número de ciclos de rho (equivalente a |D|/2)\n# F = número de ciclos de φ = ρσ (caras del mapa combinatorio)\nphi = rho * sigma  # φ = ρσ (recuerda: multiplicación de izquierda a derecha en Sage)\n\nV = len(sigma.cycle_tuples(singletons=True))\nE = len(rho.cycle_tuples(singletons=True))\nF = len(phi.cycle_tuples(singletons=True))\n\nprint(f\"Vértices (V): {V}\")\nprint(f\"Aristas  (E): {E}\")\nprint(f\"Caras    (F): {F}\")\nprint(f\"φ = ρσ: {phi}\")\nprint(f\"Ciclos de φ: {phi.cycle_tuples(singletons=True)}\")",
    "crumbs": [
      "Inicio",
      "3. Invariantes topológicos"
    ]
  },
  {
    "objectID": "capitulos/03-invariantes.html#la-característica-de-euler-chi",
    "href": "capitulos/03-invariantes.html#la-característica-de-euler-chi",
    "title": "3. Invariantes Topológicos",
    "section": "2. La Característica de Euler (\\(\\chi\\))",
    "text": "2. La Característica de Euler (\\(\\chi\\))\nLa característica de Euler es el invariante más fundamental. Se define combinatoriamente como:\n\\[ \\chi = V - E + F \\]\nEsta es la característica de Euler de la superficie cerrada obtenida al pegar discos en todas las fronteras del grafo.\nchi = V - E + F\nprint(f\"Característica de Euler (χ): {chi}\")\n# Para el toro: 1 - 2 + 1 = 0",
    "crumbs": [
      "Inicio",
      "3. Invariantes topológicos"
    ]
  },
  {
    "objectID": "capitulos/03-invariantes.html#el-género-g-y-la-frontera-b",
    "href": "capitulos/03-invariantes.html#el-género-g-y-la-frontera-b",
    "title": "3. Invariantes Topológicos",
    "section": "3. El Género (\\(g\\)) y la Frontera (\\(b\\))",
    "text": "3. El Género (\\(g\\)) y la Frontera (\\(b\\))\nEl género \\(g\\) se calcula siempre a partir de la superficie cerrada asociada. La cuenta es la misma, solo cambia la interpretación de \\(F\\) y \\(b\\):\n\nEn el ribbon graph, los ciclos de \\(\\varphi\\) son fronteras, de modo que \\(b\\) es el número de componentes de frontera.\nAl tapar cada frontera con un disco, esas mismas componentes pasan a ser las caras \\(F\\) de la superficie cerrada.\n\nPor lo tanto, en la superficie cerrada se cumple:\n\\[ \\chi = V - E + F = V - E + b \\quad \\Rightarrow \\quad g = \\frac{2 - (V - E + b)}{2} \\]\nSageMath detecta automáticamente el número de componentes de frontera (\\(b\\)), y ese mismo valor coincide con \\(F\\) cuando se interpreta el mapa en la superficie cerrada.\n# 2. Invariantes derivados\ng = R.genus()              # Género de la superficie\n\nprint(f\"Género (g): {g}\")\n\n# Verificación manual de la fórmula\nchi = V - E + F\ng_calc = (2 - chi) // 2\nprint(f\"\\nVerificación de Euler:\")\nprint(f\"  χ = V - E + F = {V} - {E} + {F} = {chi}\")\nprint(f\"  χ = 2 - 2g = 2 - 2({g}) = {2 - 2*g}\")\nprint(f\"  ✓ Fórmula consistente\" if chi == 2 - 2*g else f\"  ✗ Error en cálculo\")\n\n\n\n\n\n\nNotaNota sobre number_boundaries()\n\n\n\nEn la implementación de RibbonGraph de SageMath, el método number_boundaries() devuelve el número de caras del mapa. Si interpretamos el mapa como una superficie con borde (antes de pegar los discos de las caras), estas caras son precisamente los bordes. Si lo interpretamos como superficie cerrada (después de pegar), son las caras \\(F\\). La fórmula funciona consistentemente.",
    "crumbs": [
      "Inicio",
      "3. Invariantes topológicos"
    ]
  },
  {
    "objectID": "capitulos/03-invariantes.html#automatización-una-función-de-análisis",
    "href": "capitulos/03-invariantes.html#automatización-una-función-de-análisis",
    "title": "3. Invariantes Topológicos",
    "section": "4. Automatización: Una función de análisis",
    "text": "4. Automatización: Una función de análisis\nComo ejercicio de programación en SageMath, vamos a encapsular todo esto en una función reutilizable que nos dé un “reporte topológico” de cualquier sistema de rotación.\nPuedes probar la siguiente función en SageMathCell:\ndef analizar_topologia(sigma, rho):\n    \"\"\"\n    Imprime un reporte de los elementos del grafo y sus invariantes básicos.\n    \"\"\"\n    # Convertir strings a permutaciones si es necesario\n    if isinstance(sigma, str): sigma = PermutationGroupElement(sigma)\n    if isinstance(rho, str): rho = PermutationGroupElement(rho)\n\n    R = RibbonGraph(sigma, rho)\n    \n    # Contar elementos\n    phi = rho * sigma  # φ = ρσ\n    V = len(sigma.cycle_tuples(singletons=True))  # Número de ciclos de sigma\n    E = len(rho.cycle_tuples(singletons=True))    # Número de ciclos de rho\n    F = len(phi.cycle_tuples(singletons=True))    # Número de ciclos de φ (caras)\n    \n    # Calcular invariantes\n    chi = V - E + F\n    b = R.number_boundaries()                      # Componentes de frontera\n    g = R.genus()                                   # Género\n    \n    print(f\"{'='*55}\")\n    print(f\"Análisis del Mapa Combinatorio\")\n    print(f\"{'='*55}\")\n    print(f\"Permutaciones:\")\n    print(f\"  σ = {sigma}\")\n    print(f\"  ρ = {rho}\")\n    print(f\"  φ = ρσ = {phi}\")\n    print(f\"{'-'*55}\")\n    print(f\"Elementos:\")\n    print(f\"  V (ciclos de σ) = {V}\")\n    print(f\"  E (ciclos de ρ) = {E}\")\n    print(f\"  F (ciclos de φ) = {F}\")\n    print(f\"{'-'*55}\")\n    print(f\"Invariantes Topológicos:\")\n    print(f\"  Euler: χ = {V} - {E} + {F} = {chi}\")\n    print(f\"  Frontera: b = {b}\")\n    print(f\"  Género: g = {g}\")\n    print(f\"{'-'*55}\")\n    \n    # Interpretación\n    if g == 0:\n        nombre = \"Esfera\"\n    elif g == 1:\n        nombre = \"Toro\"\n    else:\n        nombre = f\"Género {g}\"\n    \n    if b &gt; 0:\n        nombre += f\" (grafo encajado con {F} cara{'s' if F &gt; 1 else ''})\"\n    \n    print(f\"  &gt;&gt; Homeomorfo a: {nombre}\")\n    print(f\"{'='*55}\")\n\n# Probamos con el ejemplo del capítulo anterior (Toro con 1 borde)\nanalizar_topologia('(1,3,2,4)', '(1,2)(3,4)')\n\nprint(\"\\n\")\n\n# Probamos con K3 en la esfera (sin borde)\nanalizar_topologia('(1,6)(2,3)(4,5)', '(1,2)(3,4)(5,6)')",
    "crumbs": [
      "Inicio",
      "3. Invariantes topológicos"
    ]
  },
  {
    "objectID": "capitulos/03-invariantes.html#galería-de-ejemplos",
    "href": "capitulos/03-invariantes.html#galería-de-ejemplos",
    "title": "3. Invariantes Topológicos",
    "section": "5. Galería de Ejemplos",
    "text": "5. Galería de Ejemplos\nVeamos cómo se comportan los invariantes en distintos casos.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\sigma\\)\n\\(\\rho\\)\n\\(V\\)\n\\(E\\)\n\\(F\\)\n\\(\\chi\\)\n\\(g\\)\nSuperficie\n\n\n\n\n\\((1,6)(2,3)(4,5)\\)\n\\((1,2)(3,4)(5,6)\\)\n\\(3\\)\n\\(3\\)\n\\(2\\)\n\\(2\\)\n\\(0\\)\nEsfera\n\n\n\\((1,3,2,4)\\)\n\\((1,2)(3,4)\\)\n\\(1\\)\n\\(2\\)\n\\(1\\)\n\\(0\\)\n\\(1\\)\nToro\n\n\n\\((1,2)\\)\n\\((1,2)\\)\n\\(1\\)\n\\(1\\)\n\\(2\\)\n\\(2\\)\n\\(0\\)\nEsfera\n\n\n\\((1,3,2,4,5,7,6,8)\\)\n\\((1,2)(3,4)(5,6)(7,8)\\)\n\\(1\\)\n\\(4\\)\n\\(1\\)\n\\(-2\\)\n\\(2\\)\nSup. \\(g=2\\)",
    "crumbs": [
      "Inicio",
      "3. Invariantes topológicos"
    ]
  },
  {
    "objectID": "capitulos/03-invariantes.html#ejercicios",
    "href": "capitulos/03-invariantes.html#ejercicios",
    "title": "3. Invariantes Topológicos",
    "section": "Ejercicios",
    "text": "Ejercicios\n\n\n\n\n\n\nTipEjercicio 1: Diseñador de Superficies\n\n\n\nUsa la función analizar_topologia para encontrar un sistema de rotación que genere una superficie de género 2 (Bitoro).\nPista: Necesitarás al menos 4 aristas (8 semiaristas) para tener suficiente “material” topológico. Intenta modificar \\(\\sigma\\) en un bouquet de 4 lazos.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Grafos Completos\n\n\n\nInvestiga el género de los grafos completos \\(K_n\\).\n\nVerifica que \\(K_3\\) tiene género 0.\nConstruye un sistema de rotación para \\(K_4\\) y determina el género de la superficie resultante. ¿Es posible obtener un encaje en la esfera (\\(g=0\\))?\n¿Cuál es el género mínimo para \\(K_5\\)?\n\n\n\n\nPublicado el 09 de febrero de 2026",
    "crumbs": [
      "Inicio",
      "3. Invariantes topológicos"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "",
    "text": "Autor: José Luis León Medina",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#sobre-este-proyecto",
    "href": "index.html#sobre-este-proyecto",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "Sobre este proyecto",
    "text": "Sobre este proyecto\nLos sistemas de rotación son pares de permutaciones \\((\\sigma, \\rho)\\) que codifican completamente un encaje celular de un grafo en una superficie orientable. Este proyecto explora la correspondencia biunívoca entre sistemas de rotación y ribbon graphs, establecida por el Teorema de Heffter-Edmonds.\n\nIdea principal\nUn sistema de rotación \\((\\sigma, \\rho)\\) contiene toda la información necesaria para:\n\nReconstruir el grafo subyacente (vértices y aristas)\nDeterminar el orden cíclico de semiaristas alrededor de cada vértice\nCalcular las caras mediante la permutación \\(\\varphi = \\rho\\sigma\\)\nObtener invariantes topológicos: género, característica de Euler, fronteras\nConstruir la superficie completa mediante engrosamiento (thickening)\n\nResultado fundamental: Álgebra de permutaciones ↔︎ Topología de superficies",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#contenido",
    "href": "index.html#contenido",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "Contenido",
    "text": "Contenido\n\n1. Sistemas de Rotación\nIntroducción a los sistemas de rotación como modelo combinatorio de grafos encajados.\n\nDefinición mediante permutaciones \\(\\sigma\\) y \\(\\rho\\)\nSemiaristas (darts) y orden cíclico\nEjemplos básicos con código SageMath\nConstrucción en Sage: RibbonGraph(sigma, rho)\n\n\n\n2. Mapas Combinatorios\nDe la intuición geométrica a la formalización algebraica.\n\nAxiomática de Tutte: definición formal de mapa combinatorio\nTeorema de Realización Topológica\nAlgoritmo de trazado de caras (\\(\\varphi = \\rho\\sigma\\))\nUnicidad del encaje y el género como consecuencia\n\n\n\n3. Invariantes Topológicos\nCálculo computacional con SageMath.\n\nAutomatización del cálculo de \\(V, E, F\\)\nCaracterística de Euler y Género\nFunción de análisis topológico (analizar_topologia)\nExperimentación con grafos completos y superficies de género alto",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#herramientas",
    "href": "index.html#herramientas",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "Herramientas",
    "text": "Herramientas\nEste proyecto utiliza:\n\nSageMath 10.7 - Cálculos con RibbonGraph, PermutationGroupElement\nPython 3.13 - Scripts de análisis y visualización\nQuarto - Documentación interactiva con bloques de código ejecutables",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#referencias",
    "href": "index.html#referencias",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "Referencias",
    "text": "Referencias\n\nGross, J. L., & Tucker, T. W. (1987). Topological Graph Theory\nLando, S. K., & Zvonkin, A. K. (2004). Graphs on Surfaces\nEdmonds, J. (1960). A combinatorial representation for polyhedral surfaces\nSageMath - Ribbon Graphs Documentation\n\n\n\n2026",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "capitulos/02-mapas-combinatorios.html",
    "href": "capitulos/02-mapas-combinatorios.html",
    "title": "2. Mapas Combinatorios",
    "section": "",
    "text": "En la sección anterior definimos el sistema de rotación \\((\\sigma, \\rho)\\). Es frecuente interpretar estas permutaciones como simples instrucciones para dibujar un grafo preexistente; sin embargo, esa interpretación es parcial.\nEn la topología combinatoria (y en el modelo de Mapas de Tutte), el par \\((\\sigma, \\rho)\\) contiene toda la información topológica. El encaje queda determinado de manera unívoca:",
    "crumbs": [
      "Inicio",
      "2. Mapas Combinatorios"
    ]
  },
  {
    "objectID": "capitulos/02-mapas-combinatorios.html#axiomática-de-los-mapas-combinatorios",
    "href": "capitulos/02-mapas-combinatorios.html#axiomática-de-los-mapas-combinatorios",
    "title": "2. Mapas Combinatorios",
    "section": "Axiomática de los Mapas Combinatorios",
    "text": "Axiomática de los Mapas Combinatorios\nHasta ahora nos hemos apoyado en la intuición geométrica de “dibujar grafos”. A continuación formalizamos el encaje para que no dependa de la representación gráfica, sino de reglas combinatorias precisas.\n\nLos Axiomas de Tutte\n\n\n\n\n\n\nNotaDefinición: Mapa Combinatorio (Orientado)\n\n\n\nSea \\(D\\) un conjunto finito de elementos abstractos llamados dardos (o semiaristas).\nUn Mapa Combinatorio es una terna \\(M = (D, \\sigma, \\rho)\\) que satisface los siguientes tres axiomas:\n\nAxioma de la Arista (\\(\\rho\\)): \\(\\rho\\) es una permutación de los elementos de \\(D\\) tal que \\(\\rho^2 = \\text{id}\\) y \\(\\rho(d) \\neq d\\) para todo \\(d \\in D\\).\n\nInterpretación: \\(\\rho\\) empareja los dardos; cada par define una arista.\n\nAxioma del Vértice (\\(\\sigma\\)): \\(\\sigma\\) es una permutación arbitraria de \\(D\\).\n\nInterpretación: Los ciclos de \\(\\sigma\\) agrupan los dardos; cada ciclo define un vértice.\n\nAxioma de Conectividad: El grupo de permutaciones generado por \\(\\langle \\sigma, \\rho \\rangle\\) actúa transitivamente sobre \\(D\\).\n\nInterpretación: La acción transitiva garantiza que la estructura resultante sea conexa.\n\n\n\n\n\n\n\n\n\n\nNotaNota: Sistemas de Rotación vs. Mapas Combinatorios\n\n\n\nEn la sección anterior introdujimos el concepto de sistema de rotación como la pareja \\((\\sigma, \\rho)\\). En rigor, el conjunto \\(D\\) puede deducirse de los dominios de las permutaciones \\(\\sigma\\) y \\(\\rho\\), por lo que especificarlo explícitamente es redundante.\nPor tanto, las siguientes notaciones son equivalentes y se refieren al mismo objeto matemático:\n\nSistema de rotación: \\((\\sigma, \\rho)\\)\nMapa combinatorio: \\((D, \\sigma, \\rho)\\)\n\nEn este curso usaremos ambas terminologías indistintamente, siendo conscientes de que describen exactamente la misma estructura.\n\n\n\n\nLos Elementos Derivados\nA partir de estos axiomas, definimos los elementos topológicos. En lugar de depender de la representación visual, usamos una presentación puramente combinatoria inducida por las permutaciones.\n\nVértices (\\(V\\)): El conjunto de vértices \\(V(M)\\) se define como el conjunto de órbitas (ciclos) de la permutación \\(\\sigma\\). \\[V(M) = D / \\langle \\sigma \\rangle\\]\nAristas (\\(E\\)): El conjunto de aristas \\(E(M)\\) se define como el conjunto de órbitas de la permutación \\(\\rho\\). \\[E(M) = D / \\langle \\rho \\rangle\\]\nCaras (\\(F\\)): Definimos la permutación de caras \\(\\varphi\\) como la composición \\(\\varphi = \\rho \\sigma\\) (en notación de SageMath). El conjunto de caras \\(F(M)\\) se define como el conjunto de órbitas de \\(\\varphi\\). \\[F(M) = D / \\langle \\varphi \\rangle\\]\n\n\n\nConstrucción Geométrica: La Receta de Pegado\n\n\n\n\n\n\nImportanteTeorema Fundamental de los Mapas Combinatorios\n\n\n\nPara todo mapa combinatorio \\(M = (D, \\sigma, \\rho)\\), existe una única superficie compacta orientable cerrada \\(S\\) (salvo homeomorfismo) y un grafo \\(G\\) encajado celularmente en \\(S\\), tal que:\n\nLos vértices, aristas y caras de \\(M\\) corresponden biunívocamente a los de \\(G \\subset S\\).\nEl género \\(g\\) de la superficie \\(S\\) está determinado exactamente por la característica de Euler combinatoria: \\[2 - 2g = |V(M)| - |E(M)| + |F(M)|\\]\n\n\n\nMás allá del teorema abstracto, la realización topológica es un manual de instrucciones. Dado un mapa combinatorio \\(M = (D, \\sigma, \\rho)\\), construimos la superficie física paso a paso mediante un proceso de ensamblaje.\nImagina que estamos armando un rompecabezas tridimensional:\nPaso 1: Los Vértices (Discos)\nPor cada ciclo de la permutación \\(\\sigma\\), recortamos un disco topológico (un círculo de material).\n\nSi el ciclo tiene longitud \\(k\\), marcamos \\(k\\) segmentos de arco en el borde del disco.\nEstos segmentos corresponden a los dardos.\nLos etiquetamos siguiendo el orden cíclico que nos dicta \\(\\sigma\\) (leyendo, por convención, en sentido antihorario).\n\nPaso 2: Las Aristas (Cintas)\nPor cada ciclo de la permutación \\(\\rho\\) (que siempre es de la forma \\((d_i, d_j)\\)), recortamos una cinta rectangular o banda.\n\nPegamos un extremo de la cinta en el dardo \\(d_i\\).\nPegamos el otro extremo en el dardo \\(d_j\\).\nRegla de Orientación: Pegamos la cinta sin torcerla (para superficies orientables), asegurando que la orientación de los discos de los vértices se propague suavemente a través de la arista.\n\nAl terminar el Paso 2, tenemos lo que llamamos un Ribbon Graph (o grafo de cintas): un esqueleto con agujeros.\n\n\n\nRibbon Graph determinado por el mapa combinatorio \\(D=\\{1,2,3,4,5,6\\}\\), \\(\\sigma=(1,3,2)(4,5,6)\\),\n\\(\\rho=(1,4)(2,5)(3,6)\\). La permutación \\(\\rho\\sigma\\) determina que la superficie resultante es una esfera.\n\n\nPaso 3: Las Caras (Parches)\nAhora la superficie tiene “huecos” o fronteras (las regiones negras en la figura). Para cerrarla, necesitamos pegar discos adicionales (las caras). Pero, ¿dónde pegamos estos discos? Aquí entra nuestro algoritmo de trazado.",
    "crumbs": [
      "Inicio",
      "2. Mapas Combinatorios"
    ]
  },
  {
    "objectID": "capitulos/02-mapas-combinatorios.html#el-algoritmo-de-trazado-de-caras",
    "href": "capitulos/02-mapas-combinatorios.html#el-algoritmo-de-trazado-de-caras",
    "title": "2. Mapas Combinatorios",
    "section": "El Algoritmo de Trazado de Caras",
    "text": "El Algoritmo de Trazado de Caras\nPara descubrir la forma de los huecos que debemos parchar, caminamos por el borde del Ribbon Graph que acabamos de construir.\nImagina que eres un viajero caminando por el engrosamiento del grafo. Tu regla de oro es: “Mantener siempre el grafo a tu izquierda”.\nEsto define la permutación de las caras, que en nuestra notación es la composición:\n\\[ \\varphi = \\rho \\sigma \\]\nEn la convención de SageMath para ribbon graphs, esta es la fórmula utilizada internamente por el método boundary() de la clase RibbonGraph.\n\n\n\n\n\n\nImportanteConvención de Multiplicación (SageMath)\n\n\n\nEn este curso y en SageMath, la multiplicación de permutaciones se lee de izquierda a derecha. La expresión \\(\\varphi = \\rho \\sigma\\) significa: primero aplicamos \\(\\rho\\) y luego aplicamos \\(\\sigma\\).\n\n\n\n\n\n\n\n\nNotaNota sobre Convenciones Alternativas\n\n\n\nAlgunos textos usan \\(\\varphi = \\rho \\sigma^{-1}\\), \\(\\varphi = \\sigma^{-1} \\rho\\), o \\(\\varphi = (\\sigma\\rho)^{-1}\\). Todas estas convenciones dan el mismo número de caras, pero los ciclos específicos pueden diferir. Usamos \\(\\varphi = \\rho \\sigma\\) para coincidir exactamente con la implementación de SageMath y simplificar los cálculos (no hay que invertir σ).\n\n\n\nLa Receta Geométrica: Cruzar y Girar\nPara encontrar el ciclo de una cara, partimos de un dardo \\(d\\) y repetimos:\n\nCruzar (\\(\\rho\\)): Atravesamos la cinta (arista) para llegar al vértice vecino.\n\nGeométricamente: Viajamos por el borde de la cinta hasta el otro lado.\n\nGirar (\\(\\sigma\\)): Nos movemos a lo largo del borde del vértice hasta el siguiente dardo disponible.\n\nGeométricamente: Seguimos el contorno del disco del vértice.\n\n\nEl camino se cierra cuando volvemos al dardo original. Este ciclo define el perímetro exacto donde pegaremos un disco para crear una cara.",
    "crumbs": [
      "Inicio",
      "2. Mapas Combinatorios"
    ]
  },
  {
    "objectID": "capitulos/02-mapas-combinatorios.html#la-unicidad-del-encaje",
    "href": "capitulos/02-mapas-combinatorios.html#la-unicidad-del-encaje",
    "title": "2. Mapas Combinatorios",
    "section": "La Unicidad del Encaje",
    "text": "La Unicidad del Encaje\nUna pregunta fundamental en topología es: ¿Podemos dibujar el mismo mapa combinatorio en superficies distintas?\nLa respuesta constructiva es NO.\nObserva el proceso anterior:\n\nLos discos de los vértices son fijos (dados por \\(\\sigma\\)).\nLas conexiones de las cintas son fijas (dadas por \\(\\rho\\)).\nPor tanto, los “huecos” que quedan están rígidamente determinados por la geometría del ensamblaje (\\(\\varphi = \\rho \\sigma\\)).\n\nAl pegar los discos en los huecos (Paso 3), cerramos la superficie. No hay libertad de elección; el mapa combinatorio es el plano de construcción de la superficie.\n\n\n\n\n\n\nNotaConclusión Topológica\n\n\n\nEl género \\(g\\) de la superficie resultante no es una propiedad que “elegimos”, sino una consecuencia inevitable de las permutaciones. Está forzado por la fórmula de Euler: \\[2 - 2g = |Ciclos(\\sigma)| - |Ciclos(\\rho)| + |Ciclos(\\rho\\sigma)|\\]\nUn sistema de rotación \\((\\sigma, \\rho)\\) pertenece a una y solo una superficie topológica.",
    "crumbs": [
      "Inicio",
      "2. Mapas Combinatorios"
    ]
  },
  {
    "objectID": "capitulos/02-mapas-combinatorios.html#ejemplo-el-impacto-de-sigma-en-la-topología",
    "href": "capitulos/02-mapas-combinatorios.html#ejemplo-el-impacto-de-sigma-en-la-topología",
    "title": "2. Mapas Combinatorios",
    "section": "Ejemplo: El Impacto de \\(\\sigma\\) en la Topología",
    "text": "Ejemplo: El Impacto de \\(\\sigma\\) en la Topología\nConsideraremos dos mapas combinatorios distintos que comparten el mismo conjunto de dardos y la misma estructura de aristas, pero difieren en su permutación \\(\\sigma\\). Este ejemplo ilustra cómo una pequeña variación en \\(\\sigma\\) puede cambiar radicalmente la superficie de encaje.\nAmbos mapas tienen: - Conjunto de dardos: \\(D = \\{1, 2, 3, 4\\}\\) - Estructura de aristas: \\(\\rho = (1, 2)(3, 4)\\) (dos aristas, cada una un lazo)\n\nLa diferencia está en el orden de rotación alrededor del único vértice.\n\nMapa A: Encaje en la Esfera (\\(g=0\\))\nConsideremos el mapa combinatorio: \\[ M_A = (D, \\sigma_A, \\rho) \\quad \\text{donde} \\quad \\sigma_A = (1, 2, 3, 4) \\]\nCalculamos \\(\\varphi_A = \\rho \\sigma_A\\):\n\nPaso a paso (Cruzar \\(\\to\\) Girar):\n\n\\(1 \\xrightarrow{\\rho} 2 \\xrightarrow{\\sigma} 3\\). (Sigue \\(1 \\to 3\\))\n\\(3 \\xrightarrow{\\rho} 4 \\xrightarrow{\\sigma} 1\\). (Cierra el ciclo \\((1, 3)\\))\n\\(2 \\xrightarrow{\\rho} 1 \\xrightarrow{\\sigma} 2\\). (Ciclo cerrado \\((2)\\))\n\\(4 \\xrightarrow{\\rho} 3 \\xrightarrow{\\sigma} 4\\). (Ciclo cerrado \\((4)\\))\n\n\nResultado: \\(\\varphi = (1, 3)(2)(4)\\). Tenemos \\(F=3\\) caras (Roja, Verde, Azul).\n \n\n\n\n\n\n\nTipVerificación con SageMath\n\n\n\nPuedes verificar estos cálculos en línea usando SageMathCell.\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nphi = rho * sigma  # φ = ρσ\nprint(phi)  # (1,3)\nprint(phi.cycle_tuples(singletons=True))  # [(1, 3), (2,), (4,)]\n\nR = RibbonGraph(sigma, rho)\nprint(R.boundary())  # [[1, 2, 3, 4], [2, 1], [4, 3]]\nprint(R.number_boundaries())  # 3\n\n\n\n\nMapa B: Encaje en el Toro (\\(g=1\\))\nConsideremos ahora un mapa combinatorio diferente: \\[ M_B = (D, \\sigma_B, \\rho) \\quad \\text{donde} \\quad \\sigma_B = (1, 3, 2, 4) \\]\nNotemos que \\(\\sigma_B\\) intercala las semiaristas en un orden distinto. Calculamos \\(\\varphi_B = \\rho \\sigma_B\\):\n\nPaso a paso (Cruzar \\(\\to\\) Girar):\n\n\\(1 \\xrightarrow{\\rho} 2 \\xrightarrow{\\sigma} 4\\).\n\\(4 \\xrightarrow{\\rho} 3 \\xrightarrow{\\sigma} 2\\).\n\n\\(2 \\xrightarrow{\\rho} 1 \\xrightarrow{\\sigma} 3\\).\n\\(3 \\xrightarrow{\\rho} 4 \\xrightarrow{\\sigma} 1\\).\n\n\nResultado: \\(\\varphi = (1, 4, 2, 3)\\). Tenemos \\(F=1\\) cara (Morada).\n\n\n\n\n\n\n\nTipVerificación con SageMath\n\n\n\nsigma = PermutationGroupElement('(1,3,2,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nphi = rho * sigma  # φ = ρσ\nprint(phi)  # (1,4,2,3)\nprint(phi.cycle_tuples(singletons=True))  # [(1, 4, 2, 3)]\n\nR = RibbonGraph(sigma, rho)\nprint(R.boundary())  # [[1, 2, 4, 3, 2, 1, 3, 4]]\nprint(R.number_boundaries())  # 1\n\n\n\n\n\n\n\n\nImportanteConclusión del Ejemplo\n\n\n\nHemos visto dos mapas combinatorios distintos:\n\nMapa \\(M_A\\): \\((D, \\sigma_A=(1,2,3,4), \\rho=(1,2)(3,4))\\) → Superficie: Esfera (\\(g=0\\), \\(F=3\\) caras)\nMapa \\(M_B\\): \\((D, \\sigma_B=(1,3,2,4), \\rho=(1,2)(3,4))\\) → Superficie: Toro (\\(g=1\\), \\(F=1\\) cara)\n\nAunque comparten el mismo conjunto de dardos \\(D\\) y la misma estructura de aristas \\(\\rho\\), una ligera variación en el sistema de rotación \\(\\sigma\\) (una transposición en el orden cíclico) produce superficies topológicamente distintas.\nEste ejemplo demuestra que \\(\\sigma\\) no es simplemente una “forma de dibujar” el grafo, sino que determina la topología intrínseca de la superficie de encaje.",
    "crumbs": [
      "Inicio",
      "2. Mapas Combinatorios"
    ]
  },
  {
    "objectID": "capitulos/02-mapas-combinatorios.html#ejercicios",
    "href": "capitulos/02-mapas-combinatorios.html#ejercicios",
    "title": "2. Mapas Combinatorios",
    "section": "Ejercicios",
    "text": "Ejercicios\n\n\n\n\n\n\nTipEjercicio 1: El Caso del Segmento (Vértices de Valencia 1)\n\n\n\nEste ejercicio explora qué sucede cuando la permutación \\(\\sigma\\) tiene puntos fijos (ciclos de longitud 1).\nConsidera el mapa combinatorio más simple posible que no es un lazo: un segmento con dos extremos distintos.\n\nDardos: \\(D = \\{1, 2\\}\\)\nAristas: \\(\\rho = (1, 2)\\) (los dardos 1 y 2 forman la única arista).\nVértices: Queremos que el dardo 1 esté en un vértice y el dardo 2 en otro vértice distinto. Por tanto, \\(\\sigma\\) debe ser la permutación identidad: \\[\\sigma = (1)(2)\\] (Nota: Esto significa que \\(\\sigma(1)=1\\) y \\(\\sigma(2)=2\\). Geométricamente, son vértices terminales o “hojas”).\n\nTarea: Determine la realización geométrica de este mapa combinatorio.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Cálculo Manual\n\n\n\nToma el sistema de rotación:\n\n\\(\\sigma = (1,3,5,2,4,6)\\)\n\\(\\rho = (1,2)(3,4)(5,6)\\)\n\nCalcula manualmente la permutación de caras \\(\\varphi = \\rho\\sigma\\) y determina cuántas caras tiene este encaje.\n\n\n\n\n\n\n\n\nTipEjercicio 3: Exploración Visual\n\n\n\nConsidera el bouquet de 3 círculos: un vértice con 3 self-loops (6 semiaristas). \\(\\rho\\) está fijo como \\((1,2)(3,4)(5,6)\\).\n\nUsa el visualizador para probar diferentes permutaciones \\(\\sigma\\) (por ejemplo, \\((1,2,3,4,5,6)\\) vs \\((1,6,2,5,3,4)\\)).\nAnaliza cómo cambia la conectividad de las cintas azules.\nDetermina si existe un \\(\\sigma\\) que produzca una superficie con solo 1 cara.\n\n\n\n\n\n\n\n\n\nTipEjercicio 4: El Espectro del Género (SageMath)\n\n\n\nVamos a explorar qué tan “raro” es obtener una esfera cuando conectamos aristas al azar. Considera un grafo con 1 vértice y 5 lazos (\\(|D|=10\\)).\n\nDefine \\(\\rho = (1,2)(3,4)...(9,10)\\).\nEscribe un script que genere permutaciones \\(\\sigma\\) aleatorias que consistan en un solo ciclo de longitud 10 (garantizando 1 vértice).\n\nTip: Puedes generar una lista aleatoria p de números del 1 al 10 y crear el ciclo: sigma = PermutationGroupElement([tuple(p)]).\n\nEjecuta un bucle de 1000 iteraciones. En cada paso, calcula el género del mapa resultante usando RibbonGraph(sigma, rho).genus().\nAnálisis:\n\n¿Cuáles son los géneros mínimo y máximo que observas?\n¿Con qué frecuencia aparece el género 0 (esfera)? ¿Es el caso más común o el más raro?\n\n\nNota: Este ejercicio demuestra que, combinatoriamente, las superficies de género alto son mucho más abundantes que la esfera.",
    "crumbs": [
      "Inicio",
      "2. Mapas Combinatorios"
    ]
  },
  {
    "objectID": "capitulos/02-mapas-combinatorios.html#resumen",
    "href": "capitulos/02-mapas-combinatorios.html#resumen",
    "title": "2. Mapas Combinatorios",
    "section": "Resumen",
    "text": "Resumen\n\nAxiomática: Un mapa combinatorio se define formalmente como una terna \\((D, \\sigma, \\rho)\\) que satisface axiomas algebraicos precisos, independientes del dibujo.\nTeorema de Realización: Existe una correspondencia biunívoca entre mapas combinatorios y superficies orientables con grafos encajados.\nAlgoritmo de Trazado: La permutación de caras se calcula como \\(\\varphi = \\rho \\sigma\\) (convención SageMath).\nInterpretación Geométrica: Las caras se recorren siguiendo la regla “Cruzar (\\(\\rho\\)) y Girar (\\(\\sigma\\))”.\nUnicidad: El par \\((\\sigma, \\rho)\\) determina unívocamente la topología de la superficie (el género es una consecuencia, no una elección).\n\nEn la siguiente sección utilizaremos este conteo de caras para calcular los invariantes topológicos (característica de Euler y género) directamente desde las permutaciones.",
    "crumbs": [
      "Inicio",
      "2. Mapas Combinatorios"
    ]
  },
  {
    "objectID": "capitulos/02-mapas-combinatorios.html#referencias",
    "href": "capitulos/02-mapas-combinatorios.html#referencias",
    "title": "2. Mapas Combinatorios",
    "section": "Referencias",
    "text": "Referencias\n\n[Tutte1979] W. T. Tutte, Combinatorial Oriented Maps, Canadian Journal of Mathematics, 31(5):986-1004, 1979. DOI:10.4153/CJM-1979-091-3\n\n\nPublicado el 09 de febrero de 2026",
    "crumbs": [
      "Inicio",
      "2. Mapas Combinatorios"
    ]
  },
  {
    "objectID": "capitulos/05-ejemplos.html",
    "href": "capitulos/05-ejemplos.html",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "En esta sección exploramos operaciones avanzadas sobre ribbon graphs, invariantes topológicos adicionales, y culminamos con el estudio del polinomio de Bollobás-Riordan, una generalización del polinomio de Tutte para grafos encajados en superficies.\n\n\n\nLa clase RibbonGraph en SageMath proporciona herramientas poderosas para analizar sistemas de rotación:\n\n\nfrom sage.all import RibbonGraph, PermutationGroupElement\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Acceso a las permutaciones\nprint(R.sigma())          # (1,2,3,4)\nprint(R.rho())            # (1,2)(3,4)\n\n# Invariantes topológicos\nprint(R.genus())          # 0\nprint(R.number_boundaries())  # 3\nprint(R.boundary())       # Lista de fronteras\n\n# Base de homología\nprint(R.homology_basis()) # Ciclos fundamentales\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\nsigma()\nDevuelve la permutación de vértices\n\n\nrho()\nDevuelve la permutación de aristas\n\n\ngenus()\nCalcula el género de la superficie\n\n\nnumber_boundaries()\nCuenta componentes de frontera\n\n\nboundary()\nDevuelve las secuencias de darts en cada frontera\n\n\nhomology_basis()\nBase para H₁(superficie)\n\n\ncontract_edge(d)\nContrae la arista que contiene el dart d\n\n\nreduced()\nElimina vértices de valencia 1\n\n\n\n\n\n\n\n\n\n\nLa contracción de una arista consiste en colapsar la arista a un punto, fusionando sus vértices extremos.\n\n\n\n\n\n\nNotaDefinición: Contracción\n\n\n\nDada una arista \\(e = \\{d, \\rho(d)\\}\\) en un ribbon graph, la contracción \\(G/e\\) resulta en: - Eliminar la arista \\(e\\) - Fusionar los vértices en los extremos de \\(e\\) - Preservar el orden cíclico de las aristas restantes\n\n\nEjemplo en Sage:\n# Triángulo K₃ encajado\nsigma = PermutationGroupElement('(1,6)(2,3)(4,5)')\nrho = PermutationGroupElement('(1,2)(3,4)(5,6)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Original: V={len(R.sigma().cycle_tuples(singletons=True))}, \"\n      f\"E={len(R.rho().cycle_tuples())}, \"\n      f\"g={R.genus()}\")\n\n# Contraer la arista que contiene el dart 1\nR_contraido = R.contract_edge(1)\nprint(f\"Contraído: V={len(R_contraido.sigma().cycle_tuples(singletons=True))}, \"\n      f\"E={len(R_contraido.rho().cycle_tuples())}, \"\n      f\"g={R_contraido.genus()}\")\nPropiedades: - La contracción puede cambiar el género - \\(\\chi(G/e) = \\chi(G) + 1\\) si \\(e\\) no es un loop - Útil para definir invariantes recursivos (como el polinomio de Tutte)\n\n\n\nEl método reduced() elimina sistemáticamente vértices de valencia 1:\n# Grafo con un vértice colgante\nsigma = PermutationGroupElement('(1,2,3)(4,5,6)(7,8,9)(10,11,12)(13,14,15)(16,17,18,19)')\nrho = PermutationGroupElement('(1,16)(2,13)(3,10)(4,17)(5,14)(6,11)(7,18)(8,15)(9,12)(19,20)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Original: {len(R.sigma().cycle_tuples(singletons=True))} vértices\")\nprint(f\"          {len(R.rho().cycle_tuples())} aristas\")\n\nR_reducido = R.reduced()\nprint(f\"Reducido: {len(R_reducido.sigma().cycle_tuples(singletons=True))} vértices\")\nprint(f\"          {len(R_reducido.rho().cycle_tuples())} aristas\")\n\n\n\n\n\n\nTipUso de reduced()\n\n\n\nLa reducción es útil para: - Simplificar ribbon graphs antes de calcular invariantes - Remover “hojas” que no contribuyen a la topología - Encontrar el “núcleo” topológico del grafo\n\n\n\n\n\nLa dual de un ribbon graph intercambia roles entre vértices y caras.\n\n\n\n\n\n\nImportanteConstrucción de la Dual\n\n\n\nDado un ribbon graph con sistema de rotación \\((\\sigma, \\rho)\\): - La dual tiene sistema \\((\\varphi, \\rho)\\) donde \\(\\varphi = \\rho\\sigma\\) es la permutación de caras - Los vértices de la dual corresponden a las caras del original - Las aristas se preservan (misma \\(\\rho\\)) - Las caras de la dual corresponden a los vértices del original\n\n\nImplementación manual de la dual:\ndef construir_dual(R):\n    \"\"\"\n    Construye la dual de un ribbon graph.\n\n    Args:\n        R: RibbonGraph original\n\n    Returns:\n        RibbonGraph dual\n    \"\"\"\n    # Obtener permutaciones originales\n    sigma = R.sigma()\n    rho = R.rho()\n\n    # Calcular phi = rho * sigma (caras)\n    phi = rho * sigma\n\n    # La dual tiene sigma_dual = phi, rho_dual = rho\n    R_dual = RibbonGraph(phi, rho)\n\n    return R_dual\n\n# Ejemplo: esfera con 3 fronteras\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\nR_dual = construir_dual(R)\n\nprint(\"Original:\")\nprint(f\"  V = {len(R.sigma().cycle_tuples(singletons=True))}\")\nprint(f\"  E = {len(R.rho().cycle_tuples())}\")\nprint(f\"  F = {len((R.rho() * R.sigma()).cycle_tuples(singletons=True))}\")\nprint(f\"  g = {R.genus()}\")\n\nprint(\"\\nDual:\")\nprint(f\"  V = {len(R_dual.sigma().cycle_tuples(singletons=True))}\")\nprint(f\"  E = {len(R_dual.rho().cycle_tuples())}\")\nprint(f\"  F = {len((R_dual.rho() * R_dual.sigma()).cycle_tuples(singletons=True))}\")\nprint(f\"  g = {R_dual.genus()}\")\nPropiedad fundamental: \\[ V^* = F, \\quad E^* = E, \\quad F^* = V, \\quad g^* = g \\]\ndonde \\(*\\) denota la dual.\n\n\n\n\n\nEl método homology_basis() calcula una base para el primer grupo de homología \\(H_1(S, \\mathbb{Z})\\) de la superficie:\nsigma = PermutationGroupElement('(1,3,5)(2,4,6)')\nrho = PermutationGroupElement('(1,2)(3,4)(5,6)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Género: {R.genus()}\")\nbase = R.homology_basis()\nprint(f\"Número de ciclos en la base: {len(base)}\")\nprint(f\"Base de homología:\")\nfor i, ciclo in enumerate(base, 1):\n    print(f\"  Ciclo {i}: {ciclo}\")\n\n\n\n\n\n\nNotaInterpretación\n\n\n\nPara una superficie de género \\(g\\) con \\(b\\) componentes de frontera: \\[ \\text{rank}(H_1(S)) = 2g + b - 1 \\]\nCada ciclo en la base representa un “agujero” fundamental en la superficie.\n\n\n\n\n\n\nEl polinomio de Bollobás-Riordan es una generalización del polinomio de Tutte para grafos encajados en superficies orientables. Codifica información topológica y combinatoria del encaje.\n\n\n\n\n\n\n\n\nImportantePolinomio de Bollobás-Riordan\n\n\n\nPara un ribbon graph \\(G\\) con sistema de rotación \\((\\sigma, \\rho)\\), el polinomio de Bollobás-Riordan \\(R_G(x, y, z)\\) satisface:\n\nCaso base: Si \\(G\\) es un ciclo simple (una frontera): \\[ R_G(x, y, z) = y + z \\]\nCaso base: Si \\(G\\) consiste solo de loops disjuntos: \\[ R_G(x, y, z) = x^k (y+z) \\] donde \\(k\\) es el número de loops.\nRelación de contracción-borrado: Para una arista \\(e\\) que no es loop ni istmo: \\[ R_G(x,y,z) = R_{G/e}(x,y,z) + R_{G \\setminus e}(x,y,z) \\]\nPara un loop: Si \\(e\\) es un loop: \\[ R_G(x,y,z) = x \\cdot R_{G \\setminus e}(x,y,z) \\]\nPara un istmo: Si \\(e\\) es un istmo (corta una componente de frontera): \\[ R_G(x,y,z) = z \\cdot R_{G / e}(x,y,z) \\]\n\n\n\n\n\n\n\nGeneraliza el polinomio de Tutte:\n\nPara grafos planos: \\(R_G(x, 1, 1) = T_G(x, 1)\\)\nPara grafos en superficies cerradas: codifica información adicional sobre el género\n\nInvariante topológico:\n\nDepende del encaje, no solo del grafo abstracto\nCaptura información sobre el género y componentes de frontera\n\nEvaluaciones especiales:\n\n\\(R_G(1, 1, 1)\\) cuenta spanning subgraphs\nRelación con polinomios cromáticos generalizados\n\n\n\n\n\nSage no tiene implementación nativa del polinomio de Bollobás-Riordan para RibbonGraph, pero podemos implementarlo nosotros mismos:\nfrom sage.all import PolynomialRing, QQ\n\ndef es_loop(R, dart):\n    \"\"\"\n    Verifica si un dart pertenece a un loop (self-loop).\n    Un loop conecta un vértice consigo mismo.\n    \"\"\"\n    rho = R.rho()\n    pareja = rho(dart)\n\n    # Verificar si ambos darts están en el mismo ciclo de sigma\n    sigma = R.sigma()\n    for ciclo in sigma.cycle_tuples():\n        if dart in ciclo and pareja in ciclo:\n            return True\n    return False\n\ndef es_istmo(R, dart):\n    \"\"\"\n    Verifica si un dart pertenece a un istmo (bridge).\n    Un istmo, cuando se elimina, incrementa el número de componentes de frontera.\n    \"\"\"\n    # Método aproximado: un istmo no puede ser un loop\n    # y al eliminarlo debe aumentar las componentes de frontera\n    if es_loop(R, dart):\n        return False\n\n    # Crear una versión sin esta arista requeriría\n    # manipular las permutaciones manualmente\n    # Por simplicidad, asumimos que no es istmo si no es loop\n    # (una implementación completa requeriría más lógica)\n    return False\n\ndef bollobas_riordan(R, x, y, z, memo=None):\n    \"\"\"\n    Calcula el polinomio de Bollobás-Riordan de un ribbon graph.\n\n    Args:\n        R: RibbonGraph\n        x, y, z: variables del polinomio\n        memo: diccionario para memoización\n\n    Returns:\n        Polinomio en Q[x,y,z]\n    \"\"\"\n    if memo is None:\n        memo = {}\n\n    # Convertir ribbon graph a una clave hasheable\n    sigma_str = str(R.sigma())\n    rho_str = str(R.rho())\n    clave = (sigma_str, rho_str)\n\n    if clave in memo:\n        return memo[clave]\n\n    # Casos base\n    num_edges = len(R.rho().cycle_tuples())\n    num_boundaries = R.number_boundaries()\n\n    # Caso 1: Sin aristas (solo vértices aislados)\n    if num_edges == 0:\n        # Solo componentes de frontera triviales\n        resultado = (y + z)\n        memo[clave] = resultado\n        return resultado\n\n    # Caso 2: Un ciclo simple (una frontera, una arista)\n    if num_edges == 1 and num_boundaries == 1:\n        resultado = y + z\n        memo[clave] = resultado\n        return resultado\n\n    # Caso recursivo: elegir una arista\n    # Tomamos el primer dart disponible\n    darts = []\n    for ciclo in R.rho().cycle_tuples():\n        darts.extend(ciclo)\n\n    if not darts:\n        resultado = y + z\n        memo[clave] = resultado\n        return resultado\n\n    dart = darts[0]\n\n    # Verificar si es loop\n    if es_loop(R, dart):\n        # R_G = x * R_{G\\e}\n        # Para implementar G\\e necesitamos remover el ciclo de rho\n        # Esto es complejo, por ahora retornamos una aproximación\n        resultado = x * (y + z)  # Simplificación\n        memo[clave] = resultado\n        return resultado\n\n    # Caso general: contracción-borrado\n    # R_G = R_{G/e} + R_{G\\e}\n    try:\n        R_contraido = R.contract_edge(dart)\n        term_contraer = bollobas_riordan(R_contraido, x, y, z, memo)\n    except:\n        term_contraer = 0\n\n    # Para borrar necesitaríamos remover el dart de rho\n    # Implementación simplificada\n    term_borrar = y + z\n\n    resultado = term_contraer + term_borrar\n    memo[clave] = resultado\n    return resultado\n\n# Crear ring de polinomios\nR_poly.&lt;x, y, z&gt; = PolynomialRing(QQ)\n\n# Ejemplo: calcular para un ribbon graph simple\nsigma = PermutationGroupElement('(1,2)')\nrho = PermutationGroupElement('(1,2)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Ribbon graph: sigma={R.sigma()}, rho={R.rho()}\")\nprint(f\"Género: {R.genus()}\")\nprint(f\"Fronteras: {R.number_boundaries()}\")\nprint()\n\n# Calcular polinomio (versión simplificada)\npoly = bollobas_riordan(R, x, y, z)\nprint(f\"Polinomio de Bollobás-Riordan (aproximado): {poly}\")\n\n\n\n\n\n\nAdvertenciaNota sobre la Implementación\n\n\n\nLa implementación completa del polinomio de Bollobás-Riordan requiere: 1. Manipulación cuidadosa de las permutaciones para borrar aristas 2. Detección robusta de loops e istmos 3. Memoización eficiente para evitar recálculos 4. Manejo de casos especiales (múltiples componentes, etc.)\nLa versión presentada es una implementación pedagógica simplificada que ilustra la estructura recursiva del polinomio.\n\n\n\n\n\nUna implementación más robusta utilizaría representaciones alternativas:\ndef ribbon_to_graph_data(R):\n    \"\"\"\n    Extrae información combinatoria de un ribbon graph.\n\n    Returns:\n        dict con vértices, aristas, género, etc.\n    \"\"\"\n    sigma_cycles = R.sigma().cycle_tuples(singletons=True)\n    rho_cycles = R.rho().cycle_tuples()\n    phi = R.rho() * R.sigma()\n    phi_cycles = phi.cycle_tuples(singletons=True)\n\n    return {\n        'vertices': len(sigma_cycles),\n        'edges': len(rho_cycles),\n        'faces': len(phi_cycles),\n        'genus': R.genus(),\n        'boundaries': R.number_boundaries(),\n        'euler_char': len(sigma_cycles) - len(rho_cycles) + len(phi_cycles)\n    }\n\n# Ejemplo de uso\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\ninfo = ribbon_to_graph_data(R)\nprint(\"Información del ribbon graph:\")\nfor clave, valor in info.items():\n    print(f\"  {clave}: {valor}\")\n\n\n\n\n\n\n\n\n\n\n\nTipEjercicio 1: Dualidad\n\n\n\nImplementa una función que calcule la dual de un ribbon graph y verifica que: 1. \\((G^*)^* = G\\) 2. \\(V^* = F\\) y \\(F^* = V\\) 3. \\(g^* = g\\)\nPrueba con varios ejemplos: K₃ en la esfera, toro con un vértice, etc.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Contracción Iterada\n\n\n\nToma un grafo completo K₄ encajado en una superficie y: 1. Contrae aristas una por una 2. Registra el género después de cada contracción 3. Analiza cómo evoluciona el género\n¿Cuándo la contracción preserva el género? ¿Cuándo lo cambia?\n\n\n\n\n\n\n\n\nTipEjercicio 3: Polinomio de Bollobás-Riordan\n\n\n\nMejora la implementación del polinomio de Bollobás-Riordan para: 1. Manejar correctamente la operación de borrado de aristas 2. Detectar loops e istmos de forma robusta 3. Implementar memoización eficiente\nCalcula el polinomio para grafos pequeños (K₃, K₄, bouquet de círculos).\n\n\n\n\n\n\n\n\nTipEjercicio 4: Base de Homología\n\n\n\nPara un toro con múltiples vértices: 1. Calcula la base de homología usando homology_basis() 2. Visualiza los ciclos fundamentales 3. Verifica que rank(H₁) = 2g + b - 1\nExperimenta con diferentes encajes del mismo grafo y compara las bases.\n\n\n\n\n\n\n\nOperaciones: Contracción, reducción y dualidad son transformaciones fundamentales\nHerramientas de Sage: RibbonGraph proporciona métodos poderosos para análisis topológico\nHomología: La base de homología captura los “agujeros” de la superficie\nPolinomio de Bollobás-Riordan: Generaliza el polinomio de Tutte a superficies\nImplementación: Requiere manipulación cuidadosa de permutaciones y recursión\n\nEl polinomio de Bollobás-Riordan es un área activa de investigación con conexiones a: - Teoría de nudos (polinomios de nudos) - Física matemática (modelos de Potts) - Combinatoria enumerativa\n\n\n\n\n\nBollobás, B., & Riordan, O. (2002). “A polynomial of graphs on surfaces”. Mathematische Annalen.\nChmutov, S. (2009). “Generalized duality for graphs on surfaces and the signed Bollobás–Riordan polynomial”.\nEllis-Monaghan, J. A., & Moffatt, I. (2013). “Graphs on Surfaces: Dualities, Polynomials, and Knots”.\nSageMath - Ribbon Graphs Documentation"
  },
  {
    "objectID": "capitulos/05-ejemplos.html#herramientas-de-la-clase-ribbongraph-en-sage",
    "href": "capitulos/05-ejemplos.html#herramientas-de-la-clase-ribbongraph-en-sage",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "La clase RibbonGraph en SageMath proporciona herramientas poderosas para analizar sistemas de rotación:\n\n\nfrom sage.all import RibbonGraph, PermutationGroupElement\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Acceso a las permutaciones\nprint(R.sigma())          # (1,2,3,4)\nprint(R.rho())            # (1,2)(3,4)\n\n# Invariantes topológicos\nprint(R.genus())          # 0\nprint(R.number_boundaries())  # 3\nprint(R.boundary())       # Lista de fronteras\n\n# Base de homología\nprint(R.homology_basis()) # Ciclos fundamentales\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\nsigma()\nDevuelve la permutación de vértices\n\n\nrho()\nDevuelve la permutación de aristas\n\n\ngenus()\nCalcula el género de la superficie\n\n\nnumber_boundaries()\nCuenta componentes de frontera\n\n\nboundary()\nDevuelve las secuencias de darts en cada frontera\n\n\nhomology_basis()\nBase para H₁(superficie)\n\n\ncontract_edge(d)\nContrae la arista que contiene el dart d\n\n\nreduced()\nElimina vértices de valencia 1"
  },
  {
    "objectID": "capitulos/05-ejemplos.html#operaciones-sobre-ribbon-graphs",
    "href": "capitulos/05-ejemplos.html#operaciones-sobre-ribbon-graphs",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "La contracción de una arista consiste en colapsar la arista a un punto, fusionando sus vértices extremos.\n\n\n\n\n\n\nNotaDefinición: Contracción\n\n\n\nDada una arista \\(e = \\{d, \\rho(d)\\}\\) en un ribbon graph, la contracción \\(G/e\\) resulta en: - Eliminar la arista \\(e\\) - Fusionar los vértices en los extremos de \\(e\\) - Preservar el orden cíclico de las aristas restantes\n\n\nEjemplo en Sage:\n# Triángulo K₃ encajado\nsigma = PermutationGroupElement('(1,6)(2,3)(4,5)')\nrho = PermutationGroupElement('(1,2)(3,4)(5,6)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Original: V={len(R.sigma().cycle_tuples(singletons=True))}, \"\n      f\"E={len(R.rho().cycle_tuples())}, \"\n      f\"g={R.genus()}\")\n\n# Contraer la arista que contiene el dart 1\nR_contraido = R.contract_edge(1)\nprint(f\"Contraído: V={len(R_contraido.sigma().cycle_tuples(singletons=True))}, \"\n      f\"E={len(R_contraido.rho().cycle_tuples())}, \"\n      f\"g={R_contraido.genus()}\")\nPropiedades: - La contracción puede cambiar el género - \\(\\chi(G/e) = \\chi(G) + 1\\) si \\(e\\) no es un loop - Útil para definir invariantes recursivos (como el polinomio de Tutte)\n\n\n\nEl método reduced() elimina sistemáticamente vértices de valencia 1:\n# Grafo con un vértice colgante\nsigma = PermutationGroupElement('(1,2,3)(4,5,6)(7,8,9)(10,11,12)(13,14,15)(16,17,18,19)')\nrho = PermutationGroupElement('(1,16)(2,13)(3,10)(4,17)(5,14)(6,11)(7,18)(8,15)(9,12)(19,20)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Original: {len(R.sigma().cycle_tuples(singletons=True))} vértices\")\nprint(f\"          {len(R.rho().cycle_tuples())} aristas\")\n\nR_reducido = R.reduced()\nprint(f\"Reducido: {len(R_reducido.sigma().cycle_tuples(singletons=True))} vértices\")\nprint(f\"          {len(R_reducido.rho().cycle_tuples())} aristas\")\n\n\n\n\n\n\nTipUso de reduced()\n\n\n\nLa reducción es útil para: - Simplificar ribbon graphs antes de calcular invariantes - Remover “hojas” que no contribuyen a la topología - Encontrar el “núcleo” topológico del grafo\n\n\n\n\n\nLa dual de un ribbon graph intercambia roles entre vértices y caras.\n\n\n\n\n\n\nImportanteConstrucción de la Dual\n\n\n\nDado un ribbon graph con sistema de rotación \\((\\sigma, \\rho)\\): - La dual tiene sistema \\((\\varphi, \\rho)\\) donde \\(\\varphi = \\rho\\sigma\\) es la permutación de caras - Los vértices de la dual corresponden a las caras del original - Las aristas se preservan (misma \\(\\rho\\)) - Las caras de la dual corresponden a los vértices del original\n\n\nImplementación manual de la dual:\ndef construir_dual(R):\n    \"\"\"\n    Construye la dual de un ribbon graph.\n\n    Args:\n        R: RibbonGraph original\n\n    Returns:\n        RibbonGraph dual\n    \"\"\"\n    # Obtener permutaciones originales\n    sigma = R.sigma()\n    rho = R.rho()\n\n    # Calcular phi = rho * sigma (caras)\n    phi = rho * sigma\n\n    # La dual tiene sigma_dual = phi, rho_dual = rho\n    R_dual = RibbonGraph(phi, rho)\n\n    return R_dual\n\n# Ejemplo: esfera con 3 fronteras\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\nR_dual = construir_dual(R)\n\nprint(\"Original:\")\nprint(f\"  V = {len(R.sigma().cycle_tuples(singletons=True))}\")\nprint(f\"  E = {len(R.rho().cycle_tuples())}\")\nprint(f\"  F = {len((R.rho() * R.sigma()).cycle_tuples(singletons=True))}\")\nprint(f\"  g = {R.genus()}\")\n\nprint(\"\\nDual:\")\nprint(f\"  V = {len(R_dual.sigma().cycle_tuples(singletons=True))}\")\nprint(f\"  E = {len(R_dual.rho().cycle_tuples())}\")\nprint(f\"  F = {len((R_dual.rho() * R_dual.sigma()).cycle_tuples(singletons=True))}\")\nprint(f\"  g = {R_dual.genus()}\")\nPropiedad fundamental: \\[ V^* = F, \\quad E^* = E, \\quad F^* = V, \\quad g^* = g \\]\ndonde \\(*\\) denota la dual."
  },
  {
    "objectID": "capitulos/05-ejemplos.html#base-de-homología",
    "href": "capitulos/05-ejemplos.html#base-de-homología",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "El método homology_basis() calcula una base para el primer grupo de homología \\(H_1(S, \\mathbb{Z})\\) de la superficie:\nsigma = PermutationGroupElement('(1,3,5)(2,4,6)')\nrho = PermutationGroupElement('(1,2)(3,4)(5,6)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Género: {R.genus()}\")\nbase = R.homology_basis()\nprint(f\"Número de ciclos en la base: {len(base)}\")\nprint(f\"Base de homología:\")\nfor i, ciclo in enumerate(base, 1):\n    print(f\"  Ciclo {i}: {ciclo}\")\n\n\n\n\n\n\nNotaInterpretación\n\n\n\nPara una superficie de género \\(g\\) con \\(b\\) componentes de frontera: \\[ \\text{rank}(H_1(S)) = 2g + b - 1 \\]\nCada ciclo en la base representa un “agujero” fundamental en la superficie."
  },
  {
    "objectID": "capitulos/05-ejemplos.html#el-polinomio-de-bollobás-riordan",
    "href": "capitulos/05-ejemplos.html#el-polinomio-de-bollobás-riordan",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "El polinomio de Bollobás-Riordan es una generalización del polinomio de Tutte para grafos encajados en superficies orientables. Codifica información topológica y combinatoria del encaje.\n\n\n\n\n\n\n\n\nImportantePolinomio de Bollobás-Riordan\n\n\n\nPara un ribbon graph \\(G\\) con sistema de rotación \\((\\sigma, \\rho)\\), el polinomio de Bollobás-Riordan \\(R_G(x, y, z)\\) satisface:\n\nCaso base: Si \\(G\\) es un ciclo simple (una frontera): \\[ R_G(x, y, z) = y + z \\]\nCaso base: Si \\(G\\) consiste solo de loops disjuntos: \\[ R_G(x, y, z) = x^k (y+z) \\] donde \\(k\\) es el número de loops.\nRelación de contracción-borrado: Para una arista \\(e\\) que no es loop ni istmo: \\[ R_G(x,y,z) = R_{G/e}(x,y,z) + R_{G \\setminus e}(x,y,z) \\]\nPara un loop: Si \\(e\\) es un loop: \\[ R_G(x,y,z) = x \\cdot R_{G \\setminus e}(x,y,z) \\]\nPara un istmo: Si \\(e\\) es un istmo (corta una componente de frontera): \\[ R_G(x,y,z) = z \\cdot R_{G / e}(x,y,z) \\]\n\n\n\n\n\n\n\nGeneraliza el polinomio de Tutte:\n\nPara grafos planos: \\(R_G(x, 1, 1) = T_G(x, 1)\\)\nPara grafos en superficies cerradas: codifica información adicional sobre el género\n\nInvariante topológico:\n\nDepende del encaje, no solo del grafo abstracto\nCaptura información sobre el género y componentes de frontera\n\nEvaluaciones especiales:\n\n\\(R_G(1, 1, 1)\\) cuenta spanning subgraphs\nRelación con polinomios cromáticos generalizados\n\n\n\n\n\nSage no tiene implementación nativa del polinomio de Bollobás-Riordan para RibbonGraph, pero podemos implementarlo nosotros mismos:\nfrom sage.all import PolynomialRing, QQ\n\ndef es_loop(R, dart):\n    \"\"\"\n    Verifica si un dart pertenece a un loop (self-loop).\n    Un loop conecta un vértice consigo mismo.\n    \"\"\"\n    rho = R.rho()\n    pareja = rho(dart)\n\n    # Verificar si ambos darts están en el mismo ciclo de sigma\n    sigma = R.sigma()\n    for ciclo in sigma.cycle_tuples():\n        if dart in ciclo and pareja in ciclo:\n            return True\n    return False\n\ndef es_istmo(R, dart):\n    \"\"\"\n    Verifica si un dart pertenece a un istmo (bridge).\n    Un istmo, cuando se elimina, incrementa el número de componentes de frontera.\n    \"\"\"\n    # Método aproximado: un istmo no puede ser un loop\n    # y al eliminarlo debe aumentar las componentes de frontera\n    if es_loop(R, dart):\n        return False\n\n    # Crear una versión sin esta arista requeriría\n    # manipular las permutaciones manualmente\n    # Por simplicidad, asumimos que no es istmo si no es loop\n    # (una implementación completa requeriría más lógica)\n    return False\n\ndef bollobas_riordan(R, x, y, z, memo=None):\n    \"\"\"\n    Calcula el polinomio de Bollobás-Riordan de un ribbon graph.\n\n    Args:\n        R: RibbonGraph\n        x, y, z: variables del polinomio\n        memo: diccionario para memoización\n\n    Returns:\n        Polinomio en Q[x,y,z]\n    \"\"\"\n    if memo is None:\n        memo = {}\n\n    # Convertir ribbon graph a una clave hasheable\n    sigma_str = str(R.sigma())\n    rho_str = str(R.rho())\n    clave = (sigma_str, rho_str)\n\n    if clave in memo:\n        return memo[clave]\n\n    # Casos base\n    num_edges = len(R.rho().cycle_tuples())\n    num_boundaries = R.number_boundaries()\n\n    # Caso 1: Sin aristas (solo vértices aislados)\n    if num_edges == 0:\n        # Solo componentes de frontera triviales\n        resultado = (y + z)\n        memo[clave] = resultado\n        return resultado\n\n    # Caso 2: Un ciclo simple (una frontera, una arista)\n    if num_edges == 1 and num_boundaries == 1:\n        resultado = y + z\n        memo[clave] = resultado\n        return resultado\n\n    # Caso recursivo: elegir una arista\n    # Tomamos el primer dart disponible\n    darts = []\n    for ciclo in R.rho().cycle_tuples():\n        darts.extend(ciclo)\n\n    if not darts:\n        resultado = y + z\n        memo[clave] = resultado\n        return resultado\n\n    dart = darts[0]\n\n    # Verificar si es loop\n    if es_loop(R, dart):\n        # R_G = x * R_{G\\e}\n        # Para implementar G\\e necesitamos remover el ciclo de rho\n        # Esto es complejo, por ahora retornamos una aproximación\n        resultado = x * (y + z)  # Simplificación\n        memo[clave] = resultado\n        return resultado\n\n    # Caso general: contracción-borrado\n    # R_G = R_{G/e} + R_{G\\e}\n    try:\n        R_contraido = R.contract_edge(dart)\n        term_contraer = bollobas_riordan(R_contraido, x, y, z, memo)\n    except:\n        term_contraer = 0\n\n    # Para borrar necesitaríamos remover el dart de rho\n    # Implementación simplificada\n    term_borrar = y + z\n\n    resultado = term_contraer + term_borrar\n    memo[clave] = resultado\n    return resultado\n\n# Crear ring de polinomios\nR_poly.&lt;x, y, z&gt; = PolynomialRing(QQ)\n\n# Ejemplo: calcular para un ribbon graph simple\nsigma = PermutationGroupElement('(1,2)')\nrho = PermutationGroupElement('(1,2)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Ribbon graph: sigma={R.sigma()}, rho={R.rho()}\")\nprint(f\"Género: {R.genus()}\")\nprint(f\"Fronteras: {R.number_boundaries()}\")\nprint()\n\n# Calcular polinomio (versión simplificada)\npoly = bollobas_riordan(R, x, y, z)\nprint(f\"Polinomio de Bollobás-Riordan (aproximado): {poly}\")\n\n\n\n\n\n\nAdvertenciaNota sobre la Implementación\n\n\n\nLa implementación completa del polinomio de Bollobás-Riordan requiere: 1. Manipulación cuidadosa de las permutaciones para borrar aristas 2. Detección robusta de loops e istmos 3. Memoización eficiente para evitar recálculos 4. Manejo de casos especiales (múltiples componentes, etc.)\nLa versión presentada es una implementación pedagógica simplificada que ilustra la estructura recursiva del polinomio.\n\n\n\n\n\nUna implementación más robusta utilizaría representaciones alternativas:\ndef ribbon_to_graph_data(R):\n    \"\"\"\n    Extrae información combinatoria de un ribbon graph.\n\n    Returns:\n        dict con vértices, aristas, género, etc.\n    \"\"\"\n    sigma_cycles = R.sigma().cycle_tuples(singletons=True)\n    rho_cycles = R.rho().cycle_tuples()\n    phi = R.rho() * R.sigma()\n    phi_cycles = phi.cycle_tuples(singletons=True)\n\n    return {\n        'vertices': len(sigma_cycles),\n        'edges': len(rho_cycles),\n        'faces': len(phi_cycles),\n        'genus': R.genus(),\n        'boundaries': R.number_boundaries(),\n        'euler_char': len(sigma_cycles) - len(rho_cycles) + len(phi_cycles)\n    }\n\n# Ejemplo de uso\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\ninfo = ribbon_to_graph_data(R)\nprint(\"Información del ribbon graph:\")\nfor clave, valor in info.items():\n    print(f\"  {clave}: {valor}\")"
  },
  {
    "objectID": "capitulos/05-ejemplos.html#ejercicios",
    "href": "capitulos/05-ejemplos.html#ejercicios",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "TipEjercicio 1: Dualidad\n\n\n\nImplementa una función que calcule la dual de un ribbon graph y verifica que: 1. \\((G^*)^* = G\\) 2. \\(V^* = F\\) y \\(F^* = V\\) 3. \\(g^* = g\\)\nPrueba con varios ejemplos: K₃ en la esfera, toro con un vértice, etc.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Contracción Iterada\n\n\n\nToma un grafo completo K₄ encajado en una superficie y: 1. Contrae aristas una por una 2. Registra el género después de cada contracción 3. Analiza cómo evoluciona el género\n¿Cuándo la contracción preserva el género? ¿Cuándo lo cambia?\n\n\n\n\n\n\n\n\nTipEjercicio 3: Polinomio de Bollobás-Riordan\n\n\n\nMejora la implementación del polinomio de Bollobás-Riordan para: 1. Manejar correctamente la operación de borrado de aristas 2. Detectar loops e istmos de forma robusta 3. Implementar memoización eficiente\nCalcula el polinomio para grafos pequeños (K₃, K₄, bouquet de círculos).\n\n\n\n\n\n\n\n\nTipEjercicio 4: Base de Homología\n\n\n\nPara un toro con múltiples vértices: 1. Calcula la base de homología usando homology_basis() 2. Visualiza los ciclos fundamentales 3. Verifica que rank(H₁) = 2g + b - 1\nExperimenta con diferentes encajes del mismo grafo y compara las bases."
  },
  {
    "objectID": "capitulos/05-ejemplos.html#resumen",
    "href": "capitulos/05-ejemplos.html#resumen",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "Operaciones: Contracción, reducción y dualidad son transformaciones fundamentales\nHerramientas de Sage: RibbonGraph proporciona métodos poderosos para análisis topológico\nHomología: La base de homología captura los “agujeros” de la superficie\nPolinomio de Bollobás-Riordan: Generaliza el polinomio de Tutte a superficies\nImplementación: Requiere manipulación cuidadosa de permutaciones y recursión\n\nEl polinomio de Bollobás-Riordan es un área activa de investigación con conexiones a: - Teoría de nudos (polinomios de nudos) - Física matemática (modelos de Potts) - Combinatoria enumerativa"
  },
  {
    "objectID": "capitulos/05-ejemplos.html#referencias",
    "href": "capitulos/05-ejemplos.html#referencias",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "Bollobás, B., & Riordan, O. (2002). “A polynomial of graphs on surfaces”. Mathematische Annalen.\nChmutov, S. (2009). “Generalized duality for graphs on surfaces and the signed Bollobás–Riordan polynomial”.\nEllis-Monaghan, J. A., & Moffatt, I. (2013). “Graphs on Surfaces: Dualities, Polynomials, and Knots”.\nSageMath - Ribbon Graphs Documentation"
  }
]