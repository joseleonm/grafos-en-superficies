[
  {
    "objectID": "notas/teoria.html",
    "href": "notas/teoria.html",
    "title": "Teoría de Ribbon Graphs",
    "section": "",
    "text": "NotaDefinición\n\n\n\nUn ribbon graph es un par de permutaciones \\((σ, ρ)\\) donde:\n\nσ ∈ S_n es una permutación arbitraria (ciclos de cualquier longitud)\nρ ∈ S_n es una involución (producto de 2-ciclos disjuntos)\nEl dominio es {1, 2, …, n} (conjunto de dardos)\n\n\n\n\n\n\n\n\n\nUn dardo (half-edge) es “medio” de una arista\nCada arista se parte en el punto medio\nLos dardos se numeran de 1 a n\n\n\n\n\n\nCada ciclo de σ define un vértice\nLos elementos del ciclo son los dardos incidentes\nEl orden cíclico alrededor del vértice sigue σ\n\n\n\n\n\nCada 2-ciclo de ρ conecta dos dardos\nForma una arista del grafo\n\n\n\n\n\nμ = σ · ρ define las caras\nCada ciclo de μ es una cara\nLa longitud del ciclo = número de lados\n\n\n\n\n\n\n\n\n\n\n\nImportanteTeorema (Euler)\n\n\n\nPara un ribbon graph con género g y b componentes de frontera:\n\\[\\chi = V - E + F = 2 - 2g - b\\]\ndonde V = |σ|, E = |ρ|, F = |μ|.\n\n\n\n\n\nPor construcción: V - E + F = característica del grafo\nAl engrosar obtenemos una superficie con frontera\nLa característica de Euler para superficies con frontera es 2 - 2g - b\nPor tanto: V - E + F = 2 - 2g - b\n\n\n\n\n\n\n\nρ² = identidad, es decir, cada dardo se empareja con exactamente un otro dardo.\nVerificación:\nrho = Permutation('(1,4)(2,5)(3,6)')\nrho_squared = rho * rho\nprint(rho_squared)  # Debe ser ()\n\n\n\nσ define un orden cíclico alrededor de cada vértice, crucial para: - Definir la orientación de la superficie - Calcular el género correctamente - Determinar las fronteras\n\n\n\nμ = σ · ρ no es conmutativa en general: - σ · ρ ≠ ρ · σ - Diferentes órdenes dan diferentes estructuras\n\n\n\n\nUna superficie orientable con frontera se clasifica por:\n\nGénero (g): Número de “agujeros”\nFronteras (b): Número de componentes de borde\n\n\n\n\n\n\ng\nb\nSuperficie\n\n\n\n\n0\n0\nEsfera S²\n\n\n0\n1\nDisco D²\n\n\n0\n2\nCilindro S¹ × [0,1]\n\n\n0\n3+\nEsfera con agujeros\n\n\n1\n0\nToro T²\n\n\n1\n1\nToro con 1 agujero\n\n\n2\n0\nToro doble\n\n\n\n\n\n\n\n\n\nContraer una arista (d₁, d₂): - Eliminar d₁, d₂ de σ y ρ - Fusionar los vértices correspondientes\n\n\n\nDividir un vértice en dos: - Particionar el ciclo de σ - Agregar nueva arista conectándolos\n\n\n\nEl dual de un ribbon graph (σ, ρ) es (μ, ρ⁻¹).\nPropiedades: - V(dual) = F(original) - E(dual) = E(original) - F(dual) = V(original)\n\n\n\n\nUn ribbon graph es equivalente a:\n\nUn grafo embebido en una superficie con frontera\nUn grafo con orden cíclico de aristas en cada vértice\nUn map combinatorio (en el sentido de Tutte)\n\n\n\n\n\nTopología algebraica: Cálculo de homología\nTeoría de nudos: Diagramas de enlaces\nFísica teórica: Teoría de cuerdas, diagramas de Feynman\nCombinatoria: Árboles generadores, polinomios de grafos\n\n\n\n\n\nGross & Tucker (1987) - Topological Graph Theory\nLando & Zvonkin (2004) - Graphs on Surfaces\nTutte (1963) - A census of planar maps\n\n\n\n\n\nTutorial 1: Introducción\nEjemplos Clásicos"
  },
  {
    "objectID": "notas/teoria.html#definición-formal",
    "href": "notas/teoria.html#definición-formal",
    "title": "Teoría de Ribbon Graphs",
    "section": "",
    "text": "NotaDefinición\n\n\n\nUn ribbon graph es un par de permutaciones \\((σ, ρ)\\) donde:\n\nσ ∈ S_n es una permutación arbitraria (ciclos de cualquier longitud)\nρ ∈ S_n es una involución (producto de 2-ciclos disjuntos)\nEl dominio es {1, 2, …, n} (conjunto de dardos)"
  },
  {
    "objectID": "notas/teoria.html#construcción-geométrica",
    "href": "notas/teoria.html#construcción-geométrica",
    "title": "Teoría de Ribbon Graphs",
    "section": "",
    "text": "Un dardo (half-edge) es “medio” de una arista\nCada arista se parte en el punto medio\nLos dardos se numeran de 1 a n\n\n\n\n\n\nCada ciclo de σ define un vértice\nLos elementos del ciclo son los dardos incidentes\nEl orden cíclico alrededor del vértice sigue σ\n\n\n\n\n\nCada 2-ciclo de ρ conecta dos dardos\nForma una arista del grafo\n\n\n\n\n\nμ = σ · ρ define las caras\nCada ciclo de μ es una cara\nLa longitud del ciclo = número de lados"
  },
  {
    "objectID": "notas/teoria.html#teorema-fundamental",
    "href": "notas/teoria.html#teorema-fundamental",
    "title": "Teoría de Ribbon Graphs",
    "section": "",
    "text": "ImportanteTeorema (Euler)\n\n\n\nPara un ribbon graph con género g y b componentes de frontera:\n\\[\\chi = V - E + F = 2 - 2g - b\\]\ndonde V = |σ|, E = |ρ|, F = |μ|.\n\n\n\n\n\nPor construcción: V - E + F = característica del grafo\nAl engrosar obtenemos una superficie con frontera\nLa característica de Euler para superficies con frontera es 2 - 2g - b\nPor tanto: V - E + F = 2 - 2g - b"
  },
  {
    "objectID": "notas/teoria.html#propiedades",
    "href": "notas/teoria.html#propiedades",
    "title": "Teoría de Ribbon Graphs",
    "section": "",
    "text": "ρ² = identidad, es decir, cada dardo se empareja con exactamente un otro dardo.\nVerificación:\nrho = Permutation('(1,4)(2,5)(3,6)')\nrho_squared = rho * rho\nprint(rho_squared)  # Debe ser ()\n\n\n\nσ define un orden cíclico alrededor de cada vértice, crucial para: - Definir la orientación de la superficie - Calcular el género correctamente - Determinar las fronteras\n\n\n\nμ = σ · ρ no es conmutativa en general: - σ · ρ ≠ ρ · σ - Diferentes órdenes dan diferentes estructuras"
  },
  {
    "objectID": "notas/teoria.html#clasificación-de-superficies",
    "href": "notas/teoria.html#clasificación-de-superficies",
    "title": "Teoría de Ribbon Graphs",
    "section": "",
    "text": "Una superficie orientable con frontera se clasifica por:\n\nGénero (g): Número de “agujeros”\nFronteras (b): Número de componentes de borde\n\n\n\n\n\n\ng\nb\nSuperficie\n\n\n\n\n0\n0\nEsfera S²\n\n\n0\n1\nDisco D²\n\n\n0\n2\nCilindro S¹ × [0,1]\n\n\n0\n3+\nEsfera con agujeros\n\n\n1\n0\nToro T²\n\n\n1\n1\nToro con 1 agujero\n\n\n2\n0\nToro doble"
  },
  {
    "objectID": "notas/teoria.html#operaciones",
    "href": "notas/teoria.html#operaciones",
    "title": "Teoría de Ribbon Graphs",
    "section": "",
    "text": "Contraer una arista (d₁, d₂): - Eliminar d₁, d₂ de σ y ρ - Fusionar los vértices correspondientes\n\n\n\nDividir un vértice en dos: - Particionar el ciclo de σ - Agregar nueva arista conectándolos\n\n\n\nEl dual de un ribbon graph (σ, ρ) es (μ, ρ⁻¹).\nPropiedades: - V(dual) = F(original) - E(dual) = E(original) - F(dual) = V(original)"
  },
  {
    "objectID": "notas/teoria.html#conexión-con-teoría-de-grafos",
    "href": "notas/teoria.html#conexión-con-teoría-de-grafos",
    "title": "Teoría de Ribbon Graphs",
    "section": "",
    "text": "Un ribbon graph es equivalente a:\n\nUn grafo embebido en una superficie con frontera\nUn grafo con orden cíclico de aristas en cada vértice\nUn map combinatorio (en el sentido de Tutte)"
  },
  {
    "objectID": "notas/teoria.html#aplicaciones",
    "href": "notas/teoria.html#aplicaciones",
    "title": "Teoría de Ribbon Graphs",
    "section": "",
    "text": "Topología algebraica: Cálculo de homología\nTeoría de nudos: Diagramas de enlaces\nFísica teórica: Teoría de cuerdas, diagramas de Feynman\nCombinatoria: Árboles generadores, polinomios de grafos"
  },
  {
    "objectID": "notas/teoria.html#referencias-clave",
    "href": "notas/teoria.html#referencias-clave",
    "title": "Teoría de Ribbon Graphs",
    "section": "",
    "text": "Gross & Tucker (1987) - Topological Graph Theory\nLando & Zvonkin (2004) - Graphs on Surfaces\nTutte (1963) - A census of planar maps"
  },
  {
    "objectID": "notas/teoria.html#ver-también",
    "href": "notas/teoria.html#ver-también",
    "title": "Teoría de Ribbon Graphs",
    "section": "",
    "text": "Tutorial 1: Introducción\nEjemplos Clásicos"
  },
  {
    "objectID": "capitulos/02-trazado-de-caras.html",
    "href": "capitulos/02-trazado-de-caras.html",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "Para determinar las caras de un encaje celular dado por un sistema de rotación \\((\\sigma, \\rho)\\), utilizamos el algoritmo de trazado de caras (Face Tracing). Este procedimiento nos permite identificar los ciclos de semiaristas que conforman los bordes de las caras.\n\n\nEn la convención de SageMath para ribbon graphs, las caras están determinadas por las órbitas de la permutación \\(\\varphi\\), definida como:\n\\[ \\varphi = \\rho \\sigma \\]\nEsta es la fórmula utilizada internamente por el método boundary() de la clase RibbonGraph en Sage.\n\n\n\n\n\n\nImportanteConvención de Multiplicación (SageMath)\n\n\n\nEn este curso y en SageMath, la multiplicación de permutaciones se lee de izquierda a derecha. La expresión \\(\\varphi = \\rho \\sigma\\) significa: primero aplicamos \\(\\rho\\) (cruzar la arista) y luego aplicamos \\(\\sigma\\) (girar en el vértice en el orden dado).\n\n\n\n\n\n\n\n\nNotaNota sobre Convenciones Alternativas\n\n\n\nAlgunos textos usan \\(\\varphi = \\rho \\sigma^{-1}\\), \\(\\varphi = \\sigma^{-1} \\rho\\), o \\(\\varphi = (\\sigma\\rho)^{-1}\\). Todas estas convenciones dan el mismo número de caras, pero los ciclos específicos pueden diferir. Usamos \\(\\varphi = \\rho \\sigma\\) para coincidir exactamente con la implementación de SageMath y simplificar los cálculos (no hay que invertir σ).\n\n\n\n\n\nEl cálculo de \\(\\varphi(d)\\) para una semiarista \\(d\\) sigue estos pasos geométricos:\n\nCruzar la arista: Desde \\(d\\), vamos al otro extremo de la arista aplicando \\(\\rho\\).\nGirar en el vértice: En el nuevo vértice, tomamos la siguiente semiarista según el orden de rotación \\(\\sigma\\).\n\nEsto corresponde a recorrer el borde de la cara siguiendo la orientación dada por el ribbon graph.\n\n\n\nConsideremos el grafo con un vértice y dos lazos (aristas que empiezan y terminan en el mismo vértice). Tenemos 4 semiaristas: \\(D = \\{1, 2, 3, 4\\}\\). La permutación de aristas es fija: \\(\\rho = (1, 2)(3, 4)\\).\n\nVamos a calcular las caras para dos elecciones distintas de \\(\\sigma\\), mostrando cómo el orden cíclico afecta la topología.\n\n\nElegimos el orden cíclico natural: \\[ \\sigma = (1, 2, 3, 4) \\]\nCalculamos \\(\\varphi = \\rho \\sigma\\):\n\nPaso a paso (Cruzar \\(\\to\\) Girar):\n\n\\(1 \\xrightarrow{\\rho} 2 \\xrightarrow{\\sigma} 3\\). (Sigue \\(1 \\to 3\\))\n\\(3 \\xrightarrow{\\rho} 4 \\xrightarrow{\\sigma} 1\\). (Cierra el ciclo \\((1, 3)\\))\n\\(2 \\xrightarrow{\\rho} 1 \\xrightarrow{\\sigma} 2\\). (Ciclo cerrado \\((2)\\))\n\\(4 \\xrightarrow{\\rho} 3 \\xrightarrow{\\sigma} 4\\). (Ciclo cerrado \\((4)\\))\n\n\nResultado: \\(\\varphi = (1, 3)(2)(4)\\). Tenemos \\(F=3\\) caras (Roja, Verde, Azul).\n \n\n\n\n\n\n\nTipVerificación con SageMath\n\n\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nphi = rho * sigma  # φ = ρσ\nprint(phi)  # (1,3)\nprint(phi.cycle_tuples(singletons=True))  # [(1, 3), (2,), (4,)]\n\nR = RibbonGraph(sigma, rho)\nprint(R.boundary())  # [[1, 2, 3, 4], [2, 1], [4, 3]]\nprint(R.number_boundaries())  # 3\n\n\n\n\n\nCambiamos el orden cíclico intercalando las semiaristas: \\[ \\sigma = (1, 3, 2, 4) \\]\nCalculamos \\(\\varphi = \\rho \\sigma\\):\n\nPaso a paso (Cruzar \\(\\to\\) Girar):\n\n\\(1 \\xrightarrow{\\rho} 2 \\xrightarrow{\\sigma} 4\\).\n\\(4 \\xrightarrow{\\rho} 3 \\xrightarrow{\\sigma} 2\\).\n\n\\(2 \\xrightarrow{\\rho} 1 \\xrightarrow{\\sigma} 3\\).\n\\(3 \\xrightarrow{\\rho} 4 \\xrightarrow{\\sigma} 1\\).\n\n\nResultado: \\(\\varphi = (1, 4, 2, 3)\\). Tenemos \\(F=1\\) cara (Morada).\n\n\n\n\n\n\n\nTipVerificación con SageMath\n\n\n\nsigma = PermutationGroupElement('(1,3,2,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nphi = rho * sigma  # φ = ρσ\nprint(phi)  # (1,4,2,3)\nprint(phi.cycle_tuples(singletons=True))  # [(1, 4, 2, 3)]\n\nR = RibbonGraph(sigma, rho)\nprint(R.boundary())  # [[1, 2, 4, 3, 2, 1, 3, 4]]\nprint(R.number_boundaries())  # 1\n\n\n\n\n\n\n\n\nNotaSuperficie Cerrada\n\n\n\nEste encaje produce un toro (género 1, con una componente de frontera). ¡Una simple transposición en el orden de las semiaristas alrededor del vértice transformó la superficie de tres componentes disjuntas a un toro!\n\n\n\n\n\n\nEl conjunto de órbitas (ciclos disjuntos) de la permutación \\(\\varphi\\) es exactamente el conjunto de caras del encaje.\n\\[ F = \\text{número de ciclos de } \\varphi \\]\n\n\n\n\n\n\n\n\n\n\nTipEjercicio 1: Cálculo Manual\n\n\n\nToma el sistema de rotación:\n\n\\(\\sigma = (1,2)(3,4)(5,6)\\)\n\\(\\rho = (1,2)(3,4)(5,6)\\)\n\nCalcula manualmente la permutación de caras \\(\\varphi = \\rho\\sigma\\) y determina cuántas caras tiene este encaje.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Exploración Visual\n\n\n\nConsidera el bouquet de 3 círculos: un vértice con 3 self-loops (6 semiaristas). \\(\\rho\\) está fijo como \\((1,2)(3,4)(5,6)\\).\n\nUsa el visualizador para probar diferentes permutaciones \\(\\sigma\\) (por ejemplo, \\((1,2,3,4,5,6)\\) vs \\((1,6,2,5,3,4)\\)).\nObserva cómo cambia la conectividad de las cintas azules.\n¿Puedes encontrar un \\(\\sigma\\) que produzca una superficie con solo 1 cara?\n\n\n\n\n\n\n\n\n\nTipEjercicio 3: Experimento Computacional con SageMath\n\n\n\nEscribe un script en SageMath para verificar la fórmula de las caras:\n\nDefine un conjunto de semiaristas \\(D = \\{1, \\dots, 20\\}\\).\nDefine un \\(\\rho\\) fijo (ej. (1,2)(3,4)...(19,20)).\nGenera un \\(\\sigma\\) aleatorio usando SymmetricGroup(20).random_element().\nCalcula el número de ciclos de \\(\\varphi = \\rho\\sigma\\).\nCompara este resultado con RibbonGraph(sigma, rho).number_boundaries().\n\nReto: Ejecuta este experimento 100 veces en un bucle. ¿Cuál es el número mínimo y máximo de caras que observas?\n\n\n\n\n\n\n\nEl Algoritmo de Trazado de Caras permite identificar las regiones del encaje mediante recorridos en el grafo.\nLa permutación de caras se define como \\(\\varphi = \\rho \\sigma\\) (convención de SageMath).\nLa regla geométrica es “Cruzar y Girar”: aplicar \\(\\rho\\) y luego \\(\\sigma\\).\nEl número de caras \\(F\\) es exactamente el número de ciclos disjuntos de \\(\\varphi\\).\nEl orden cíclico \\(\\sigma\\) determina la topología de la superficie (ej. Esfera vs. Toro).\n\nEn el siguiente capítulo utilizaremos este conteo de caras para calcular los invariantes topológicos (característica de Euler y género) directamente desde las permutaciones."
  },
  {
    "objectID": "capitulos/02-trazado-de-caras.html#la-permutación-de-caras-varphi",
    "href": "capitulos/02-trazado-de-caras.html#la-permutación-de-caras-varphi",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "En la convención de SageMath para ribbon graphs, las caras están determinadas por las órbitas de la permutación \\(\\varphi\\), definida como:\n\\[ \\varphi = \\rho \\sigma \\]\nEsta es la fórmula utilizada internamente por el método boundary() de la clase RibbonGraph en Sage.\n\n\n\n\n\n\nImportanteConvención de Multiplicación (SageMath)\n\n\n\nEn este curso y en SageMath, la multiplicación de permutaciones se lee de izquierda a derecha. La expresión \\(\\varphi = \\rho \\sigma\\) significa: primero aplicamos \\(\\rho\\) (cruzar la arista) y luego aplicamos \\(\\sigma\\) (girar en el vértice en el orden dado).\n\n\n\n\n\n\n\n\nNotaNota sobre Convenciones Alternativas\n\n\n\nAlgunos textos usan \\(\\varphi = \\rho \\sigma^{-1}\\), \\(\\varphi = \\sigma^{-1} \\rho\\), o \\(\\varphi = (\\sigma\\rho)^{-1}\\). Todas estas convenciones dan el mismo número de caras, pero los ciclos específicos pueden diferir. Usamos \\(\\varphi = \\rho \\sigma\\) para coincidir exactamente con la implementación de SageMath y simplificar los cálculos (no hay que invertir σ)."
  },
  {
    "objectID": "capitulos/02-trazado-de-caras.html#la-receta-geométrica-cruzar-y-girar",
    "href": "capitulos/02-trazado-de-caras.html#la-receta-geométrica-cruzar-y-girar",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "El cálculo de \\(\\varphi(d)\\) para una semiarista \\(d\\) sigue estos pasos geométricos:\n\nCruzar la arista: Desde \\(d\\), vamos al otro extremo de la arista aplicando \\(\\rho\\).\nGirar en el vértice: En el nuevo vértice, tomamos la siguiente semiarista según el orden de rotación \\(\\sigma\\).\n\nEsto corresponde a recorrer el borde de la cara siguiendo la orientación dada por el ribbon graph."
  },
  {
    "objectID": "capitulos/02-trazado-de-caras.html#ejemplo-un-vértice-dos-lazos",
    "href": "capitulos/02-trazado-de-caras.html#ejemplo-un-vértice-dos-lazos",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "Consideremos el grafo con un vértice y dos lazos (aristas que empiezan y terminan en el mismo vértice). Tenemos 4 semiaristas: \\(D = \\{1, 2, 3, 4\\}\\). La permutación de aristas es fija: \\(\\rho = (1, 2)(3, 4)\\).\n\nVamos a calcular las caras para dos elecciones distintas de \\(\\sigma\\), mostrando cómo el orden cíclico afecta la topología.\n\n\nElegimos el orden cíclico natural: \\[ \\sigma = (1, 2, 3, 4) \\]\nCalculamos \\(\\varphi = \\rho \\sigma\\):\n\nPaso a paso (Cruzar \\(\\to\\) Girar):\n\n\\(1 \\xrightarrow{\\rho} 2 \\xrightarrow{\\sigma} 3\\). (Sigue \\(1 \\to 3\\))\n\\(3 \\xrightarrow{\\rho} 4 \\xrightarrow{\\sigma} 1\\). (Cierra el ciclo \\((1, 3)\\))\n\\(2 \\xrightarrow{\\rho} 1 \\xrightarrow{\\sigma} 2\\). (Ciclo cerrado \\((2)\\))\n\\(4 \\xrightarrow{\\rho} 3 \\xrightarrow{\\sigma} 4\\). (Ciclo cerrado \\((4)\\))\n\n\nResultado: \\(\\varphi = (1, 3)(2)(4)\\). Tenemos \\(F=3\\) caras (Roja, Verde, Azul).\n \n\n\n\n\n\n\nTipVerificación con SageMath\n\n\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nphi = rho * sigma  # φ = ρσ\nprint(phi)  # (1,3)\nprint(phi.cycle_tuples(singletons=True))  # [(1, 3), (2,), (4,)]\n\nR = RibbonGraph(sigma, rho)\nprint(R.boundary())  # [[1, 2, 3, 4], [2, 1], [4, 3]]\nprint(R.number_boundaries())  # 3\n\n\n\n\n\nCambiamos el orden cíclico intercalando las semiaristas: \\[ \\sigma = (1, 3, 2, 4) \\]\nCalculamos \\(\\varphi = \\rho \\sigma\\):\n\nPaso a paso (Cruzar \\(\\to\\) Girar):\n\n\\(1 \\xrightarrow{\\rho} 2 \\xrightarrow{\\sigma} 4\\).\n\\(4 \\xrightarrow{\\rho} 3 \\xrightarrow{\\sigma} 2\\).\n\n\\(2 \\xrightarrow{\\rho} 1 \\xrightarrow{\\sigma} 3\\).\n\\(3 \\xrightarrow{\\rho} 4 \\xrightarrow{\\sigma} 1\\).\n\n\nResultado: \\(\\varphi = (1, 4, 2, 3)\\). Tenemos \\(F=1\\) cara (Morada).\n\n\n\n\n\n\n\nTipVerificación con SageMath\n\n\n\nsigma = PermutationGroupElement('(1,3,2,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nphi = rho * sigma  # φ = ρσ\nprint(phi)  # (1,4,2,3)\nprint(phi.cycle_tuples(singletons=True))  # [(1, 4, 2, 3)]\n\nR = RibbonGraph(sigma, rho)\nprint(R.boundary())  # [[1, 2, 4, 3, 2, 1, 3, 4]]\nprint(R.number_boundaries())  # 1\n\n\n\n\n\n\n\n\nNotaSuperficie Cerrada\n\n\n\nEste encaje produce un toro (género 1, con una componente de frontera). ¡Una simple transposición en el orden de las semiaristas alrededor del vértice transformó la superficie de tres componentes disjuntas a un toro!"
  },
  {
    "objectID": "capitulos/02-trazado-de-caras.html#propiedad-fundamental",
    "href": "capitulos/02-trazado-de-caras.html#propiedad-fundamental",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "El conjunto de órbitas (ciclos disjuntos) de la permutación \\(\\varphi\\) es exactamente el conjunto de caras del encaje.\n\\[ F = \\text{número de ciclos de } \\varphi \\]"
  },
  {
    "objectID": "capitulos/02-trazado-de-caras.html#ejercicios",
    "href": "capitulos/02-trazado-de-caras.html#ejercicios",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "TipEjercicio 1: Cálculo Manual\n\n\n\nToma el sistema de rotación:\n\n\\(\\sigma = (1,2)(3,4)(5,6)\\)\n\\(\\rho = (1,2)(3,4)(5,6)\\)\n\nCalcula manualmente la permutación de caras \\(\\varphi = \\rho\\sigma\\) y determina cuántas caras tiene este encaje.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Exploración Visual\n\n\n\nConsidera el bouquet de 3 círculos: un vértice con 3 self-loops (6 semiaristas). \\(\\rho\\) está fijo como \\((1,2)(3,4)(5,6)\\).\n\nUsa el visualizador para probar diferentes permutaciones \\(\\sigma\\) (por ejemplo, \\((1,2,3,4,5,6)\\) vs \\((1,6,2,5,3,4)\\)).\nObserva cómo cambia la conectividad de las cintas azules.\n¿Puedes encontrar un \\(\\sigma\\) que produzca una superficie con solo 1 cara?\n\n\n\n\n\n\n\n\n\nTipEjercicio 3: Experimento Computacional con SageMath\n\n\n\nEscribe un script en SageMath para verificar la fórmula de las caras:\n\nDefine un conjunto de semiaristas \\(D = \\{1, \\dots, 20\\}\\).\nDefine un \\(\\rho\\) fijo (ej. (1,2)(3,4)...(19,20)).\nGenera un \\(\\sigma\\) aleatorio usando SymmetricGroup(20).random_element().\nCalcula el número de ciclos de \\(\\varphi = \\rho\\sigma\\).\nCompara este resultado con RibbonGraph(sigma, rho).number_boundaries().\n\nReto: Ejecuta este experimento 100 veces en un bucle. ¿Cuál es el número mínimo y máximo de caras que observas?"
  },
  {
    "objectID": "capitulos/02-trazado-de-caras.html#resumen",
    "href": "capitulos/02-trazado-de-caras.html#resumen",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "El Algoritmo de Trazado de Caras permite identificar las regiones del encaje mediante recorridos en el grafo.\nLa permutación de caras se define como \\(\\varphi = \\rho \\sigma\\) (convención de SageMath).\nLa regla geométrica es “Cruzar y Girar”: aplicar \\(\\rho\\) y luego \\(\\sigma\\).\nEl número de caras \\(F\\) es exactamente el número de ciclos disjuntos de \\(\\varphi\\).\nEl orden cíclico \\(\\sigma\\) determina la topología de la superficie (ej. Esfera vs. Toro).\n\nEn el siguiente capítulo utilizaremos este conteo de caras para calcular los invariantes topológicos (característica de Euler y género) directamente desde las permutaciones."
  },
  {
    "objectID": "capitulos/04-teoremas.html",
    "href": "capitulos/04-teoremas.html",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "El Teorema de Heffter-Edmonds es la piedra angular de la teoría de grafos topológicos. No solo establece que todo sistema de rotación genera una superficie, sino que la correspondencia es estructuralmente perfecta: clasifica los encajes salvo equivalencia.\n\n\nAntes de enunciar el teorema en su forma fuerte, debemos precisar qué significa que dos sistemas sean “el mismo” desde el punto de vista combinatorio.\nDos sistemas de rotación \\((\\sigma_1, \\rho_1)\\) sobre un conjunto de semiaristas \\(D_1\\) y \\((\\sigma_2, \\rho_2)\\) sobre \\(D_2\\) son equivalentes (o isomorfos) si existe una biyección \\(\\tau: D_1 \\to D_2\\) tal que:\n\\[\n\\sigma_2 = \\tau \\sigma_1 \\tau^{-1} \\quad \\text{y} \\quad \\rho_2 = \\tau \\rho_1 \\tau^{-1}\n\\]\nEsta biyección \\(\\tau\\) preserva toda la estructura combinatoria: mapea vértices a vértices (ciclos de \\(\\sigma\\)) y aristas a aristas (ciclos de \\(\\rho\\)).\n\n\n\nGeométricamente, dos encajes de grafos \\(G_1 \\subset S_1\\) y \\(G_2 \\subset S_2\\) son equivalentes si existe un homeomorfismo que preserva la orientación \\(h: S_1 \\to S_2\\) tal que \\(h(G_1) = G_2\\). Esto implica que \\(h\\) induce un isomorfismo entre los grafos abstractos subyacentes.\n\n\n\n\n\n\n\n\n\nImportanteTeorema Fuerte de Heffter-Edmonds\n\n\n\nExiste una correspondencia biunívoca natural entre:\n\nClases de equivalencia de sistemas de rotación \\((\\sigma, \\rho)\\).\nClases de equivalencia de encajes celulares de grafos en superficies orientables.\n\nEsto significa que el álgebra de las permutaciones \\((\\sigma, \\rho)\\) captura toda la información topológica del encaje, sin pérdida ni ambigüedad.\n\n\n\n\n\nEste resultado transforma problemas topológicos en problemas puramente combinatorios:\n\nHeffter (1891): Primeros trabajos sobre encajes de grafos en superficies\nEdmonds (1960): Formulación moderna en términos de permutaciones\nTambién conocido como el teorema de representación de superficies\n\n\n\n\n\n\n\n\n\n\n\n\nImportanteProposición fundamental\n\n\n\nExiste una correspondencia biunívoca natural entre:\n\nSistemas de rotación \\((\\sigma, \\rho)\\)\nRibbon graphs\nEncajes celulares en superficies orientables\n\nEstas tres formas de describir el mismo objeto matemático son completamente equivalentes.\n\n\n\n\nLa construcción del trazado de caras (capítulo 2) proporciona la transformación explícita:\n\\[\n(\\sigma, \\rho) \\quad \\xrightarrow{\\text{engrosamiento}} \\quad \\text{Ribbon graph}\n\\]\n\n\n\nDado un ribbon graph (superficie con grafo encajado):\n\nIdentificar las semiaristas en el borde de cada vértice\nLeer el orden cíclico \\(\\to\\) permutación \\(\\sigma\\)\nEmparejar semiaristas de cada arista \\(\\to\\) permutación \\(\\rho\\)\n\n\n\n\n\n\nComo hemos visto en los capítulos anteriores, el sistema \\((\\sigma, \\rho)\\) determina completamente el grafo (\\(V, E\\)) y la topología de la superficie (\\(F, g\\)). Sin embargo, hay una propiedad topológica fundamental que está implícita en esta construcción: la orientabilidad.\n\n\nTodo sistema de rotación \\((\\sigma, \\rho)\\) genera necesariamente una superficie orientable. Esto no es una coincidencia, sino una consecuencia de la definición misma.\n\nOrientación Local: La permutación \\(\\sigma\\) define un orden cíclico estricto en cada vértice. Geométricamente, esto equivale a elegir una dirección de “giro” (por ejemplo, antihorario) en el disco que representa cada vértice.\nConsistencia Global: Al conectar estos vértices mediante aristas (las bandas o ribbons), asumimos implícitamente que no hay torsiones. Conectamos el borde del disco \\(u\\) con el borde del disco \\(v\\) sin voltear la cinta.\nDos Lados: Como resultado, la superficie resultante tiene dos lados bien definidos (“arriba” y “abajo”). Es posible pintar un lado de rojo y otro de azul sin que los colores se mezclen, lo cual es la definición intuitiva de orientabilidad.\n\n\n\n\nPara representar superficies no orientables (como la Banda de Möbius o la Botella de Klein), el modelo de permutaciones \\((\\sigma, \\rho)\\) es insuficiente. Se requiere información adicional:\n\nSistemas de rotación con signo: Se añade una función de firma \\(\\lambda: E \\to \\{+1, -1\\}\\).\nSi una arista tiene signo \\(-1\\), la cinta se “tuerce” al conectar los vértices, invirtiendo la orientación local.\n\nDado que nuestros sistemas de rotación no incluyen esta firma (son “puros”), estamos restringidos exclusivamente al universo de las superficies orientables.\n\n\n\n\n\nUn encaje celular de un grafo en una superficie es equivalente a un complejo celular 2-dimensional donde:\n\n0-celdas = vértices del grafo\n1-celdas = aristas del grafo\n2-celdas = caras del encaje\n\nEl sistema de rotación \\((\\sigma, \\rho)\\) codifica completamente la información combinatoria de este complejo celular.\n\n\n\n\n\n\n# ¿Cuál es el género mínimo en el que K₃ se puede encajar?\nR = RibbonGraph('(1,6)(2,3)(4,5)', '(1,2)(3,4)(5,6)')\nprint(f\"Género de este encaje: {R.genus()}\")\n\n# K₃ es planar, por lo que g = 0 es posible\n\n\n\n# Queremos género 1 (toro)\n# Usamos la fórmula: chi = 2 - 2g - b\n# Para g=1, b=0: chi = 0\n# Necesitamos V - E + F = 0\n\n# Ejemplo: V=1, E=2, F=1\nR = RibbonGraph('(1,2,3,4)', '(1,2)(3,4)')\nprint(f\"χ = {R.num_vertices() - R.num_edges() + len(list(R.faces()))}\")\nprint(f\"g = {R.genus()}\")\n\n\n\n\n\n\n\n\n\n\n\nTipEjercicio 1: Teorema de Heffter-Edmonds\n\n\n\nConsidera el sistema \\(\\sigma = (1,2,3)\\), \\(\\rho = (1,2)(3)\\).\n\n¿Es válido este sistema? (¿\\(\\rho\\) tiene solo 2-ciclos?)\nSi no es válido, corrige \\(\\rho\\)\nCalcula los invariantes del sistema corregido\n\n\n\n\n\n\n\n\n\nTipEjercicio 2: Superficies con frontera\n\n\n\nEncuentra sistemas de rotación que produzcan:\n\nUn anillo (cilindro topológico: g=0, b=2)\nUn toro con un agujero (g=1, b=1)\nUn bitoro con dos agujeros (g=2, b=2)\n\n\n\n\n\n\n\n\nTeorema de Heffter-Edmonds: establece la equivalencia entre sistemas de rotación y encajes celulares\nEquivalencia: sistemas de rotación ↔︎ ribbon graphs ↔︎ encajes celulares\nPropiedades: determinación del grafo, cálculo de invariantes, orientabilidad\nClasificación: superficies orientables compactas caracterizadas por \\((g, b)\\)\n\nEn el siguiente capítulo veremos una galería de ejemplos clásicos con análisis completo de sus propiedades."
  },
  {
    "objectID": "capitulos/04-teoremas.html#el-teorema-de-heffter-edmonds",
    "href": "capitulos/04-teoremas.html#el-teorema-de-heffter-edmonds",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "El Teorema de Heffter-Edmonds es la piedra angular de la teoría de grafos topológicos. No solo establece que todo sistema de rotación genera una superficie, sino que la correspondencia es estructuralmente perfecta: clasifica los encajes salvo equivalencia.\n\n\nAntes de enunciar el teorema en su forma fuerte, debemos precisar qué significa que dos sistemas sean “el mismo” desde el punto de vista combinatorio.\nDos sistemas de rotación \\((\\sigma_1, \\rho_1)\\) sobre un conjunto de semiaristas \\(D_1\\) y \\((\\sigma_2, \\rho_2)\\) sobre \\(D_2\\) son equivalentes (o isomorfos) si existe una biyección \\(\\tau: D_1 \\to D_2\\) tal que:\n\\[\n\\sigma_2 = \\tau \\sigma_1 \\tau^{-1} \\quad \\text{y} \\quad \\rho_2 = \\tau \\rho_1 \\tau^{-1}\n\\]\nEsta biyección \\(\\tau\\) preserva toda la estructura combinatoria: mapea vértices a vértices (ciclos de \\(\\sigma\\)) y aristas a aristas (ciclos de \\(\\rho\\)).\n\n\n\nGeométricamente, dos encajes de grafos \\(G_1 \\subset S_1\\) y \\(G_2 \\subset S_2\\) son equivalentes si existe un homeomorfismo que preserva la orientación \\(h: S_1 \\to S_2\\) tal que \\(h(G_1) = G_2\\). Esto implica que \\(h\\) induce un isomorfismo entre los grafos abstractos subyacentes.\n\n\n\n\n\n\n\n\n\nImportanteTeorema Fuerte de Heffter-Edmonds\n\n\n\nExiste una correspondencia biunívoca natural entre:\n\nClases de equivalencia de sistemas de rotación \\((\\sigma, \\rho)\\).\nClases de equivalencia de encajes celulares de grafos en superficies orientables.\n\nEsto significa que el álgebra de las permutaciones \\((\\sigma, \\rho)\\) captura toda la información topológica del encaje, sin pérdida ni ambigüedad.\n\n\n\n\n\nEste resultado transforma problemas topológicos en problemas puramente combinatorios:\n\nHeffter (1891): Primeros trabajos sobre encajes de grafos en superficies\nEdmonds (1960): Formulación moderna en términos de permutaciones\nTambién conocido como el teorema de representación de superficies"
  },
  {
    "objectID": "capitulos/04-teoremas.html#equivalencia-con-ribbon-graphs",
    "href": "capitulos/04-teoremas.html#equivalencia-con-ribbon-graphs",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "ImportanteProposición fundamental\n\n\n\nExiste una correspondencia biunívoca natural entre:\n\nSistemas de rotación \\((\\sigma, \\rho)\\)\nRibbon graphs\nEncajes celulares en superficies orientables\n\nEstas tres formas de describir el mismo objeto matemático son completamente equivalentes.\n\n\n\n\nLa construcción del trazado de caras (capítulo 2) proporciona la transformación explícita:\n\\[\n(\\sigma, \\rho) \\quad \\xrightarrow{\\text{engrosamiento}} \\quad \\text{Ribbon graph}\n\\]\n\n\n\nDado un ribbon graph (superficie con grafo encajado):\n\nIdentificar las semiaristas en el borde de cada vértice\nLeer el orden cíclico \\(\\to\\) permutación \\(\\sigma\\)\nEmparejar semiaristas de cada arista \\(\\to\\) permutación \\(\\rho\\)"
  },
  {
    "objectID": "capitulos/04-teoremas.html#propiedades-la-cuestión-de-la-orientabilidad",
    "href": "capitulos/04-teoremas.html#propiedades-la-cuestión-de-la-orientabilidad",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "Como hemos visto en los capítulos anteriores, el sistema \\((\\sigma, \\rho)\\) determina completamente el grafo (\\(V, E\\)) y la topología de la superficie (\\(F, g\\)). Sin embargo, hay una propiedad topológica fundamental que está implícita en esta construcción: la orientabilidad.\n\n\nTodo sistema de rotación \\((\\sigma, \\rho)\\) genera necesariamente una superficie orientable. Esto no es una coincidencia, sino una consecuencia de la definición misma.\n\nOrientación Local: La permutación \\(\\sigma\\) define un orden cíclico estricto en cada vértice. Geométricamente, esto equivale a elegir una dirección de “giro” (por ejemplo, antihorario) en el disco que representa cada vértice.\nConsistencia Global: Al conectar estos vértices mediante aristas (las bandas o ribbons), asumimos implícitamente que no hay torsiones. Conectamos el borde del disco \\(u\\) con el borde del disco \\(v\\) sin voltear la cinta.\nDos Lados: Como resultado, la superficie resultante tiene dos lados bien definidos (“arriba” y “abajo”). Es posible pintar un lado de rojo y otro de azul sin que los colores se mezclen, lo cual es la definición intuitiva de orientabilidad.\n\n\n\n\nPara representar superficies no orientables (como la Banda de Möbius o la Botella de Klein), el modelo de permutaciones \\((\\sigma, \\rho)\\) es insuficiente. Se requiere información adicional:\n\nSistemas de rotación con signo: Se añade una función de firma \\(\\lambda: E \\to \\{+1, -1\\}\\).\nSi una arista tiene signo \\(-1\\), la cinta se “tuerce” al conectar los vértices, invirtiendo la orientación local.\n\nDado que nuestros sistemas de rotación no incluyen esta firma (son “puros”), estamos restringidos exclusivamente al universo de las superficies orientables."
  },
  {
    "objectID": "capitulos/04-teoremas.html#relación-con-complejos-celulares",
    "href": "capitulos/04-teoremas.html#relación-con-complejos-celulares",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "Un encaje celular de un grafo en una superficie es equivalente a un complejo celular 2-dimensional donde:\n\n0-celdas = vértices del grafo\n1-celdas = aristas del grafo\n2-celdas = caras del encaje\n\nEl sistema de rotación \\((\\sigma, \\rho)\\) codifica completamente la información combinatoria de este complejo celular."
  },
  {
    "objectID": "capitulos/04-teoremas.html#ejemplos-de-aplicación",
    "href": "capitulos/04-teoremas.html#ejemplos-de-aplicación",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "# ¿Cuál es el género mínimo en el que K₃ se puede encajar?\nR = RibbonGraph('(1,6)(2,3)(4,5)', '(1,2)(3,4)(5,6)')\nprint(f\"Género de este encaje: {R.genus()}\")\n\n# K₃ es planar, por lo que g = 0 es posible\n\n\n\n# Queremos género 1 (toro)\n# Usamos la fórmula: chi = 2 - 2g - b\n# Para g=1, b=0: chi = 0\n# Necesitamos V - E + F = 0\n\n# Ejemplo: V=1, E=2, F=1\nR = RibbonGraph('(1,2,3,4)', '(1,2)(3,4)')\nprint(f\"χ = {R.num_vertices() - R.num_edges() + len(list(R.faces()))}\")\nprint(f\"g = {R.genus()}\")"
  },
  {
    "objectID": "capitulos/04-teoremas.html#ejercicios",
    "href": "capitulos/04-teoremas.html#ejercicios",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "TipEjercicio 1: Teorema de Heffter-Edmonds\n\n\n\nConsidera el sistema \\(\\sigma = (1,2,3)\\), \\(\\rho = (1,2)(3)\\).\n\n¿Es válido este sistema? (¿\\(\\rho\\) tiene solo 2-ciclos?)\nSi no es válido, corrige \\(\\rho\\)\nCalcula los invariantes del sistema corregido\n\n\n\n\n\n\n\n\n\nTipEjercicio 2: Superficies con frontera\n\n\n\nEncuentra sistemas de rotación que produzcan:\n\nUn anillo (cilindro topológico: g=0, b=2)\nUn toro con un agujero (g=1, b=1)\nUn bitoro con dos agujeros (g=2, b=2)"
  },
  {
    "objectID": "capitulos/04-teoremas.html#resumen",
    "href": "capitulos/04-teoremas.html#resumen",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "Teorema de Heffter-Edmonds: establece la equivalencia entre sistemas de rotación y encajes celulares\nEquivalencia: sistemas de rotación ↔︎ ribbon graphs ↔︎ encajes celulares\nPropiedades: determinación del grafo, cálculo de invariantes, orientabilidad\nClasificación: superficies orientables compactas caracterizadas por \\((g, b)\\)\n\nEn el siguiente capítulo veremos una galería de ejemplos clásicos con análisis completo de sus propiedades."
  },
  {
    "objectID": "capitulos/05-ejemplos.html",
    "href": "capitulos/05-ejemplos.html",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "En este capítulo exploramos operaciones avanzadas sobre ribbon graphs, invariantes topológicos adicionales, y culminamos con el estudio del polinomio de Bollobás-Riordan, una generalización del polinomio de Tutte para grafos encajados en superficies.\n\n\n\nLa clase RibbonGraph en SageMath proporciona herramientas poderosas para analizar sistemas de rotación:\n\n\nfrom sage.all import RibbonGraph, PermutationGroupElement\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Acceso a las permutaciones\nprint(R.sigma())          # (1,2,3,4)\nprint(R.rho())            # (1,2)(3,4)\n\n# Invariantes topológicos\nprint(R.genus())          # 0\nprint(R.number_boundaries())  # 3\nprint(R.boundary())       # Lista de fronteras\n\n# Base de homología\nprint(R.homology_basis()) # Ciclos fundamentales\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\nsigma()\nDevuelve la permutación de vértices\n\n\nrho()\nDevuelve la permutación de aristas\n\n\ngenus()\nCalcula el género de la superficie\n\n\nnumber_boundaries()\nCuenta componentes de frontera\n\n\nboundary()\nDevuelve las secuencias de darts en cada frontera\n\n\nhomology_basis()\nBase para H₁(superficie)\n\n\ncontract_edge(d)\nContrae la arista que contiene el dart d\n\n\nreduced()\nElimina vértices de valencia 1\n\n\n\n\n\n\n\n\n\n\nLa contracción de una arista consiste en colapsar la arista a un punto, fusionando sus vértices extremos.\n\n\n\n\n\n\nNotaDefinición: Contracción\n\n\n\nDada una arista \\(e = \\{d, \\rho(d)\\}\\) en un ribbon graph, la contracción \\(G/e\\) resulta en: - Eliminar la arista \\(e\\) - Fusionar los vértices en los extremos de \\(e\\) - Preservar el orden cíclico de las aristas restantes\n\n\nEjemplo en Sage:\n# Triángulo K₃ encajado\nsigma = PermutationGroupElement('(1,6)(2,3)(4,5)')\nrho = PermutationGroupElement('(1,2)(3,4)(5,6)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Original: V={len(R.sigma().cycle_tuples(singletons=True))}, \"\n      f\"E={len(R.rho().cycle_tuples())}, \"\n      f\"g={R.genus()}\")\n\n# Contraer la arista que contiene el dart 1\nR_contraido = R.contract_edge(1)\nprint(f\"Contraído: V={len(R_contraido.sigma().cycle_tuples(singletons=True))}, \"\n      f\"E={len(R_contraido.rho().cycle_tuples())}, \"\n      f\"g={R_contraido.genus()}\")\nPropiedades: - La contracción puede cambiar el género - \\(\\chi(G/e) = \\chi(G) + 1\\) si \\(e\\) no es un loop - Útil para definir invariantes recursivos (como el polinomio de Tutte)\n\n\n\nEl método reduced() elimina sistemáticamente vértices de valencia 1:\n# Grafo con un vértice colgante\nsigma = PermutationGroupElement('(1,2,3)(4,5,6)(7,8,9)(10,11,12)(13,14,15)(16,17,18,19)')\nrho = PermutationGroupElement('(1,16)(2,13)(3,10)(4,17)(5,14)(6,11)(7,18)(8,15)(9,12)(19,20)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Original: {len(R.sigma().cycle_tuples(singletons=True))} vértices\")\nprint(f\"          {len(R.rho().cycle_tuples())} aristas\")\n\nR_reducido = R.reduced()\nprint(f\"Reducido: {len(R_reducido.sigma().cycle_tuples(singletons=True))} vértices\")\nprint(f\"          {len(R_reducido.rho().cycle_tuples())} aristas\")\n\n\n\n\n\n\nTipUso de reduced()\n\n\n\nLa reducción es útil para: - Simplificar ribbon graphs antes de calcular invariantes - Remover “hojas” que no contribuyen a la topología - Encontrar el “núcleo” topológico del grafo\n\n\n\n\n\nLa dual de un ribbon graph intercambia roles entre vértices y caras.\n\n\n\n\n\n\nImportanteConstrucción de la Dual\n\n\n\nDado un ribbon graph con sistema de rotación \\((\\sigma, \\rho)\\): - La dual tiene sistema \\((\\varphi, \\rho)\\) donde \\(\\varphi = \\rho\\sigma\\) es la permutación de caras - Los vértices de la dual corresponden a las caras del original - Las aristas se preservan (misma \\(\\rho\\)) - Las caras de la dual corresponden a los vértices del original\n\n\nImplementación manual de la dual:\ndef construir_dual(R):\n    \"\"\"\n    Construye la dual de un ribbon graph.\n\n    Args:\n        R: RibbonGraph original\n\n    Returns:\n        RibbonGraph dual\n    \"\"\"\n    # Obtener permutaciones originales\n    sigma = R.sigma()\n    rho = R.rho()\n\n    # Calcular phi = rho * sigma (caras)\n    phi = rho * sigma\n\n    # La dual tiene sigma_dual = phi, rho_dual = rho\n    R_dual = RibbonGraph(phi, rho)\n\n    return R_dual\n\n# Ejemplo: esfera con 3 fronteras\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\nR_dual = construir_dual(R)\n\nprint(\"Original:\")\nprint(f\"  V = {len(R.sigma().cycle_tuples(singletons=True))}\")\nprint(f\"  E = {len(R.rho().cycle_tuples())}\")\nprint(f\"  F = {len((R.rho() * R.sigma()).cycle_tuples(singletons=True))}\")\nprint(f\"  g = {R.genus()}\")\n\nprint(\"\\nDual:\")\nprint(f\"  V = {len(R_dual.sigma().cycle_tuples(singletons=True))}\")\nprint(f\"  E = {len(R_dual.rho().cycle_tuples())}\")\nprint(f\"  F = {len((R_dual.rho() * R_dual.sigma()).cycle_tuples(singletons=True))}\")\nprint(f\"  g = {R_dual.genus()}\")\nPropiedad fundamental: \\[ V^* = F, \\quad E^* = E, \\quad F^* = V, \\quad g^* = g \\]\ndonde \\(*\\) denota la dual.\n\n\n\n\n\nEl método homology_basis() calcula una base para el primer grupo de homología \\(H_1(S, \\mathbb{Z})\\) de la superficie:\nsigma = PermutationGroupElement('(1,3,5)(2,4,6)')\nrho = PermutationGroupElement('(1,2)(3,4)(5,6)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Género: {R.genus()}\")\nbase = R.homology_basis()\nprint(f\"Número de ciclos en la base: {len(base)}\")\nprint(f\"Base de homología:\")\nfor i, ciclo in enumerate(base, 1):\n    print(f\"  Ciclo {i}: {ciclo}\")\n\n\n\n\n\n\nNotaInterpretación\n\n\n\nPara una superficie de género \\(g\\) con \\(b\\) componentes de frontera: \\[ \\text{rank}(H_1(S)) = 2g + b - 1 \\]\nCada ciclo en la base representa un “agujero” fundamental en la superficie.\n\n\n\n\n\n\nEl polinomio de Bollobás-Riordan es una generalización del polinomio de Tutte para grafos encajados en superficies orientables. Codifica información topológica y combinatoria del encaje.\n\n\n\n\n\n\n\n\nImportantePolinomio de Bollobás-Riordan\n\n\n\nPara un ribbon graph \\(G\\) con sistema de rotación \\((\\sigma, \\rho)\\), el polinomio de Bollobás-Riordan \\(R_G(x, y, z)\\) satisface:\n\nCaso base: Si \\(G\\) es un ciclo simple (una frontera): \\[ R_G(x, y, z) = y + z \\]\nCaso base: Si \\(G\\) consiste solo de loops disjuntos: \\[ R_G(x, y, z) = x^k (y+z) \\] donde \\(k\\) es el número de loops.\nRelación de contracción-borrado: Para una arista \\(e\\) que no es loop ni istmo: \\[ R_G(x,y,z) = R_{G/e}(x,y,z) + R_{G \\setminus e}(x,y,z) \\]\nPara un loop: Si \\(e\\) es un loop: \\[ R_G(x,y,z) = x \\cdot R_{G \\setminus e}(x,y,z) \\]\nPara un istmo: Si \\(e\\) es un istmo (corta una componente de frontera): \\[ R_G(x,y,z) = z \\cdot R_{G / e}(x,y,z) \\]\n\n\n\n\n\n\n\nGeneraliza el polinomio de Tutte:\n\nPara grafos planos: \\(R_G(x, 1, 1) = T_G(x, 1)\\)\nPara grafos en superficies cerradas: codifica información adicional sobre el género\n\nInvariante topológico:\n\nDepende del encaje, no solo del grafo abstracto\nCaptura información sobre el género y componentes de frontera\n\nEvaluaciones especiales:\n\n\\(R_G(1, 1, 1)\\) cuenta spanning subgraphs\nRelación con polinomios cromáticos generalizados\n\n\n\n\n\nSage no tiene implementación nativa del polinomio de Bollobás-Riordan para RibbonGraph, pero podemos implementarlo nosotros mismos:\nfrom sage.all import PolynomialRing, QQ\n\ndef es_loop(R, dart):\n    \"\"\"\n    Verifica si un dart pertenece a un loop (self-loop).\n    Un loop conecta un vértice consigo mismo.\n    \"\"\"\n    rho = R.rho()\n    pareja = rho(dart)\n\n    # Verificar si ambos darts están en el mismo ciclo de sigma\n    sigma = R.sigma()\n    for ciclo in sigma.cycle_tuples():\n        if dart in ciclo and pareja in ciclo:\n            return True\n    return False\n\ndef es_istmo(R, dart):\n    \"\"\"\n    Verifica si un dart pertenece a un istmo (bridge).\n    Un istmo, cuando se elimina, incrementa el número de componentes de frontera.\n    \"\"\"\n    # Método aproximado: un istmo no puede ser un loop\n    # y al eliminarlo debe aumentar las componentes de frontera\n    if es_loop(R, dart):\n        return False\n\n    # Crear una versión sin esta arista requeriría\n    # manipular las permutaciones manualmente\n    # Por simplicidad, asumimos que no es istmo si no es loop\n    # (una implementación completa requeriría más lógica)\n    return False\n\ndef bollobas_riordan(R, x, y, z, memo=None):\n    \"\"\"\n    Calcula el polinomio de Bollobás-Riordan de un ribbon graph.\n\n    Args:\n        R: RibbonGraph\n        x, y, z: variables del polinomio\n        memo: diccionario para memoización\n\n    Returns:\n        Polinomio en Q[x,y,z]\n    \"\"\"\n    if memo is None:\n        memo = {}\n\n    # Convertir ribbon graph a una clave hasheable\n    sigma_str = str(R.sigma())\n    rho_str = str(R.rho())\n    clave = (sigma_str, rho_str)\n\n    if clave in memo:\n        return memo[clave]\n\n    # Casos base\n    num_edges = len(R.rho().cycle_tuples())\n    num_boundaries = R.number_boundaries()\n\n    # Caso 1: Sin aristas (solo vértices aislados)\n    if num_edges == 0:\n        # Solo componentes de frontera triviales\n        resultado = (y + z)\n        memo[clave] = resultado\n        return resultado\n\n    # Caso 2: Un ciclo simple (una frontera, una arista)\n    if num_edges == 1 and num_boundaries == 1:\n        resultado = y + z\n        memo[clave] = resultado\n        return resultado\n\n    # Caso recursivo: elegir una arista\n    # Tomamos el primer dart disponible\n    darts = []\n    for ciclo in R.rho().cycle_tuples():\n        darts.extend(ciclo)\n\n    if not darts:\n        resultado = y + z\n        memo[clave] = resultado\n        return resultado\n\n    dart = darts[0]\n\n    # Verificar si es loop\n    if es_loop(R, dart):\n        # R_G = x * R_{G\\e}\n        # Para implementar G\\e necesitamos remover el ciclo de rho\n        # Esto es complejo, por ahora retornamos una aproximación\n        resultado = x * (y + z)  # Simplificación\n        memo[clave] = resultado\n        return resultado\n\n    # Caso general: contracción-borrado\n    # R_G = R_{G/e} + R_{G\\e}\n    try:\n        R_contraido = R.contract_edge(dart)\n        term_contraer = bollobas_riordan(R_contraido, x, y, z, memo)\n    except:\n        term_contraer = 0\n\n    # Para borrar necesitaríamos remover el dart de rho\n    # Implementación simplificada\n    term_borrar = y + z\n\n    resultado = term_contraer + term_borrar\n    memo[clave] = resultado\n    return resultado\n\n# Crear ring de polinomios\nR_poly.&lt;x, y, z&gt; = PolynomialRing(QQ)\n\n# Ejemplo: calcular para un ribbon graph simple\nsigma = PermutationGroupElement('(1,2)')\nrho = PermutationGroupElement('(1,2)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Ribbon graph: sigma={R.sigma()}, rho={R.rho()}\")\nprint(f\"Género: {R.genus()}\")\nprint(f\"Fronteras: {R.number_boundaries()}\")\nprint()\n\n# Calcular polinomio (versión simplificada)\npoly = bollobas_riordan(R, x, y, z)\nprint(f\"Polinomio de Bollobás-Riordan (aproximado): {poly}\")\n\n\n\n\n\n\nAdvertenciaNota sobre la Implementación\n\n\n\nLa implementación completa del polinomio de Bollobás-Riordan requiere: 1. Manipulación cuidadosa de las permutaciones para borrar aristas 2. Detección robusta de loops e istmos 3. Memoización eficiente para evitar recálculos 4. Manejo de casos especiales (múltiples componentes, etc.)\nLa versión presentada es una implementación pedagógica simplificada que ilustra la estructura recursiva del polinomio.\n\n\n\n\n\nUna implementación más robusta utilizaría representaciones alternativas:\ndef ribbon_to_graph_data(R):\n    \"\"\"\n    Extrae información combinatoria de un ribbon graph.\n\n    Returns:\n        dict con vértices, aristas, género, etc.\n    \"\"\"\n    sigma_cycles = R.sigma().cycle_tuples(singletons=True)\n    rho_cycles = R.rho().cycle_tuples()\n    phi = R.rho() * R.sigma()\n    phi_cycles = phi.cycle_tuples(singletons=True)\n\n    return {\n        'vertices': len(sigma_cycles),\n        'edges': len(rho_cycles),\n        'faces': len(phi_cycles),\n        'genus': R.genus(),\n        'boundaries': R.number_boundaries(),\n        'euler_char': len(sigma_cycles) - len(rho_cycles) + len(phi_cycles)\n    }\n\n# Ejemplo de uso\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\ninfo = ribbon_to_graph_data(R)\nprint(\"Información del ribbon graph:\")\nfor clave, valor in info.items():\n    print(f\"  {clave}: {valor}\")\n\n\n\n\n\n\n\n\n\n\n\nTipEjercicio 1: Dualidad\n\n\n\nImplementa una función que calcule la dual de un ribbon graph y verifica que: 1. \\((G^*)^* = G\\) 2. \\(V^* = F\\) y \\(F^* = V\\) 3. \\(g^* = g\\)\nPrueba con varios ejemplos: K₃ en la esfera, toro con un vértice, etc.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Contracción Iterada\n\n\n\nToma un grafo completo K₄ encajado en una superficie y: 1. Contrae aristas una por una 2. Registra el género después de cada contracción 3. Analiza cómo evoluciona el género\n¿Cuándo la contracción preserva el género? ¿Cuándo lo cambia?\n\n\n\n\n\n\n\n\nTipEjercicio 3: Polinomio de Bollobás-Riordan\n\n\n\nMejora la implementación del polinomio de Bollobás-Riordan para: 1. Manejar correctamente la operación de borrado de aristas 2. Detectar loops e istmos de forma robusta 3. Implementar memoización eficiente\nCalcula el polinomio para grafos pequeños (K₃, K₄, bouquet de círculos).\n\n\n\n\n\n\n\n\nTipEjercicio 4: Base de Homología\n\n\n\nPara un toro con múltiples vértices: 1. Calcula la base de homología usando homology_basis() 2. Visualiza los ciclos fundamentales 3. Verifica que rank(H₁) = 2g + b - 1\nExperimenta con diferentes encajes del mismo grafo y compara las bases.\n\n\n\n\n\n\n\nOperaciones: Contracción, reducción y dualidad son transformaciones fundamentales\nHerramientas de Sage: RibbonGraph proporciona métodos poderosos para análisis topológico\nHomología: La base de homología captura los “agujeros” de la superficie\nPolinomio de Bollobás-Riordan: Generaliza el polinomio de Tutte a superficies\nImplementación: Requiere manipulación cuidadosa de permutaciones y recursión\n\nEl polinomio de Bollobás-Riordan es un área activa de investigación con conexiones a: - Teoría de nudos (polinomios de nudos) - Física matemática (modelos de Potts) - Combinatoria enumerativa\n\n\n\n\n\nBollobás, B., & Riordan, O. (2002). “A polynomial of graphs on surfaces”. Mathematische Annalen.\nChmutov, S. (2009). “Generalized duality for graphs on surfaces and the signed Bollobás–Riordan polynomial”.\nEllis-Monaghan, J. A., & Moffatt, I. (2013). “Graphs on Surfaces: Dualities, Polynomials, and Knots”.\nSageMath - Ribbon Graphs Documentation"
  },
  {
    "objectID": "capitulos/05-ejemplos.html#herramientas-de-la-clase-ribbongraph-en-sage",
    "href": "capitulos/05-ejemplos.html#herramientas-de-la-clase-ribbongraph-en-sage",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "La clase RibbonGraph en SageMath proporciona herramientas poderosas para analizar sistemas de rotación:\n\n\nfrom sage.all import RibbonGraph, PermutationGroupElement\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Acceso a las permutaciones\nprint(R.sigma())          # (1,2,3,4)\nprint(R.rho())            # (1,2)(3,4)\n\n# Invariantes topológicos\nprint(R.genus())          # 0\nprint(R.number_boundaries())  # 3\nprint(R.boundary())       # Lista de fronteras\n\n# Base de homología\nprint(R.homology_basis()) # Ciclos fundamentales\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\nsigma()\nDevuelve la permutación de vértices\n\n\nrho()\nDevuelve la permutación de aristas\n\n\ngenus()\nCalcula el género de la superficie\n\n\nnumber_boundaries()\nCuenta componentes de frontera\n\n\nboundary()\nDevuelve las secuencias de darts en cada frontera\n\n\nhomology_basis()\nBase para H₁(superficie)\n\n\ncontract_edge(d)\nContrae la arista que contiene el dart d\n\n\nreduced()\nElimina vértices de valencia 1"
  },
  {
    "objectID": "capitulos/05-ejemplos.html#operaciones-sobre-ribbon-graphs",
    "href": "capitulos/05-ejemplos.html#operaciones-sobre-ribbon-graphs",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "La contracción de una arista consiste en colapsar la arista a un punto, fusionando sus vértices extremos.\n\n\n\n\n\n\nNotaDefinición: Contracción\n\n\n\nDada una arista \\(e = \\{d, \\rho(d)\\}\\) en un ribbon graph, la contracción \\(G/e\\) resulta en: - Eliminar la arista \\(e\\) - Fusionar los vértices en los extremos de \\(e\\) - Preservar el orden cíclico de las aristas restantes\n\n\nEjemplo en Sage:\n# Triángulo K₃ encajado\nsigma = PermutationGroupElement('(1,6)(2,3)(4,5)')\nrho = PermutationGroupElement('(1,2)(3,4)(5,6)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Original: V={len(R.sigma().cycle_tuples(singletons=True))}, \"\n      f\"E={len(R.rho().cycle_tuples())}, \"\n      f\"g={R.genus()}\")\n\n# Contraer la arista que contiene el dart 1\nR_contraido = R.contract_edge(1)\nprint(f\"Contraído: V={len(R_contraido.sigma().cycle_tuples(singletons=True))}, \"\n      f\"E={len(R_contraido.rho().cycle_tuples())}, \"\n      f\"g={R_contraido.genus()}\")\nPropiedades: - La contracción puede cambiar el género - \\(\\chi(G/e) = \\chi(G) + 1\\) si \\(e\\) no es un loop - Útil para definir invariantes recursivos (como el polinomio de Tutte)\n\n\n\nEl método reduced() elimina sistemáticamente vértices de valencia 1:\n# Grafo con un vértice colgante\nsigma = PermutationGroupElement('(1,2,3)(4,5,6)(7,8,9)(10,11,12)(13,14,15)(16,17,18,19)')\nrho = PermutationGroupElement('(1,16)(2,13)(3,10)(4,17)(5,14)(6,11)(7,18)(8,15)(9,12)(19,20)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Original: {len(R.sigma().cycle_tuples(singletons=True))} vértices\")\nprint(f\"          {len(R.rho().cycle_tuples())} aristas\")\n\nR_reducido = R.reduced()\nprint(f\"Reducido: {len(R_reducido.sigma().cycle_tuples(singletons=True))} vértices\")\nprint(f\"          {len(R_reducido.rho().cycle_tuples())} aristas\")\n\n\n\n\n\n\nTipUso de reduced()\n\n\n\nLa reducción es útil para: - Simplificar ribbon graphs antes de calcular invariantes - Remover “hojas” que no contribuyen a la topología - Encontrar el “núcleo” topológico del grafo\n\n\n\n\n\nLa dual de un ribbon graph intercambia roles entre vértices y caras.\n\n\n\n\n\n\nImportanteConstrucción de la Dual\n\n\n\nDado un ribbon graph con sistema de rotación \\((\\sigma, \\rho)\\): - La dual tiene sistema \\((\\varphi, \\rho)\\) donde \\(\\varphi = \\rho\\sigma\\) es la permutación de caras - Los vértices de la dual corresponden a las caras del original - Las aristas se preservan (misma \\(\\rho\\)) - Las caras de la dual corresponden a los vértices del original\n\n\nImplementación manual de la dual:\ndef construir_dual(R):\n    \"\"\"\n    Construye la dual de un ribbon graph.\n\n    Args:\n        R: RibbonGraph original\n\n    Returns:\n        RibbonGraph dual\n    \"\"\"\n    # Obtener permutaciones originales\n    sigma = R.sigma()\n    rho = R.rho()\n\n    # Calcular phi = rho * sigma (caras)\n    phi = rho * sigma\n\n    # La dual tiene sigma_dual = phi, rho_dual = rho\n    R_dual = RibbonGraph(phi, rho)\n\n    return R_dual\n\n# Ejemplo: esfera con 3 fronteras\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\nR_dual = construir_dual(R)\n\nprint(\"Original:\")\nprint(f\"  V = {len(R.sigma().cycle_tuples(singletons=True))}\")\nprint(f\"  E = {len(R.rho().cycle_tuples())}\")\nprint(f\"  F = {len((R.rho() * R.sigma()).cycle_tuples(singletons=True))}\")\nprint(f\"  g = {R.genus()}\")\n\nprint(\"\\nDual:\")\nprint(f\"  V = {len(R_dual.sigma().cycle_tuples(singletons=True))}\")\nprint(f\"  E = {len(R_dual.rho().cycle_tuples())}\")\nprint(f\"  F = {len((R_dual.rho() * R_dual.sigma()).cycle_tuples(singletons=True))}\")\nprint(f\"  g = {R_dual.genus()}\")\nPropiedad fundamental: \\[ V^* = F, \\quad E^* = E, \\quad F^* = V, \\quad g^* = g \\]\ndonde \\(*\\) denota la dual."
  },
  {
    "objectID": "capitulos/05-ejemplos.html#base-de-homología",
    "href": "capitulos/05-ejemplos.html#base-de-homología",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "El método homology_basis() calcula una base para el primer grupo de homología \\(H_1(S, \\mathbb{Z})\\) de la superficie:\nsigma = PermutationGroupElement('(1,3,5)(2,4,6)')\nrho = PermutationGroupElement('(1,2)(3,4)(5,6)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Género: {R.genus()}\")\nbase = R.homology_basis()\nprint(f\"Número de ciclos en la base: {len(base)}\")\nprint(f\"Base de homología:\")\nfor i, ciclo in enumerate(base, 1):\n    print(f\"  Ciclo {i}: {ciclo}\")\n\n\n\n\n\n\nNotaInterpretación\n\n\n\nPara una superficie de género \\(g\\) con \\(b\\) componentes de frontera: \\[ \\text{rank}(H_1(S)) = 2g + b - 1 \\]\nCada ciclo en la base representa un “agujero” fundamental en la superficie."
  },
  {
    "objectID": "capitulos/05-ejemplos.html#el-polinomio-de-bollobás-riordan",
    "href": "capitulos/05-ejemplos.html#el-polinomio-de-bollobás-riordan",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "El polinomio de Bollobás-Riordan es una generalización del polinomio de Tutte para grafos encajados en superficies orientables. Codifica información topológica y combinatoria del encaje.\n\n\n\n\n\n\n\n\nImportantePolinomio de Bollobás-Riordan\n\n\n\nPara un ribbon graph \\(G\\) con sistema de rotación \\((\\sigma, \\rho)\\), el polinomio de Bollobás-Riordan \\(R_G(x, y, z)\\) satisface:\n\nCaso base: Si \\(G\\) es un ciclo simple (una frontera): \\[ R_G(x, y, z) = y + z \\]\nCaso base: Si \\(G\\) consiste solo de loops disjuntos: \\[ R_G(x, y, z) = x^k (y+z) \\] donde \\(k\\) es el número de loops.\nRelación de contracción-borrado: Para una arista \\(e\\) que no es loop ni istmo: \\[ R_G(x,y,z) = R_{G/e}(x,y,z) + R_{G \\setminus e}(x,y,z) \\]\nPara un loop: Si \\(e\\) es un loop: \\[ R_G(x,y,z) = x \\cdot R_{G \\setminus e}(x,y,z) \\]\nPara un istmo: Si \\(e\\) es un istmo (corta una componente de frontera): \\[ R_G(x,y,z) = z \\cdot R_{G / e}(x,y,z) \\]\n\n\n\n\n\n\n\nGeneraliza el polinomio de Tutte:\n\nPara grafos planos: \\(R_G(x, 1, 1) = T_G(x, 1)\\)\nPara grafos en superficies cerradas: codifica información adicional sobre el género\n\nInvariante topológico:\n\nDepende del encaje, no solo del grafo abstracto\nCaptura información sobre el género y componentes de frontera\n\nEvaluaciones especiales:\n\n\\(R_G(1, 1, 1)\\) cuenta spanning subgraphs\nRelación con polinomios cromáticos generalizados\n\n\n\n\n\nSage no tiene implementación nativa del polinomio de Bollobás-Riordan para RibbonGraph, pero podemos implementarlo nosotros mismos:\nfrom sage.all import PolynomialRing, QQ\n\ndef es_loop(R, dart):\n    \"\"\"\n    Verifica si un dart pertenece a un loop (self-loop).\n    Un loop conecta un vértice consigo mismo.\n    \"\"\"\n    rho = R.rho()\n    pareja = rho(dart)\n\n    # Verificar si ambos darts están en el mismo ciclo de sigma\n    sigma = R.sigma()\n    for ciclo in sigma.cycle_tuples():\n        if dart in ciclo and pareja in ciclo:\n            return True\n    return False\n\ndef es_istmo(R, dart):\n    \"\"\"\n    Verifica si un dart pertenece a un istmo (bridge).\n    Un istmo, cuando se elimina, incrementa el número de componentes de frontera.\n    \"\"\"\n    # Método aproximado: un istmo no puede ser un loop\n    # y al eliminarlo debe aumentar las componentes de frontera\n    if es_loop(R, dart):\n        return False\n\n    # Crear una versión sin esta arista requeriría\n    # manipular las permutaciones manualmente\n    # Por simplicidad, asumimos que no es istmo si no es loop\n    # (una implementación completa requeriría más lógica)\n    return False\n\ndef bollobas_riordan(R, x, y, z, memo=None):\n    \"\"\"\n    Calcula el polinomio de Bollobás-Riordan de un ribbon graph.\n\n    Args:\n        R: RibbonGraph\n        x, y, z: variables del polinomio\n        memo: diccionario para memoización\n\n    Returns:\n        Polinomio en Q[x,y,z]\n    \"\"\"\n    if memo is None:\n        memo = {}\n\n    # Convertir ribbon graph a una clave hasheable\n    sigma_str = str(R.sigma())\n    rho_str = str(R.rho())\n    clave = (sigma_str, rho_str)\n\n    if clave in memo:\n        return memo[clave]\n\n    # Casos base\n    num_edges = len(R.rho().cycle_tuples())\n    num_boundaries = R.number_boundaries()\n\n    # Caso 1: Sin aristas (solo vértices aislados)\n    if num_edges == 0:\n        # Solo componentes de frontera triviales\n        resultado = (y + z)\n        memo[clave] = resultado\n        return resultado\n\n    # Caso 2: Un ciclo simple (una frontera, una arista)\n    if num_edges == 1 and num_boundaries == 1:\n        resultado = y + z\n        memo[clave] = resultado\n        return resultado\n\n    # Caso recursivo: elegir una arista\n    # Tomamos el primer dart disponible\n    darts = []\n    for ciclo in R.rho().cycle_tuples():\n        darts.extend(ciclo)\n\n    if not darts:\n        resultado = y + z\n        memo[clave] = resultado\n        return resultado\n\n    dart = darts[0]\n\n    # Verificar si es loop\n    if es_loop(R, dart):\n        # R_G = x * R_{G\\e}\n        # Para implementar G\\e necesitamos remover el ciclo de rho\n        # Esto es complejo, por ahora retornamos una aproximación\n        resultado = x * (y + z)  # Simplificación\n        memo[clave] = resultado\n        return resultado\n\n    # Caso general: contracción-borrado\n    # R_G = R_{G/e} + R_{G\\e}\n    try:\n        R_contraido = R.contract_edge(dart)\n        term_contraer = bollobas_riordan(R_contraido, x, y, z, memo)\n    except:\n        term_contraer = 0\n\n    # Para borrar necesitaríamos remover el dart de rho\n    # Implementación simplificada\n    term_borrar = y + z\n\n    resultado = term_contraer + term_borrar\n    memo[clave] = resultado\n    return resultado\n\n# Crear ring de polinomios\nR_poly.&lt;x, y, z&gt; = PolynomialRing(QQ)\n\n# Ejemplo: calcular para un ribbon graph simple\nsigma = PermutationGroupElement('(1,2)')\nrho = PermutationGroupElement('(1,2)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Ribbon graph: sigma={R.sigma()}, rho={R.rho()}\")\nprint(f\"Género: {R.genus()}\")\nprint(f\"Fronteras: {R.number_boundaries()}\")\nprint()\n\n# Calcular polinomio (versión simplificada)\npoly = bollobas_riordan(R, x, y, z)\nprint(f\"Polinomio de Bollobás-Riordan (aproximado): {poly}\")\n\n\n\n\n\n\nAdvertenciaNota sobre la Implementación\n\n\n\nLa implementación completa del polinomio de Bollobás-Riordan requiere: 1. Manipulación cuidadosa de las permutaciones para borrar aristas 2. Detección robusta de loops e istmos 3. Memoización eficiente para evitar recálculos 4. Manejo de casos especiales (múltiples componentes, etc.)\nLa versión presentada es una implementación pedagógica simplificada que ilustra la estructura recursiva del polinomio.\n\n\n\n\n\nUna implementación más robusta utilizaría representaciones alternativas:\ndef ribbon_to_graph_data(R):\n    \"\"\"\n    Extrae información combinatoria de un ribbon graph.\n\n    Returns:\n        dict con vértices, aristas, género, etc.\n    \"\"\"\n    sigma_cycles = R.sigma().cycle_tuples(singletons=True)\n    rho_cycles = R.rho().cycle_tuples()\n    phi = R.rho() * R.sigma()\n    phi_cycles = phi.cycle_tuples(singletons=True)\n\n    return {\n        'vertices': len(sigma_cycles),\n        'edges': len(rho_cycles),\n        'faces': len(phi_cycles),\n        'genus': R.genus(),\n        'boundaries': R.number_boundaries(),\n        'euler_char': len(sigma_cycles) - len(rho_cycles) + len(phi_cycles)\n    }\n\n# Ejemplo de uso\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\ninfo = ribbon_to_graph_data(R)\nprint(\"Información del ribbon graph:\")\nfor clave, valor in info.items():\n    print(f\"  {clave}: {valor}\")"
  },
  {
    "objectID": "capitulos/05-ejemplos.html#ejercicios",
    "href": "capitulos/05-ejemplos.html#ejercicios",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "TipEjercicio 1: Dualidad\n\n\n\nImplementa una función que calcule la dual de un ribbon graph y verifica que: 1. \\((G^*)^* = G\\) 2. \\(V^* = F\\) y \\(F^* = V\\) 3. \\(g^* = g\\)\nPrueba con varios ejemplos: K₃ en la esfera, toro con un vértice, etc.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Contracción Iterada\n\n\n\nToma un grafo completo K₄ encajado en una superficie y: 1. Contrae aristas una por una 2. Registra el género después de cada contracción 3. Analiza cómo evoluciona el género\n¿Cuándo la contracción preserva el género? ¿Cuándo lo cambia?\n\n\n\n\n\n\n\n\nTipEjercicio 3: Polinomio de Bollobás-Riordan\n\n\n\nMejora la implementación del polinomio de Bollobás-Riordan para: 1. Manejar correctamente la operación de borrado de aristas 2. Detectar loops e istmos de forma robusta 3. Implementar memoización eficiente\nCalcula el polinomio para grafos pequeños (K₃, K₄, bouquet de círculos).\n\n\n\n\n\n\n\n\nTipEjercicio 4: Base de Homología\n\n\n\nPara un toro con múltiples vértices: 1. Calcula la base de homología usando homology_basis() 2. Visualiza los ciclos fundamentales 3. Verifica que rank(H₁) = 2g + b - 1\nExperimenta con diferentes encajes del mismo grafo y compara las bases."
  },
  {
    "objectID": "capitulos/05-ejemplos.html#resumen",
    "href": "capitulos/05-ejemplos.html#resumen",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "Operaciones: Contracción, reducción y dualidad son transformaciones fundamentales\nHerramientas de Sage: RibbonGraph proporciona métodos poderosos para análisis topológico\nHomología: La base de homología captura los “agujeros” de la superficie\nPolinomio de Bollobás-Riordan: Generaliza el polinomio de Tutte a superficies\nImplementación: Requiere manipulación cuidadosa de permutaciones y recursión\n\nEl polinomio de Bollobás-Riordan es un área activa de investigación con conexiones a: - Teoría de nudos (polinomios de nudos) - Física matemática (modelos de Potts) - Combinatoria enumerativa"
  },
  {
    "objectID": "capitulos/05-ejemplos.html#referencias",
    "href": "capitulos/05-ejemplos.html#referencias",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "Bollobás, B., & Riordan, O. (2002). “A polynomial of graphs on surfaces”. Mathematische Annalen.\nChmutov, S. (2009). “Generalized duality for graphs on surfaces and the signed Bollobás–Riordan polynomial”.\nEllis-Monaghan, J. A., & Moffatt, I. (2013). “Graphs on Surfaces: Dualities, Polynomials, and Knots”.\nSageMath - Ribbon Graphs Documentation"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "",
    "text": "Un enfoque combinatorio para entender encajes de grafos en superficies orientables.",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#sobre-este-proyecto",
    "href": "index.html#sobre-este-proyecto",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "Sobre este proyecto",
    "text": "Sobre este proyecto\nLos sistemas de rotación son pares de permutaciones \\((\\sigma, \\rho)\\) que codifican completamente un encaje celular de un grafo en una superficie orientable. Este proyecto explora la correspondencia biunívoca entre sistemas de rotación y ribbon graphs, establecida por el Teorema de Heffter-Edmonds.\n\nIdea principal\nUn sistema de rotación \\((\\sigma, \\rho)\\) contiene toda la información necesaria para:\n\nReconstruir el grafo subyacente (vértices y aristas)\nDeterminar el orden cíclico de semiaristas alrededor de cada vértice\nCalcular las caras mediante la permutación \\(\\varphi = \\rho\\sigma\\)\nObtener invariantes topológicos: género, característica de Euler, fronteras\nConstruir la superficie completa mediante engrosamiento (thickening)\n\nResultado fundamental: Álgebra de permutaciones ↔︎ Topología de superficies",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#contenido",
    "href": "index.html#contenido",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "Contenido",
    "text": "Contenido\n\n1. Sistemas de Rotación\nIntroducción a los sistemas de rotación como modelo combinatorio de grafos encajados.\n\nDefinición mediante permutaciones \\(\\sigma\\) y \\(\\rho\\)\nSemiaristas (darts) y orden cíclico\nEjemplos básicos con código SageMath\nConstrucción en Sage: RibbonGraph(sigma, rho)\n\n\n\n2. Trazado de Caras\nAlgoritmo para determinar las caras de un encaje celular mediante sistemas de rotación.\n\nPermutación de caras \\(\\varphi = \\rho\\sigma\\) (convención SageMath)\nAlgoritmo de trazado (cruzar → girar)\nEjemplos: esfera vs. toro\nCorrespondencia caras ↔︎ fronteras\nVerificación con código SageMath\n\n\n\n3. Invariantes Topológicos\nCálculo de invariantes directamente desde las permutaciones.\n\nConteo directo: V (ciclos de σ), E (ciclos de ρ), F (ciclos de φ)\nCaracterística de Euler: \\(\\chi = V - E + F\\)\nGénero de superficies: \\(g = 1 - \\frac{\\chi + b}{2}\\)\nComponentes de frontera y su interpretación\nProceso de engrosamiento (thickening)\nVerificación experimental con Sage\n\n\n\n4. Teorema de Heffter-Edmonds\nEl teorema fundamental que establece la correspondencia biunívoca.\n\nEquivalencia de sistemas de rotación (isomorfismos)\nEquivalencia de encajes (homeomorfismos)\nTeorema fuerte: correspondencia 1:1 entre clases de equivalencia\nConstrucción directa: \\((\\sigma, \\rho) \\to\\) ribbon graph\nConstrucción inversa: ribbon graph \\(\\to (\\sigma, \\rho)\\)\nOrientabilidad y limitaciones del modelo\n\n\n\n5. Propiedades Adicionales y Polinomios\nOperaciones avanzadas y el polinomio de Bollobás-Riordan.\n\nOperaciones: contracción, reducción, dualidad\nHerramientas de RibbonGraph en Sage\nBase de homología H₁(superficie)\nPolinomio de Bollobás-Riordan\nImplementación en SageMath",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#flujo-del-curso",
    "href": "index.html#flujo-del-curso",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "Flujo del Curso",
    "text": "Flujo del Curso\ngraph LR\n    A[1. Sistemas de Rotación] --&gt; B[2. Trazado de Caras]\n    B --&gt; C[3. Invariantes]\n    C --&gt; D[4. Heffter-Edmonds]\n    D --&gt; E[5. Propiedades Avanzadas]\n\n    style A fill:#e3f2fd\n    style B fill:#e8f5e9\n    style C fill:#fff3e0\n    style D fill:#fce4ec\n    style E fill:#f3e5f5\nProgresión natural: 1. Definición → Permutaciones \\((\\sigma, \\rho)\\) 2. Algoritmo → Calcular caras con \\(\\varphi = \\rho\\sigma\\) 3. Invariantes → Extraer χ, g, componentes de frontera 4. Teoría → Correspondencia biunívoca (Heffter-Edmonds) 5. Aplicaciones → Operaciones y polinomios",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#herramientas",
    "href": "index.html#herramientas",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "Herramientas",
    "text": "Herramientas\nEste proyecto utiliza:\n\nSageMath 10.7 - Cálculos con RibbonGraph, PermutationGroupElement\nPython 3.13 - Scripts de análisis y visualización\nQuarto - Documentación interactiva con bloques de código ejecutables",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#referencias",
    "href": "index.html#referencias",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "Referencias",
    "text": "Referencias\n\nGross, J. L., & Tucker, T. W. (1987). Topological Graph Theory\nLando, S. K., & Zvonkin, A. K. (2004). Graphs on Surfaces\nEdmonds, J. (1960). A combinatorial representation for polyhedral surfaces\nSageMath - Ribbon Graphs Documentation\n\n\n\nJosé Luis León • 2026",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "tutoriales/02-visualizacion.html",
    "href": "tutoriales/02-visualizacion.html",
    "title": "Tutorial 2: Visualización Paso a Paso",
    "section": "",
    "text": "Un ribbon graph se construye mediante un proceso de engrosamiento que transforma un grafo abstracto en una superficie con frontera. Este proceso se visualiza en 5 pasos.\n\n\n\n\nComenzamos con el grafo abstracto: - Vértices representados como puntos rojos - Aristas como líneas negras - NO tiene estructura ribbon todavía\n\n# Cargar el visualizador\nload('../scripts/ribbongraph_visualizer.sage')\n\n# Crear ribbon graph\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\n\n# Generar solo paso 1\nviz.paso_1_grafo_base(save_to='paso1.png')\n\n\n\n\nPaso 1: Grafo Base\n\n\n\n\n\n\n\n\nNota\n\n\n\nEn este paso solo vemos la topología del grafo. Los vértices son puntos sin extensión.\n\n\n\n\n\n\nLas aristas se dividen en dardos (half-edges):\n\nCada arista → 2 dardos\nLos dardos se colocan en el borde de los vértices\nLos números muestran el orden cíclico dado por σ\n\n\nviz.paso_2_mostrar_dardos(save_to='paso2.png')\n\n\n\n\nPaso 2: Dardos\n\n\n\n\n\n\n\n\nImportanteOrden Cíclico\n\n\n\nLos dardos alrededor de cada vértice siguen el orden definido por σ: - Vértice 0: dardos {1, 2, 3} - Vértice 1: dardos {4, 5, 6}\n\n\n\n\n\n\nLos vértices se convierten en discos:\n\nPunto → Disco amarillo\nLos dardos aparecen en el borde del disco\nSe ve claramente el orden cíclico\n\n\nviz.paso_3_engrosar_vertices(save_to='paso3.png')\n\n\n\n\nPaso 3: Vértices Engrosados\n\n\n\n\n\n\n\n\nTip¿Por qué “engrosar”?\n\n\n\nEl engrosamiento convierte objetos 0-dimensionales (puntos) en objetos 2-dimensionales (discos). Esto es clave para obtener una superficie.\n\n\n\n\n\n\nLas aristas se convierten en cintas (ribbons):\n\nLínea → Polígono azul (cinta)\nLas cintas conectan pares de dardos según ρ\n¡Esta es la superficie ribbon completa!\n\n\nviz.paso_4_ribbon_completo(save_to='paso4.png')\n\n\n\n\nPaso 4: Ribbon Completo\n\n\n\n\n\n\n\n\nImportanteSuperficie Ribbon\n\n\n\nEn este paso ya tenemos una superficie completa: - Discos (de los vértices) - Cintas (de las aristas) - Al “pegar” todo formamos una superficie topológica\n\n\n\n\n\n\nFinalmente, visualizamos las fronteras:\n\nUsa el método boundary() de SageMath\nLas fronteras se dibujan como curvas gruesas\nEl número de componentes es el invariante ‘b’\n\n\nviz.paso_5_fronteras(save_to='paso5.png')\n\n\n\n\nPaso 5: Fronteras\n\n\n\n\n\n\n\n\nNotaComponentes de Frontera\n\n\n\nPara este ejemplo: b = 1 - Una sola curva cerrada forma la frontera - Es el “borde” de la superficie ribbon\n\n\n\n\n\n\n\nPara generar los 5 pasos automáticamente:\n\nload('../scripts/ribbongraph_visualizer.sage')\n\n# Crear ribbon graph\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\n\n# Generar todas las imágenes\narchivos = viz.generar_secuencia_completa(\n    output_dir='../outputs/imagenes',\n    prefix='mi_ejemplo_'\n)\n\nprint(\"Archivos generados:\")\nfor f in archivos:\n    print(f\"  - {f}\")\n\n\n\n\n\n\n\n\n\n\nPaso 1: Grafo Base\n\n\n\n\n\n\n\nPaso 4: Ribbon Completo\n\n\n\n\n\nLa transformación es clara: de un grafo abstracto a una superficie ribbon completa.\n\n\n\n\n\nUn vértice con 2 self-loops:\n\n\n\n\n\n\nGrafo Base\n\n\n\n\n\n\n\nRibbon\n\n\n\n\n\n\nGénero: 0 (esfera)\nFronteras: 3 componentes\n\n\n\n\n\n\n\n\n\n\nGrafo Base\n\n\n\n\n\n\n\nRibbon\n\n\n\n\n\n\nGénero: 0 (esfera)\nFronteras: 2 componentes\n\n\n\n\n\nPuedes ajustar los parámetros:\n\n# Parámetros personalizados\nviz.paso_3_engrosar_vertices(\n    radio_vertice=0.5,    # Discos más grandes\n    save_to='paso3_custom.png'\n)\n\nviz.paso_4_ribbon_completo(\n    radio_vertice=0.5,\n    ancho_cinta=0.25,      # Cintas más anchas\n    save_to='paso4_custom.png'\n)\n\n\n\n\n\n\n\n\n\n\nTip📝 Ejercicio 2.1\n\n\n\nGenera la secuencia completa para el ribbon graph: - σ = (1,2,3,4) - ρ = (1,2)(3,4)\nIdentifica: 1. ¿Cuántos vértices tiene? 2. ¿Cuántas aristas? 3. ¿Cuántas componentes de frontera?\n\n\nVer solución\n\nviz = RibbonGraphVisualizer('(1,2,3,4)', '(1,2)(3,4)')\ninv = viz.invariantes()\nprint(inv)\n\n# Generar visualizaciones\nviz.generar_secuencia_completa(prefix='ejercicio2_')\nRespuestas: 1. 1 vértice 2. 2 aristas (ambas self-loops) 3. 3 componentes de frontera\n\n\n\n\n\n\nEn el Tutorial 3 estudiaremos en detalle los invariantes topológicos.\n\n\n\n\nScripts del proyecto\nTutorial 1: Introducción"
  },
  {
    "objectID": "tutoriales/02-visualizacion.html#los-5-pasos",
    "href": "tutoriales/02-visualizacion.html#los-5-pasos",
    "title": "Tutorial 2: Visualización Paso a Paso",
    "section": "",
    "text": "Comenzamos con el grafo abstracto: - Vértices representados como puntos rojos - Aristas como líneas negras - NO tiene estructura ribbon todavía\n\n# Cargar el visualizador\nload('../scripts/ribbongraph_visualizer.sage')\n\n# Crear ribbon graph\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\n\n# Generar solo paso 1\nviz.paso_1_grafo_base(save_to='paso1.png')\n\n\n\n\nPaso 1: Grafo Base\n\n\n\n\n\n\n\n\nNota\n\n\n\nEn este paso solo vemos la topología del grafo. Los vértices son puntos sin extensión.\n\n\n\n\n\n\nLas aristas se dividen en dardos (half-edges):\n\nCada arista → 2 dardos\nLos dardos se colocan en el borde de los vértices\nLos números muestran el orden cíclico dado por σ\n\n\nviz.paso_2_mostrar_dardos(save_to='paso2.png')\n\n\n\n\nPaso 2: Dardos\n\n\n\n\n\n\n\n\nImportanteOrden Cíclico\n\n\n\nLos dardos alrededor de cada vértice siguen el orden definido por σ: - Vértice 0: dardos {1, 2, 3} - Vértice 1: dardos {4, 5, 6}\n\n\n\n\n\n\nLos vértices se convierten en discos:\n\nPunto → Disco amarillo\nLos dardos aparecen en el borde del disco\nSe ve claramente el orden cíclico\n\n\nviz.paso_3_engrosar_vertices(save_to='paso3.png')\n\n\n\n\nPaso 3: Vértices Engrosados\n\n\n\n\n\n\n\n\nTip¿Por qué “engrosar”?\n\n\n\nEl engrosamiento convierte objetos 0-dimensionales (puntos) en objetos 2-dimensionales (discos). Esto es clave para obtener una superficie.\n\n\n\n\n\n\nLas aristas se convierten en cintas (ribbons):\n\nLínea → Polígono azul (cinta)\nLas cintas conectan pares de dardos según ρ\n¡Esta es la superficie ribbon completa!\n\n\nviz.paso_4_ribbon_completo(save_to='paso4.png')\n\n\n\n\nPaso 4: Ribbon Completo\n\n\n\n\n\n\n\n\nImportanteSuperficie Ribbon\n\n\n\nEn este paso ya tenemos una superficie completa: - Discos (de los vértices) - Cintas (de las aristas) - Al “pegar” todo formamos una superficie topológica\n\n\n\n\n\n\nFinalmente, visualizamos las fronteras:\n\nUsa el método boundary() de SageMath\nLas fronteras se dibujan como curvas gruesas\nEl número de componentes es el invariante ‘b’\n\n\nviz.paso_5_fronteras(save_to='paso5.png')\n\n\n\n\nPaso 5: Fronteras\n\n\n\n\n\n\n\n\nNotaComponentes de Frontera\n\n\n\nPara este ejemplo: b = 1 - Una sola curva cerrada forma la frontera - Es el “borde” de la superficie ribbon"
  },
  {
    "objectID": "tutoriales/02-visualizacion.html#generar-la-secuencia-completa",
    "href": "tutoriales/02-visualizacion.html#generar-la-secuencia-completa",
    "title": "Tutorial 2: Visualización Paso a Paso",
    "section": "",
    "text": "Para generar los 5 pasos automáticamente:\n\nload('../scripts/ribbongraph_visualizer.sage')\n\n# Crear ribbon graph\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\n\n# Generar todas las imágenes\narchivos = viz.generar_secuencia_completa(\n    output_dir='../outputs/imagenes',\n    prefix='mi_ejemplo_'\n)\n\nprint(\"Archivos generados:\")\nfor f in archivos:\n    print(f\"  - {f}\")"
  },
  {
    "objectID": "tutoriales/02-visualizacion.html#comparación-lado-a-lado",
    "href": "tutoriales/02-visualizacion.html#comparación-lado-a-lado",
    "title": "Tutorial 2: Visualización Paso a Paso",
    "section": "",
    "text": "Paso 1: Grafo Base\n\n\n\n\n\n\n\nPaso 4: Ribbon Completo\n\n\n\n\n\nLa transformación es clara: de un grafo abstracto a una superficie ribbon completa."
  },
  {
    "objectID": "tutoriales/02-visualizacion.html#otros-ejemplos",
    "href": "tutoriales/02-visualizacion.html#otros-ejemplos",
    "title": "Tutorial 2: Visualización Paso a Paso",
    "section": "",
    "text": "Un vértice con 2 self-loops:\n\n\n\n\n\n\nGrafo Base\n\n\n\n\n\n\n\nRibbon\n\n\n\n\n\n\nGénero: 0 (esfera)\nFronteras: 3 componentes\n\n\n\n\n\n\n\n\n\n\nGrafo Base\n\n\n\n\n\n\n\nRibbon\n\n\n\n\n\n\nGénero: 0 (esfera)\nFronteras: 2 componentes"
  },
  {
    "objectID": "tutoriales/02-visualizacion.html#personalizar-las-visualizaciones",
    "href": "tutoriales/02-visualizacion.html#personalizar-las-visualizaciones",
    "title": "Tutorial 2: Visualización Paso a Paso",
    "section": "",
    "text": "Puedes ajustar los parámetros:\n\n# Parámetros personalizados\nviz.paso_3_engrosar_vertices(\n    radio_vertice=0.5,    # Discos más grandes\n    save_to='paso3_custom.png'\n)\n\nviz.paso_4_ribbon_completo(\n    radio_vertice=0.5,\n    ancho_cinta=0.25,      # Cintas más anchas\n    save_to='paso4_custom.png'\n)"
  },
  {
    "objectID": "tutoriales/02-visualizacion.html#ejercicio",
    "href": "tutoriales/02-visualizacion.html#ejercicio",
    "title": "Tutorial 2: Visualización Paso a Paso",
    "section": "",
    "text": "Tip📝 Ejercicio 2.1\n\n\n\nGenera la secuencia completa para el ribbon graph: - σ = (1,2,3,4) - ρ = (1,2)(3,4)\nIdentifica: 1. ¿Cuántos vértices tiene? 2. ¿Cuántas aristas? 3. ¿Cuántas componentes de frontera?\n\n\nVer solución\n\nviz = RibbonGraphVisualizer('(1,2,3,4)', '(1,2)(3,4)')\ninv = viz.invariantes()\nprint(inv)\n\n# Generar visualizaciones\nviz.generar_secuencia_completa(prefix='ejercicio2_')\nRespuestas: 1. 1 vértice 2. 2 aristas (ambas self-loops) 3. 3 componentes de frontera"
  },
  {
    "objectID": "tutoriales/02-visualizacion.html#próximos-pasos",
    "href": "tutoriales/02-visualizacion.html#próximos-pasos",
    "title": "Tutorial 2: Visualización Paso a Paso",
    "section": "",
    "text": "En el Tutorial 3 estudiaremos en detalle los invariantes topológicos."
  },
  {
    "objectID": "tutoriales/02-visualizacion.html#referencias",
    "href": "tutoriales/02-visualizacion.html#referencias",
    "title": "Tutorial 2: Visualización Paso a Paso",
    "section": "",
    "text": "Scripts del proyecto\nTutorial 1: Introducción"
  },
  {
    "objectID": "tutoriales/01-introduccion.html",
    "href": "tutoriales/01-introduccion.html",
    "title": "Tutorial 1: Introducción a Ribbon Graphs",
    "section": "",
    "text": "Un ribbon graph (grafo de cinta) es una forma de representar grafos embebidos en superficies con frontera. La idea clave es “engrosar” el grafo para obtener una superficie.\n\n\nUn ribbon graph se define mediante dos permutaciones:\n\n\n\n\n\n\nImportantePermutaciones Fundamentales\n\n\n\n\nσ (sigma): Permutación de vértices\n\nCada ciclo representa un vértice\nLos elementos son dardos (half-edges) en orden cíclico\n\nρ (rho): Permutación de aristas\n\nCada 2-ciclo empareja dos dardos\nForma una arista del grafo\n\n\n\n\n\n\n\nConsideremos el ribbon graph más simple:\nσ = (1,2,3)(4,5,6)    # 2 vértices de grado 3\nρ = (1,4)(2,5)(3,6)   # 3 aristas\n\n\n\nVértice 0: Tiene dardos {1, 2, 3} en orden cíclico\nVértice 1: Tiene dardos {4, 5, 6} en orden cíclico\nArista 1: Conecta dardos 1 y 4\nArista 2: Conecta dardos 2 y 5\nArista 3: Conecta dardos 3 y 6\n\n\n\n\n\n\nCódigo PythonUsando SageMathResultado\n\n\n# Cargar el visualizador\nimport sys\nsys.path.append('../scripts')\n\n# Definir permutaciones\nsigma = '(1,2,3)(4,5,6)'\nrho = '(1,4)(2,5)(3,6)'\n\nprint(f\"σ = {sigma}\")\nprint(f\"ρ = {rho}\")\n\n\n# En SageMath directamente\nload('../scripts/ribbongraph_visualizer.sage')\n\n# Crear el ribbon graph\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\n\n# Mostrar invariantes\nviz.invariantes()\n\n\n{\n  'genus': 1,\n  'caras_mu': 1,\n  'vertices': 2,\n  'aristas': 3,\n  'componentes_frontera': 1,\n  'euler_char_superficie': -1\n}\n\n\n\n\n\n\nEl proceso de visualización tiene 5 pasos:\n\nGrafo Base - Grafo abstracto (puntos y líneas)\nDardos - División de aristas en half-edges\nEngrosamiento - Vértices se convierten en discos\nCintas - Aristas se convierten en ribbons\nFronteras - Componentes de frontera visibles\n\n \n\n\n\nPara este ejemplo:\n\n\n\nInvariante\nValor\nSignificado\n\n\n\n\nGénero (g)\n1\nUn “agujero” (como un toro)\n\n\nVértices\n2\nDos vértices del grafo\n\n\nAristas\n3\nTres aristas\n\n\nCaras\n1\nUna cara de la superficie\n\n\nFronteras (b)\n1\nUna componente de frontera\n\n\nχ\n-1\nCaracterística de Euler\n\n\n\n\n\nPara una superficie con frontera:\n\\[\n\\chi = 2 - 2g - b = 2 - 2(1) - 1 = -1\n\\]\nTambién se cumple:\n\\[\n\\chi = V - E + F = 2 - 3 + 1 = 0\n\\]\n\n\n\n\n\n\nAdvertenciaNota sobre χ\n\n\n\nHay dos formas de calcular χ: - χ de la superficie: \\(2 - 2g - b\\) - χ del grafo: \\(V - E + F\\)\nSon diferentes pero relacionados!\n\n\n\n\n\n\n\n\n\n\n\n\nTip📝 Ejercicio 1.1\n\n\n\nCrea un ribbon graph con: - σ = (1,2)(3,4) - ρ = (1,3)\n¿Qué superficie representa?\n\n\nVer solución\n\nviz = RibbonGraphVisualizer('(1,2)(3,4)', '(1,3)')\ninv = viz.invariantes()\nprint(inv)\nResultado: - Género: 0 (esfera) - Fronteras: 2 - Superficie: Esfera con 2 agujeros\n\n\n\n\n\n\nEn el Tutorial 2 exploraremos en detalle el proceso de visualización paso a paso.\n\n\n\n\nDocumentación SageMath\nScripts del proyecto"
  },
  {
    "objectID": "tutoriales/01-introduccion.html#definición-mediante-permutaciones",
    "href": "tutoriales/01-introduccion.html#definición-mediante-permutaciones",
    "title": "Tutorial 1: Introducción a Ribbon Graphs",
    "section": "",
    "text": "Un ribbon graph se define mediante dos permutaciones:\n\n\n\n\n\n\nImportantePermutaciones Fundamentales\n\n\n\n\nσ (sigma): Permutación de vértices\n\nCada ciclo representa un vértice\nLos elementos son dardos (half-edges) en orden cíclico\n\nρ (rho): Permutación de aristas\n\nCada 2-ciclo empareja dos dardos\nForma una arista del grafo"
  },
  {
    "objectID": "tutoriales/01-introduccion.html#ejemplo-simple",
    "href": "tutoriales/01-introduccion.html#ejemplo-simple",
    "title": "Tutorial 1: Introducción a Ribbon Graphs",
    "section": "",
    "text": "Consideremos el ribbon graph más simple:\nσ = (1,2,3)(4,5,6)    # 2 vértices de grado 3\nρ = (1,4)(2,5)(3,6)   # 3 aristas\n\n\n\nVértice 0: Tiene dardos {1, 2, 3} en orden cíclico\nVértice 1: Tiene dardos {4, 5, 6} en orden cíclico\nArista 1: Conecta dardos 1 y 4\nArista 2: Conecta dardos 2 y 5\nArista 3: Conecta dardos 3 y 6"
  },
  {
    "objectID": "tutoriales/01-introduccion.html#crear-tu-primer-ribbon-graph",
    "href": "tutoriales/01-introduccion.html#crear-tu-primer-ribbon-graph",
    "title": "Tutorial 1: Introducción a Ribbon Graphs",
    "section": "",
    "text": "Código PythonUsando SageMathResultado\n\n\n# Cargar el visualizador\nimport sys\nsys.path.append('../scripts')\n\n# Definir permutaciones\nsigma = '(1,2,3)(4,5,6)'\nrho = '(1,4)(2,5)(3,6)'\n\nprint(f\"σ = {sigma}\")\nprint(f\"ρ = {rho}\")\n\n\n# En SageMath directamente\nload('../scripts/ribbongraph_visualizer.sage')\n\n# Crear el ribbon graph\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\n\n# Mostrar invariantes\nviz.invariantes()\n\n\n{\n  'genus': 1,\n  'caras_mu': 1,\n  'vertices': 2,\n  'aristas': 3,\n  'componentes_frontera': 1,\n  'euler_char_superficie': -1\n}"
  },
  {
    "objectID": "tutoriales/01-introduccion.html#visualización",
    "href": "tutoriales/01-introduccion.html#visualización",
    "title": "Tutorial 1: Introducción a Ribbon Graphs",
    "section": "",
    "text": "El proceso de visualización tiene 5 pasos:\n\nGrafo Base - Grafo abstracto (puntos y líneas)\nDardos - División de aristas en half-edges\nEngrosamiento - Vértices se convierten en discos\nCintas - Aristas se convierten en ribbons\nFronteras - Componentes de frontera visibles"
  },
  {
    "objectID": "tutoriales/01-introduccion.html#invariantes-topológicos",
    "href": "tutoriales/01-introduccion.html#invariantes-topológicos",
    "title": "Tutorial 1: Introducción a Ribbon Graphs",
    "section": "",
    "text": "Para este ejemplo:\n\n\n\nInvariante\nValor\nSignificado\n\n\n\n\nGénero (g)\n1\nUn “agujero” (como un toro)\n\n\nVértices\n2\nDos vértices del grafo\n\n\nAristas\n3\nTres aristas\n\n\nCaras\n1\nUna cara de la superficie\n\n\nFronteras (b)\n1\nUna componente de frontera\n\n\nχ\n-1\nCaracterística de Euler\n\n\n\n\n\nPara una superficie con frontera:\n\\[\n\\chi = 2 - 2g - b = 2 - 2(1) - 1 = -1\n\\]\nTambién se cumple:\n\\[\n\\chi = V - E + F = 2 - 3 + 1 = 0\n\\]\n\n\n\n\n\n\nAdvertenciaNota sobre χ\n\n\n\nHay dos formas de calcular χ: - χ de la superficie: \\(2 - 2g - b\\) - χ del grafo: \\(V - E + F\\)\nSon diferentes pero relacionados!"
  },
  {
    "objectID": "tutoriales/01-introduccion.html#ejercicio",
    "href": "tutoriales/01-introduccion.html#ejercicio",
    "title": "Tutorial 1: Introducción a Ribbon Graphs",
    "section": "",
    "text": "Tip📝 Ejercicio 1.1\n\n\n\nCrea un ribbon graph con: - σ = (1,2)(3,4) - ρ = (1,3)\n¿Qué superficie representa?\n\n\nVer solución\n\nviz = RibbonGraphVisualizer('(1,2)(3,4)', '(1,3)')\ninv = viz.invariantes()\nprint(inv)\nResultado: - Género: 0 (esfera) - Fronteras: 2 - Superficie: Esfera con 2 agujeros"
  },
  {
    "objectID": "tutoriales/01-introduccion.html#próximos-pasos",
    "href": "tutoriales/01-introduccion.html#próximos-pasos",
    "title": "Tutorial 1: Introducción a Ribbon Graphs",
    "section": "",
    "text": "En el Tutorial 2 exploraremos en detalle el proceso de visualización paso a paso."
  },
  {
    "objectID": "tutoriales/01-introduccion.html#referencias",
    "href": "tutoriales/01-introduccion.html#referencias",
    "title": "Tutorial 1: Introducción a Ribbon Graphs",
    "section": "",
    "text": "Documentación SageMath\nScripts del proyecto"
  },
  {
    "objectID": "tutoriales/03-invariantes.html",
    "href": "tutoriales/03-invariantes.html",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "Los invariantes topológicos son números que caracterizan la superficie ribbon sin depender de cómo la dibujemos.\n\n\n\nload('../scripts/ribbongraph_visualizer.sage')\n\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\ninv = viz.invariantes()\n\nfor nombre, valor in inv.items():\n    print(f\"{nombre:30s} = {valor}\")\n\ngenus                          = 1\ncaras_mu                       = 1\nvertices                       = 2\naristas                        = 3\ncomponentes_frontera           = 1\neuler_char_superficie          = -1\nV-E+F(mu)                      = 0\n\n\n\nEl género es el número de “agujeros” de la superficie.\n\nDefiniciónInterpretaciónCálculo\n\n\n\\[g = \\text{número de agujeros}\\]\n\n\n\ng = 0: Esfera (sin agujeros)\ng = 1: Toro (1 agujero)\ng = 2: Toro doble (2 agujeros)\ng ≥ 3: Superficies de género superior\n\n\n\nSageMath calcula el género usando la fórmula de Euler:\n\\[g = \\frac{2 - \\chi - b}{2}\\]\ndonde χ = V - E + F y b es el número de fronteras.\n\n\n\n\n\n\nNúmero de vértices del grafo = número de ciclos en σ.\n\nsigma = Permutation('(1,2,3)(4,5,6)')\nV = len(sigma.cycle_tuples())\nprint(f\"Vértices: {V}\")\n# Salida: Vértices: 2\n\n\n\n\n\n\n\nNota\n\n\n\nCada ciclo en σ representa un vértice del grafo.\n\n\n\n\n\nNúmero de aristas = número de 2-ciclos en ρ.\n\nrho = Permutation('(1,4)(2,5)(3,6)')\nE = len(rho.cycle_tuples())\nprint(f\"Aristas: {E}\")\n# Salida: Aristas: 3\n\n\n\n\n\n\n\nImportante\n\n\n\nρ debe ser una involución (producto de 2-ciclos disjuntos).\n\n\n\n\n\nNúmero de caras = número de ciclos en μ = σ·ρ.\n\nsigma = Permutation('(1,2,3)(4,5,6)')\nrho = Permutation('(1,4)(2,5)(3,6)')\nmu = sigma * rho\nF = len(mu.cycle_tuples())\nprint(f\"Caras: {F}\")\nprint(f\"μ = {mu}\")\n# Salida:\n# Caras: 1\n# μ = (1,5,3,4,2,6)\n\n\n\n\n\n\n\nTipLas caras son los “polígonos” de la superficie\n\n\n\nCada ciclo de μ representa una cara. La longitud del ciclo es el número de lados.\n\n\n\n\n\nNúmero de “bordes” de la superficie.\n\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\nrg = viz.ribbon_graph\nb = rg.number_boundaries()\nprint(f\"Fronteras: {b}\")\n# Salida: Fronteras: 1\n\n\n\n\n\n\n\nNota\n\n\n\nLas fronteras se calculan usando el método boundary() de SageMath, que devuelve las componentes como listas de dardos.\n\n\n\n\n\nHay dos formas de calcular χ:\n\n\nPara una superficie con frontera:\n\\[\\chi = 2 - 2g - b\\]\n\ng = 1  # género\nb = 1  # fronteras\nchi_superficie = 2 - 2*g - b\nprint(f\"χ (superficie) = {chi_superficie}\")\n# Salida: χ (superficie) = -1\n\n\n\n\nFórmula clásica de Euler:\n\\[\\chi_{grafo} = V - E + F\\]\n\nV, E, F = 2, 3, 1\nchi_grafo = V - E + F\nprint(f\"χ (grafo) = {chi_grafo}\")\n# Salida: χ (grafo) = 0\n\n\n\n\n\n\n\nAdvertencia¡Son diferentes!\n\n\n\n\nχ_{superficie} considera la superficie con frontera\nχ_{grafo} es la característica del grafo embebido\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEjemplo\nσ\nρ\nV\nE\nF\ng\nb\nχ\n\n\n\n\nToro\n(1,2,3)(4,5,6)\n(1,4)(2,5)(3,6)\n2\n3\n1\n1\n1\n-1\n\n\nSelf-loops\n(1,2,3,4)\n(1,2)(3,4)\n1\n2\n1\n0\n3\n-1\n\n\nTriángulo\n(1,2)(3,4)(5,6)\n(1,3)(2,5)(4,6)\n3\n3\n2\n0\n2\n0\n\n\nTheta\n(1,2,3)(4,5,6)\n(1,6)(2,4)(3,5)\n2\n3\n1\n1\n1\n-1\n\n\n\n\n\n\nPara cada ribbon graph, podemos verificar:\n\ndef verificar_invariantes(sigma_str, rho_str):\n    viz = RibbonGraphVisualizer(sigma_str, rho_str)\n    inv = viz.invariantes()\n\n    # Verificar χ = 2 - 2g - b\n    chi_calc = 2 - 2*inv['genus'] - inv['componentes_frontera']\n    chi_real = inv['euler_char_superficie']\n\n    # Verificar V - E + F\n    vef = inv['V-E+F(mu)']\n\n    print(f\"Verificación:\")\n    print(f\"  χ calculado (2-2g-b): {chi_calc}\")\n    print(f\"  χ real:               {chi_real}\")\n    print(f\"  Coinciden: {chi_calc == chi_real}\")\n    print(f\"  V - E + F:            {vef}\")\n\n    return inv\n\n# Probar con ejemplo\nverificar_invariantes('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\n\n\n\n\nLas relaciones fundamentales:\n\nFórmula de Euler para superficies con frontera: \\[\\chi = 2 - 2g - b\\]\nRelación con el grafo: \\[\\chi_{grafo} = V - E + F\\]\nConexión: \\[2 - 2g - b = V - E + F + \\text{(términos de ajuste)}\\]\n\n\n\n\n\n\n\nNotaLa diferencia\n\n\n\nLa diferencia entre χ_{superficie} y χ_{grafo} depende de cómo se cuentan las fronteras.\n\n\n\n\n\n\n\n\n\n\n\nTip📝 Ejercicio 3.1\n\n\n\nPara el ribbon graph σ = (1,2,3,4,5,6), ρ = (1,2)(3,4)(5,6):\n\nCalcula V, E, F\nCalcula g y b\nVerifica χ = 2 - 2g - b\nVerifica V - E + F\n\n\n\nVer solución\n\nviz = RibbonGraphVisualizer('(1,2,3,4,5,6)', '(1,2)(3,4)(5,6)')\ninv = viz.invariantes()\n\n# 1. V, E, F\nV = inv['vertices']      # 1\nE = inv['aristas']       # 3\nF = inv['caras_mu']      # ?\n\n# 2. g, b\ng = inv['genus']\nb = inv['componentes_frontera']\n\n# 3. Verificar χ = 2 - 2g - b\nchi = 2 - 2*g - b\nprint(f\"χ = 2 - 2({g}) - {b} = {chi}\")\n\n# 4. Verificar V - E + F\nvef = V - E + F\nprint(f\"V - E + F = {V} - {E} + {F} = {vef}\")\nResultado: - V = 1, E = 3, F = 1 - g = 0, b = 4 - χ = -2 - V - E + F = -1\n\n\n\n\n\n\nExplora más ejemplos en Notas: Ejemplos Clásicos.\n\n\n\n\nGross & Tucker, Topological Graph Theory (1987)\nTutorial 1 | Tutorial 2"
  },
  {
    "objectID": "tutoriales/03-invariantes.html#los-7-invariantes-principales",
    "href": "tutoriales/03-invariantes.html#los-7-invariantes-principales",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "load('../scripts/ribbongraph_visualizer.sage')\n\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\ninv = viz.invariantes()\n\nfor nombre, valor in inv.items():\n    print(f\"{nombre:30s} = {valor}\")\n\ngenus                          = 1\ncaras_mu                       = 1\nvertices                       = 2\naristas                        = 3\ncomponentes_frontera           = 1\neuler_char_superficie          = -1\nV-E+F(mu)                      = 0"
  },
  {
    "objectID": "tutoriales/03-invariantes.html#género-g",
    "href": "tutoriales/03-invariantes.html#género-g",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "El género es el número de “agujeros” de la superficie.\n\nDefiniciónInterpretaciónCálculo\n\n\n\\[g = \\text{número de agujeros}\\]\n\n\n\ng = 0: Esfera (sin agujeros)\ng = 1: Toro (1 agujero)\ng = 2: Toro doble (2 agujeros)\ng ≥ 3: Superficies de género superior\n\n\n\nSageMath calcula el género usando la fórmula de Euler:\n\\[g = \\frac{2 - \\chi - b}{2}\\]\ndonde χ = V - E + F y b es el número de fronteras."
  },
  {
    "objectID": "tutoriales/03-invariantes.html#vértices-v",
    "href": "tutoriales/03-invariantes.html#vértices-v",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "Número de vértices del grafo = número de ciclos en σ.\n\nsigma = Permutation('(1,2,3)(4,5,6)')\nV = len(sigma.cycle_tuples())\nprint(f\"Vértices: {V}\")\n# Salida: Vértices: 2\n\n\n\n\n\n\n\nNota\n\n\n\nCada ciclo en σ representa un vértice del grafo."
  },
  {
    "objectID": "tutoriales/03-invariantes.html#aristas-e",
    "href": "tutoriales/03-invariantes.html#aristas-e",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "Número de aristas = número de 2-ciclos en ρ.\n\nrho = Permutation('(1,4)(2,5)(3,6)')\nE = len(rho.cycle_tuples())\nprint(f\"Aristas: {E}\")\n# Salida: Aristas: 3\n\n\n\n\n\n\n\nImportante\n\n\n\nρ debe ser una involución (producto de 2-ciclos disjuntos)."
  },
  {
    "objectID": "tutoriales/03-invariantes.html#caras-f",
    "href": "tutoriales/03-invariantes.html#caras-f",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "Número de caras = número de ciclos en μ = σ·ρ.\n\nsigma = Permutation('(1,2,3)(4,5,6)')\nrho = Permutation('(1,4)(2,5)(3,6)')\nmu = sigma * rho\nF = len(mu.cycle_tuples())\nprint(f\"Caras: {F}\")\nprint(f\"μ = {mu}\")\n# Salida:\n# Caras: 1\n# μ = (1,5,3,4,2,6)\n\n\n\n\n\n\n\nTipLas caras son los “polígonos” de la superficie\n\n\n\nCada ciclo de μ representa una cara. La longitud del ciclo es el número de lados."
  },
  {
    "objectID": "tutoriales/03-invariantes.html#componentes-de-frontera-b",
    "href": "tutoriales/03-invariantes.html#componentes-de-frontera-b",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "Número de “bordes” de la superficie.\n\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\nrg = viz.ribbon_graph\nb = rg.number_boundaries()\nprint(f\"Fronteras: {b}\")\n# Salida: Fronteras: 1\n\n\n\n\n\n\n\nNota\n\n\n\nLas fronteras se calculan usando el método boundary() de SageMath, que devuelve las componentes como listas de dardos."
  },
  {
    "objectID": "tutoriales/03-invariantes.html#característica-de-euler-χ",
    "href": "tutoriales/03-invariantes.html#característica-de-euler-χ",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "Hay dos formas de calcular χ:\n\n\nPara una superficie con frontera:\n\\[\\chi = 2 - 2g - b\\]\n\ng = 1  # género\nb = 1  # fronteras\nchi_superficie = 2 - 2*g - b\nprint(f\"χ (superficie) = {chi_superficie}\")\n# Salida: χ (superficie) = -1\n\n\n\n\nFórmula clásica de Euler:\n\\[\\chi_{grafo} = V - E + F\\]\n\nV, E, F = 2, 3, 1\nchi_grafo = V - E + F\nprint(f\"χ (grafo) = {chi_grafo}\")\n# Salida: χ (grafo) = 0\n\n\n\n\n\n\n\nAdvertencia¡Son diferentes!\n\n\n\n\nχ_{superficie} considera la superficie con frontera\nχ_{grafo} es la característica del grafo embebido"
  },
  {
    "objectID": "tutoriales/03-invariantes.html#tabla-de-ejemplos",
    "href": "tutoriales/03-invariantes.html#tabla-de-ejemplos",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "Ejemplo\nσ\nρ\nV\nE\nF\ng\nb\nχ\n\n\n\n\nToro\n(1,2,3)(4,5,6)\n(1,4)(2,5)(3,6)\n2\n3\n1\n1\n1\n-1\n\n\nSelf-loops\n(1,2,3,4)\n(1,2)(3,4)\n1\n2\n1\n0\n3\n-1\n\n\nTriángulo\n(1,2)(3,4)(5,6)\n(1,3)(2,5)(4,6)\n3\n3\n2\n0\n2\n0\n\n\nTheta\n(1,2,3)(4,5,6)\n(1,6)(2,4)(3,5)\n2\n3\n1\n1\n1\n-1"
  },
  {
    "objectID": "tutoriales/03-invariantes.html#verificación-de-fórmulas",
    "href": "tutoriales/03-invariantes.html#verificación-de-fórmulas",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "Para cada ribbon graph, podemos verificar:\n\ndef verificar_invariantes(sigma_str, rho_str):\n    viz = RibbonGraphVisualizer(sigma_str, rho_str)\n    inv = viz.invariantes()\n\n    # Verificar χ = 2 - 2g - b\n    chi_calc = 2 - 2*inv['genus'] - inv['componentes_frontera']\n    chi_real = inv['euler_char_superficie']\n\n    # Verificar V - E + F\n    vef = inv['V-E+F(mu)']\n\n    print(f\"Verificación:\")\n    print(f\"  χ calculado (2-2g-b): {chi_calc}\")\n    print(f\"  χ real:               {chi_real}\")\n    print(f\"  Coinciden: {chi_calc == chi_real}\")\n    print(f\"  V - E + F:            {vef}\")\n\n    return inv\n\n# Probar con ejemplo\nverificar_invariantes('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')"
  },
  {
    "objectID": "tutoriales/03-invariantes.html#relación-entre-invariantes",
    "href": "tutoriales/03-invariantes.html#relación-entre-invariantes",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "Las relaciones fundamentales:\n\nFórmula de Euler para superficies con frontera: \\[\\chi = 2 - 2g - b\\]\nRelación con el grafo: \\[\\chi_{grafo} = V - E + F\\]\nConexión: \\[2 - 2g - b = V - E + F + \\text{(términos de ajuste)}\\]\n\n\n\n\n\n\n\nNotaLa diferencia\n\n\n\nLa diferencia entre χ_{superficie} y χ_{grafo} depende de cómo se cuentan las fronteras."
  },
  {
    "objectID": "tutoriales/03-invariantes.html#ejercicio",
    "href": "tutoriales/03-invariantes.html#ejercicio",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "Tip📝 Ejercicio 3.1\n\n\n\nPara el ribbon graph σ = (1,2,3,4,5,6), ρ = (1,2)(3,4)(5,6):\n\nCalcula V, E, F\nCalcula g y b\nVerifica χ = 2 - 2g - b\nVerifica V - E + F\n\n\n\nVer solución\n\nviz = RibbonGraphVisualizer('(1,2,3,4,5,6)', '(1,2)(3,4)(5,6)')\ninv = viz.invariantes()\n\n# 1. V, E, F\nV = inv['vertices']      # 1\nE = inv['aristas']       # 3\nF = inv['caras_mu']      # ?\n\n# 2. g, b\ng = inv['genus']\nb = inv['componentes_frontera']\n\n# 3. Verificar χ = 2 - 2g - b\nchi = 2 - 2*g - b\nprint(f\"χ = 2 - 2({g}) - {b} = {chi}\")\n\n# 4. Verificar V - E + F\nvef = V - E + F\nprint(f\"V - E + F = {V} - {E} + {F} = {vef}\")\nResultado: - V = 1, E = 3, F = 1 - g = 0, b = 4 - χ = -2 - V - E + F = -1"
  },
  {
    "objectID": "tutoriales/03-invariantes.html#próximos-pasos",
    "href": "tutoriales/03-invariantes.html#próximos-pasos",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "Explora más ejemplos en Notas: Ejemplos Clásicos."
  },
  {
    "objectID": "tutoriales/03-invariantes.html#referencias",
    "href": "tutoriales/03-invariantes.html#referencias",
    "title": "Tutorial 3: Invariantes Topológicos",
    "section": "",
    "text": "Gross & Tucker, Topological Graph Theory (1987)\nTutorial 1 | Tutorial 2"
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#section",
    "href": "presentaciones/sistemas-rotacion.html#section",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "",
    "text": "Sistemas de rotación y ribbon graphs\n\n\nJosé Luis León"
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#objetivo-de-la-charla",
    "href": "presentaciones/sistemas-rotacion.html#objetivo-de-la-charla",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "Objetivo de la charla",
    "text": "Objetivo de la charla\nQueremos codificar encajes celulares de grafos en superficies orientables sin dibujar la superficie, usando sólo datos combinatorios.\n\nEntrada: un grafo abstracto \\(G\\).\nDato extra: un sistema de rotación (orden cíclico local).\nSalida: una superficie orientable (con o sin frontera) donde \\(G\\) queda encajado, más las caras y el género.\n\n\n\n\n\n\n\n\nIdea clave\n\n\n“Localmente en vértices” \\(\\Rightarrow\\) “globalmente en la superficie”"
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#sistemas-de-rotación-semiaristas",
    "href": "presentaciones/sistemas-rotacion.html#sistemas-de-rotación-semiaristas",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "Sistemas de rotación (semiaristas)",
    "text": "Sistemas de rotación (semiaristas)\nConsideremos un grafo \\(G\\) (no necesariamente encajado en una superficie). Insertamos un vértice en el interior de cada arista, dividiéndola en dos semiaristas (también llamadas darts, half-edges o flags). Etiquetamos las semiaristas con números.\n\nUn sistema de rotación sobre \\(G\\) se da por un par de permutaciones \\((\\sigma,\\rho)\\) sobre el conjunto de semiaristas, donde:\n\n\\(\\sigma\\) es producto de ciclos disjuntos, uno por cada vértice de \\(G\\). Cada ciclo describe un orden cíclico de las semiaristas incidentes a ese vértice.\n\\(\\rho\\) es producto de 2-ciclos (involución sin puntos fijos) y empareja las dos semiaristas que forman una arista.\n\n\n\n\n\n\n\n\nNotación\n\n\nTraducción a Lando–Zvonkin: \\(\\rho=\\alpha\\). En Sage: sigma, rho."
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#engrosamiento-de-sigmarho-a-una-superficie",
    "href": "presentaciones/sistemas-rotacion.html#engrosamiento-de-sigmarho-a-una-superficie",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "Engrosamiento: de \\((\\sigma,\\rho)\\) a una superficie",
    "text": "Engrosamiento: de \\((\\sigma,\\rho)\\) a una superficie\nPara cualquier par \\((\\sigma,\\rho)\\) como arriba, existe un procedimiento de engrosar el grafo para obtener una superficie orientable con frontera tal que:\n\nla superficie se retrae fuertemente al grafo (deformación fuerte);\nel grafo queda encajado en la superficie;\na partir del encaje se recuperan \\(\\sigma\\) y \\(\\rho\\).\n\n\n\n\n\n\n\n\nIntuición\n\n\nCada vértice se vuelve un “disco”; cada semiarista es una banda pegada al borde; \\(\\sigma\\) indica el orden de pegado alrededor del disco; \\(\\rho\\) pega lengüetas por pares."
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#heffteredmonds-rotaciones-leftrightarrow-encajes-celulares",
    "href": "presentaciones/sistemas-rotacion.html#heffteredmonds-rotaciones-leftrightarrow-encajes-celulares",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "Heffter–Edmonds: rotaciones \\(\\leftrightarrow\\) encajes celulares",
    "text": "Heffter–Edmonds: rotaciones \\(\\leftrightarrow\\) encajes celulares\n\n\n\n\n\n\nTeorema (Heffter–Edmonds)\n\n\nTodo sistema de rotación puro para un grafo \\(G\\) induce (hasta equivalencia por homeomorfismos que preservan orientación) un encaje de \\(G\\) en una superficie orientable.\nRecíprocamente, todo encaje de \\(G\\) en una superficie orientable induce un único sistema de rotación puro para \\(G\\).\n\n\n\n\n\nSe atribuye a Heffter (1891) y Edmonds (1960) en la literatura."
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#mapas-combinatorios-el-modelo-permutacional",
    "href": "presentaciones/sistemas-rotacion.html#mapas-combinatorios-el-modelo-permutacional",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "Mapas combinatorios: el modelo permutacional",
    "text": "Mapas combinatorios: el modelo permutacional\nSea \\(D\\) el conjunto de semiaristas. Entonces \\(|D|=2|E|\\).\n\nDel lado combinatorio trabajamos con:\n\n\\(\\sigma\\): ciclos = vértices; orden cíclico alrededor del vértice (orientación).\n\\(\\rho\\): transposiciones = aristas; empareja semiaristas.\n\n\n\n\nLo que falta para reconstruir el encaje es identificar las caras. Esto se obtiene con una tercera permutación sobre \\(D\\)."
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#convención-para-leer-caras",
    "href": "presentaciones/sistemas-rotacion.html#convención-para-leer-caras",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "Convención para leer caras",
    "text": "Convención para leer caras\n\n\n\n\n\n\nConvención\n\n\nAl recorrer una semiarista desde un vértice, colocamos su etiqueta en el lado izquierdo del trazo. Una semiarista es incidente a una cara si su etiqueta queda dentro de esa cara.\n\n\n\n\nCon esta convención, cada cara queda descrita por un ciclo de semiaristas en sentido antihorario.\n\n\n\n(Esto es exactamente lo que usan los algoritmos de face tracing.)"
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#permutación-de-caras-varphi",
    "href": "presentaciones/sistemas-rotacion.html#permutación-de-caras-varphi",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "Permutación de caras \\(\\varphi\\)",
    "text": "Permutación de caras \\(\\varphi\\)\nLa permutación de caras \\(\\varphi\\) se computa a partir de \\(\\sigma\\) y \\(\\rho\\):\n\\[\n\\varphi \\;=\\; \\rho^{-1}\\sigma^{-1}\n\\]\n\nComo \\(\\rho\\) es una involución, \\(\\rho^{-1}=\\rho\\), pero se escribe así porque en generalizaciones (hipermapas) la “permutación de aristas” puede no ser involución.\n\n\nForma equivalente: \\[\n\\sigma\\,\\rho\\,\\varphi \\;=\\; \\mathrm{id}\n\\]\n\n\n\n\n\n\n\n\nInterpretación\n\n\nLos ciclos de \\(\\varphi\\) \\(\\leftrightarrow\\) caras del encaje celular."
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#algoritmo-de-trazado-de-caras-face-tracing-vía-permutaciones",
    "href": "presentaciones/sistemas-rotacion.html#algoritmo-de-trazado-de-caras-face-tracing-vía-permutaciones",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "Algoritmo de trazado de caras (face tracing) vía permutaciones",
    "text": "Algoritmo de trazado de caras (face tracing) vía permutaciones\nPara recorrer una cara en sentido positivo, desde una semiarista \\(d\\) repetimos: \\[\nd \\longmapsto \\varphi(d)=\\rho^{-1}\\sigma^{-1}(d)\n\\]\n\n\n\n\n\n\n\nRegla local (mentalmente útil)\n\n\n\n\\(\\rho^{-1}\\): cruzar la arista (cambiar a la semiarista “opuesta”).\n\\(\\sigma^{-1}\\): tomar la semiarista “anterior” en el orden cíclico del vértice.\n\n\n\n\n\n\nUn ciclo cerrado de \\(\\varphi\\) da la frontera de una cara. Repitiendo con semiaristas no usadas se obtienen todas las caras."
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#de-sigmarhovarphi-a-una-superficie-pegado-de-polígonos",
    "href": "presentaciones/sistemas-rotacion.html#de-sigmarhovarphi-a-una-superficie-pegado-de-polígonos",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "De \\([\\sigma,\\rho,\\varphi]\\) a una superficie: pegado de polígonos",
    "text": "De \\([\\sigma,\\rho,\\varphi]\\) a una superficie: pegado de polígonos\n\n\n\n\n\n\nConstrucción (polígonos \\(\\to\\) superficie)\n\n\n\nA cada ciclo de \\(\\varphi\\) de longitud \\(m\\), asociamos un \\(m\\)-gono orientado (con lados etiquetados por las semiaristas del ciclo).\nPegamos lados por pares según \\(\\rho\\), con orientaciones opuestas.\nLos vértices quedan determinados por los ciclos de \\(\\sigma\\).\n\n\n\n\n\nEl resultado es una superficie orientable y un encaje celular del grafo.\n\n\n\nCon esto, \\((\\sigma,\\rho)\\) “contiene” el encaje completo."
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#euler-y-género-desde-permutaciones",
    "href": "presentaciones/sistemas-rotacion.html#euler-y-género-desde-permutaciones",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "Euler y género desde permutaciones",
    "text": "Euler y género desde permutaciones\nSi \\(V=\\#\\text{ciclos}(\\sigma)\\), \\(E=|D|/2\\), \\(F=\\#\\text{ciclos}(\\varphi)\\), entonces\n\\[\n\\chi \\;=\\; V - E + F\n\\]\n\nPara una superficie orientable cerrada:\n\\[\n\\chi = 2-2g \\quad\\Rightarrow\\quad g = 1-\\frac{\\chi}{2}\n\\]\n\n\n\n\n\n\n\n\nCaso con frontera\n\n\nEn el caso “con frontera” (ribbon graph thickening), Sage reporta género y número de componentes de frontera."
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#conexión-con-sage-ribbongraphsigmarho",
    "href": "presentaciones/sistemas-rotacion.html#conexión-con-sage-ribbongraphsigmarho",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "Conexión con Sage: RibbonGraph(\\(\\sigma,\\rho\\))",
    "text": "Conexión con Sage: RibbonGraph(\\(\\sigma,\\rho\\))\nSage implementa ribbon graphs como datos \\((\\sigma,\\rho)\\) sobre semiaristas:\n\nsigma: ciclos = orden cíclico en cada vértice.\nrho: producto de 2-ciclos = emparejamiento en aristas.\n\n\n\nLo útil para clase/investigación:\n\nR.genus(), R.number_boundaries()\nR.boundary() (caras/bordes etiquetados)\ncontracciones/extrusiones: contract_edge, extrude_edge\nR.homology_basis() (base en \\(H_1\\) del grafo)\n\n\n\n\n\n\n\n\n\n\nVentaja\n\n\nEsto te permite pasar de rotaciones a “geometría” sin dibujar la superficie."
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#puente-hacia-el-toro-del-rectángulo-identificado-al-dibujo",
    "href": "presentaciones/sistemas-rotacion.html#puente-hacia-el-toro-del-rectángulo-identificado-al-dibujo",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "Puente hacia el toro: del rectángulo identificado al dibujo",
    "text": "Puente hacia el toro: del rectángulo identificado al dibujo\nPara visualizar un encaje en el toro:\n\nModela el toro como un cuadrado con lados opuestos identificados.\nTraza el grafo dentro del cuadrado; cuando una arista cruza un borde, reaparece en el borde opuesto.\nEl sistema de rotación fija el orden local en cada vértice, y el trazado de caras (\\(\\varphi\\)) te dice qué polígonos pegas: eso determina el género.\n\n\n\n\n\n\n\n\nMensaje clave\n\n\nEl dibujo bonito en 3D es sólo una visualización; la información real está en \\((\\sigma,\\rho)\\)."
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#para-investigación-direcciones-inmediatas",
    "href": "presentaciones/sistemas-rotacion.html#para-investigación-direcciones-inmediatas",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "Para investigación: direcciones inmediatas",
    "text": "Para investigación: direcciones inmediatas\nUna vez dominado \\((\\sigma,\\rho)\\), puedes atacar:\n\nGénero mínimo y obstrucciones combinatorias.\nEnumeración de encajes celulares (órbitas por conjugación).\nInvariantes: polinomios tipo Tutte/Bollobás–Riordan (ribbon graphs).\nOperaciones: contracción, eliminación, dualidad (cuando aplique), reducción.\n\n\n\n\n\n\n\n\nSage como laboratorio\n\n\nSage te sirve como laboratorio para experimentar y luego formalizar resultados."
  },
  {
    "objectID": "presentaciones/sistemas-rotacion.html#cierre",
    "href": "presentaciones/sistemas-rotacion.html#cierre",
    "title": "Sistemas de rotación y ribbon graphs",
    "section": "Cierre",
    "text": "Cierre\n\nUn encaje celular orientable \\(\\Longleftrightarrow\\) un sistema de rotación puro.\nCombinatoriamente: semiaristas \\(D\\), permutaciones \\(\\sigma\\) (vértices) y \\(\\rho\\) (aristas).\nLas caras se leen con \\(\\varphi=\\rho^{-1}\\sigma^{-1}\\).\nCon \\((V,E,F)\\) recuperamos \\(\\chi\\) y el género.\n\n\n\n\n\n\n\n\n\nSiguiente paso\n\n\nEjemplos concretos (toro) y experimentos en Sage.\n\n\n\n\n\n\n\n¡Gracias!"
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html",
    "href": "capitulos/01-sistemas-rotacion.html",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Queremos codificar encajes celulares de grafos en superficies orientables sin dibujar la superficie, usando sólo datos combinatorios.\n\nEntrada: un grafo abstracto \\(G\\)\nDato extra: un sistema de rotación (orden cíclico local)\nSalida: una superficie orientable donde \\(G\\) queda encajado, más las caras y el género\n\nLa idea es que la información “local” (en vértices) determine completamente la estructura “global” (la superficie).\n\n\n\n\nPara trabajar con sistemas de rotación, descomponemos cada arista del grafo \\(G\\) mediante una partición formal. Insertamos un vértice ficticio (o de paso) en el interior de cada arista, lo que resulta en un conjunto \\(D\\) de semiaristas (también llamadas darts o half-edges).\nEsta construcción garantiza que:\n\nPartición por Arista: Cada arista original queda particionada exactamente en dos semiaristas que comparten el vértice ficticio.\nIncidencia en Vértices Originales: Cada semiarista \\(d \\in D\\) tiene un extremo en un vértice original de \\(G\\) y el otro en un vértice ficticio. Decimos que \\(d\\) está asociada al vértice original donde incide.\nRelación de Adyacencia (Involución): Dos semiaristas son adyacentes si comparten el mismo vértice ficticio. Esto define una permutación \\(\\rho: D \\to D\\) compuesta por trasposiciones (2-ciclos), donde cada ciclo vincula el par de semiaristas que conforman una arista original.\n\n\n\n\n\n\n\nNotaConteo de semiaristas\n\n\n\nSi el grafo tiene \\(E\\) aristas, tendremos \\(|D| = 2E\\) semiaristas en total, donde \\(D\\) es el conjunto de todas las semiaristas.\n\n\n\n\n\nConsideremos el grafo con un vértice y dos aristas.\n\n\n\nVértices: 1\nAristas: 2 aristas\nSemiaristas: 4 (etiquetadas 1, 2, 3, 4)\n\n\n\n\nEtiquetado de semiaristas\n\n\n\n\n\n\n\nUn sistema de rotación sobre un grafo \\(G\\) se define por un par de permutaciones \\((\\sigma, \\rho)\\) sobre el conjunto de semiaristas \\(D\\):\n\n\n\nEs un producto de ciclos disjuntos\nHay un ciclo por cada vértice de \\(G\\)\nCada ciclo describe el orden cíclico de las semiaristas incidentes a ese vértice\nEl orden cíclico refleja cómo las aristas se ordenan alrededor del vértice en la superficie\n\n\n\n\n\nEs un producto de 2-ciclos (transposiciones)\nCada 2-ciclo empareja las dos semiaristas que forman una arista\nEs una involución sin puntos fijos: \\(\\rho^2 = \\mathrm{id}\\)\n\n\n\n\n\n\n\nNotaContexto Histórico y Terminología\n\n\n\nLos sistemas de rotación tienen una rica historia y han sido redescubiertos en múltiples contextos:\n\nOrígenes: Fueron introducidos por Edmonds (1960) y formalizados por Youngs (1963), quien también introdujo sistemas con signo para superficies no orientables. Representaciones similares fueron propuestas independientemente por Jacques, Biggs, y Walsh & Lehman.\nDesarrollo: Tutte y Gross & Alpert extendieron estos sistemas. El encaje celular inducido que revisaremos más adelante es frecuentemente llamado encaje de Heffter-Edmonds.\nSinónimos: En la literatura se encuentran como vortex graphs, constelaciones, mapas combinatorios, fat graphs, ribbon graphs y dessins d’enfants.\n\nNuestra Convención: Adoptamos la notación de SageMath y Lando & Zvonkin, usando el par de permutaciones \\((\\sigma, \\rho)\\) sobre semiaristas y refiriéndonos a la estructura topológica como Ribbon Graph.\n\n\n\n\n\n\n\nRecordando la construcción del ejemplo anterior:\n\n\nVértices: 1\nAristas: 2\nSemiaristas: 4 (etiquetadas 1, 2, 3, 4)\n\nEs importante notar que \\(\\rho\\) está fijo por la construcción del grafo (la elección de qué pares de semiaristas forman cada arista). Por lo tanto, solo podemos variar \\(\\sigma\\).\nComo tenemos 4 semiaristas incidentes al mismo vértice, el número de posibles órdenes cíclicos es \\((4-1)! = 6\\). A continuación listamos todas las posibilidades:\n\n\\(\\sigma = (1, 2, 3, 4)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 2, 4, 3)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 3, 2, 4)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 3, 4, 2)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 4, 2, 3)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 4, 3, 2)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\nCada una de estas elecciones define un sistema de rotación válido. En las siguientes secciones veremos cómo estas permutaciones determinan la topología de la superficie resultante.\n\n\n\n\n\nConsideremos el grafo completo con 3 vértices: \\(K_3\\):\n\n\n\n\nVértices: 3 (A, B, C)\nAristas: 3 (AB, BC, CA)\nSemiaristas: 6 (etiquetadas 1, 2, 3, 4, 5, 6)\n\nAsignación de semiaristas:\n\nVértice A: semiaristas 1, 6\nVértice B: semiaristas 2, 3\nVértice C: semiaristas 4, 5\n\nAristas:\n\nAB: semiaristas 1 y 2\nBC: semiaristas 3 y 4\nCA: semiaristas 5 y 6\n\nPara definir el sistema de rotación, la asignación explícita de semiaristas es necesaria para fijar \\(\\rho\\).\n\n\\(\\rho\\): Queda determinado por los pares que forman las aristas. \\[\\rho = (1, 2)(3, 4)(5, 6)\\]\n\\(\\sigma\\): En este caso, como cada vértice tiene grado 2, existe un único orden cíclico posible para las semiaristas incidentes (\\((a,b)\\) es equivalente a \\((b,a)\\)). \\[\\sigma = (1, 6)(2, 3)(4, 5)\\]\n\nEste sistema describe el encaje estándar de \\(K_3\\) en la esfera (género 0).\n\n\n\n\n\nPara un grafo dado (sin vértices aislados), podemos calcular exactamente cuántos Sistemas de Rotación (que generan superficies orientables) se pueden construir. La fórmula depende enteramente de la conectividad local de los vértices.\n\n\nSi llamamos \\(N(G)\\) al número total de sistemas de rotación para un grafo \\(G\\), tenemos:\n\\[ N(G) = \\prod_{v \\in V(G)} (\\deg(v) - 1)! \\]\nDonde:\n\n\\(\\prod\\): Es el símbolo de producto (multiplicamos el resultado de cada vértice).\n\\(V(G)\\): Es el conjunto de todos los vértices del grafo.\n\\(\\deg(v)\\) (Grado): Es el número de semiaristas que llegan al vértice \\(v\\).\n\\((\\deg(v) - 1)!\\): Es el número de formas de organizar las semiaristas en un círculo (permutaciones cíclicas).\n\n\n\n\n\n\nEl grafo de un vértice y dos lazos:\n\nTenemos 1 vértice con grado \\(4\\).\nCálculo: \\((4-1)! = 6\\) sistemas.\nResultado: Coincide exactamente con la lista de \\(6\\) que vimos anteriormente.\n\nEl Triángulo (\\(K_3\\)):\n\nTenemos 3 vértices, cada uno con grado \\(2\\).\nCálculo: \\((2-1)! \\times (2-1)! \\times (2-1)! = 1\\) sistema.\nResultado: Por eso el \\(K_3\\) es “rígido”; solo puede encajarse de una forma (en la esfera).\n\n\n\n\n\n\nA medida que añadimos vértices y cada uno se conecta con todos los demás, el número de universos topológicos posibles crece de forma estrepitosa:\n\n\n\nGrafo\nVértices\nGrado\nFórmula\nTotal de Sistemas\n\n\n\n\n\\(K_3\\) (Triángulo)\n3\n2\n\\((1!)^3\\)\n1\n\n\n\\(K_4\\) (Tetraedro)\n4\n3\n\\((2!)^4\\)\n16\n\n\n\\(K_5\\) (Pentáculo)\n5\n4\n\\((3!)^5\\)\n7,776\n\n\n\\(K_6\\)\n6\n5\n\\((4!)^6\\)\n191,102,976\n\n\n\\(K_7\\)\n7\n6\n\\((5!)^7\\)\n358,318,080,000,000\n\n\n\n\nNota para la reflexión: ¡Para un simple grafo de 7 vértices, existen más de 358 billones de formas de encajarlo en superficies! La gran mayoría de estas formas resultarán en superficies con muchísimos “agujeros” (género alto), y solo unas pocas tendrán género mínimo (\\(K_7\\) no es planar).\n\n\n\n\n\n\nEl sistema de rotación \\((\\sigma, \\rho)\\) codifica:\n\nEl grafo subyacente\n\nLos ciclos de \\(\\sigma\\) determinan los vértices\nLos 2-ciclos de \\(\\rho\\) determinan las aristas\nPodemos reconstruir \\(G\\) desde \\((\\sigma, \\rho)\\)\n\nEl orden cíclico local\n\nCada ciclo de \\(\\sigma\\) indica cómo se ordenan las semiaristas alrededor de un vértice\nEste orden respeta la orientación de la superficie\n\n\n\n\n\n\nSageMath implementa ribbon graphs directamente desde sistemas de rotación:\nPuedes verificar estos cálculos rápidamente en línea usando SageMathCell.\n\n\nConstruyamos el sistema de rotación más estándar para este grafo:\n# Usamos PermutationGroupElement directamente\nsigma = PermutationGroupElement(\"(1,2,3,4)\")\nrho = PermutationGroupElement(\"(1,2)(3,4)\")\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Objeto creado: {R}\")\nprint(f\"Tipo: {type(R).__name__}\")\n\n# Recuperar las permutaciones almacenadas\nprint(f\"\\nPermutaciones:\")\nprint(f\"  σ = {R.sigma()}\")\nprint(f\"  ρ = {R.rho()}\")\n\n# Contar elementos del grafo\nnum_semiaristas = len(R.sigma().domain())\nnum_vertices = len(R.sigma().cycle_tuples(singletons=True))\nnum_aristas = len(R.rho().cycle_tuples())\n\nprint(f\"\\nEstructura del grafo:\")\nprint(f\"  Semiaristas: {num_semiaristas}\")\nprint(f\"  Vértices: {num_vertices}\")\nprint(f\"  Aristas: {num_aristas}\")\n\n\n\nPodemos etiquetar las semiaristas con cualquier numeración, no necesariamente 1,2,3,…\n# K₃ con numeración consecutiva empezando desde 10\nsigma_k3 = PermutationGroupElement(\"(10,15)(11,12)(13,14)\")\nrho_k3 = PermutationGroupElement(\"(10,11)(12,13)(14,15)\")\nR_k3 = RibbonGraph(sigma_k3, rho_k3)\n\nprint(f\"K₃ con numeración salteada:\")\nprint(f\"  σ = {R_k3.sigma()}\")\nprint(f\"  ρ = {R_k3.rho()}\")\nprint(f\"  Números usados: 10, 11, 12, 13, 14, 15\")\n\n# normalize() renumera del 1 al número de semiaristas\nR_norm = R_k3.normalize()\n\nprint(f\"\\nDespués de normalize():\")\nprint(f\"  σ = {R_norm.sigma()}\")\nprint(f\"  ρ = {R_norm.rho()}\")\nprint(f\"  Números usados: 1, 2, 3, 4, 5, 6\")\n\n# Verificar que la estructura se preserva\nprint(f\"\\nVértices: {len(R_k3.sigma().cycle_tuples())} → {len(R_norm.sigma().cycle_tuples())}\")\nprint(f\"Aristas: {len(R_k3.rho().cycle_tuples())} → {len(R_norm.rho().cycle_tuples())}\")\n\n\n\nPodemos calcular programáticamente cuántos sistemas de rotación existen para un grafo dado:\ndef contar_sistemas(R):\n    \"\"\"\n    Calcula N(G) = ∏(deg(v) - 1)! para un RibbonGraph\n    \"\"\"\n    grados = [len(ciclo) for ciclo in R.sigma().cycle_tuples(singletons=True)]\n    total = 1\n    for g in grados:\n        total *= factorial(g - 1)\n    return total, grados\n\n# Verificar con el Ejemplo 1: Un vértice, dos lazos\nsigma1 = PermutationGroupElement(\"(1,2,3,4)\")\nrho1 = PermutationGroupElement(\"(1,2)(3,4)\")\nR1 = RibbonGraph(sigma1, rho1)\n\ntotal1, grados1 = contar_sistemas(R1)\nprint(f\"Ejemplo 1: Un vértice, dos lazos\")\nprint(f\"  Grados de vértices: {grados1}\")\nprint(f\"  N(G) = (4-1)! = {total1}\")\n\n# Verificar con el Ejemplo 2: K₃\nsigma2 = PermutationGroupElement(\"(1,6)(2,3)(4,5)\")\nrho2 = PermutationGroupElement(\"(1,2)(3,4)(5,6)\")\nR2 = RibbonGraph(sigma2, rho2)\n\ntotal2, grados2 = contar_sistemas(R2)\nprint(f\"\\nEjemplo 2: Triángulo K₃\")\nprint(f\"  Grados de vértices: {grados2}\")\nprint(f\"  N(G) = (1!)³ = {total2}\")\n\n\n\n\n\n\n\n\n\n\n\nTipEjercicio 1\n\n\n\nConsidera un grafo con un vértice y tres self-loops (tres aristas que comienzan y terminan en el mismo vértice).\n\n¿Cuántas semiaristas tiene este sistema?\n¿Cuántos sistemas de rotación posibles existen para este grafo? Usa la fórmula manualmente.\nEscribe en Sage un sistema de rotación \\((\\sigma, \\rho)\\) para este grafo usando PermutationGroupElement.\nUsa la función contar_sistemas(R) del ejemplo para verificar tu cálculo del inciso (b).\n\n\n\n\n\n\n\n\n\nTipEjercicio 2\n\n\n\nExperimentando con numeración y normalización:\n\nCrea un RibbonGraph usando numeración salteada (por ejemplo, usando solo números pares o múltiplos de 5).\nUsa el método .normalize() para obtener la versión canónica.\nVerifica que el número de semiaristas se preserva usando len(R.sigma().domain()).\n¿Qué propiedades del grafo cambian con normalize() y cuáles se preservan?\n\n\n\n\n\n\n\n\n[GGD2011] E. Girondo, G. Gonzalez-Diez, Introduction to Compact Riemann surfaces and Dessins d’enfant, London Mathematical Society, Student Text 79, 2011.\n[LZ2004] S. Lando, A. Zvonkine, Graphs on Surfaces and Their Applications, Springer-Verlag, 2004.\n[Edmonds1960] J. Edmonds, A Combinatorial Representation for Polyhedral Surfaces, Notices Amer. Math. Soc. 7, 1960. (Tesis disponible en UMD)\n[Youngs1963] J. W. T. Youngs, The Genus of a Graph, Journal of Mathematics and Mechanics, Vol. 12, No. 2, 1963. JSTOR",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#motivación",
    "href": "capitulos/01-sistemas-rotacion.html#motivación",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Queremos codificar encajes celulares de grafos en superficies orientables sin dibujar la superficie, usando sólo datos combinatorios.\n\nEntrada: un grafo abstracto \\(G\\)\nDato extra: un sistema de rotación (orden cíclico local)\nSalida: una superficie orientable donde \\(G\\) queda encajado, más las caras y el género\n\nLa idea es que la información “local” (en vértices) determine completamente la estructura “global” (la superficie).",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#semiaristas-darts-o-half-edges",
    "href": "capitulos/01-sistemas-rotacion.html#semiaristas-darts-o-half-edges",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Para trabajar con sistemas de rotación, descomponemos cada arista del grafo \\(G\\) mediante una partición formal. Insertamos un vértice ficticio (o de paso) en el interior de cada arista, lo que resulta en un conjunto \\(D\\) de semiaristas (también llamadas darts o half-edges).\nEsta construcción garantiza que:\n\nPartición por Arista: Cada arista original queda particionada exactamente en dos semiaristas que comparten el vértice ficticio.\nIncidencia en Vértices Originales: Cada semiarista \\(d \\in D\\) tiene un extremo en un vértice original de \\(G\\) y el otro en un vértice ficticio. Decimos que \\(d\\) está asociada al vértice original donde incide.\nRelación de Adyacencia (Involución): Dos semiaristas son adyacentes si comparten el mismo vértice ficticio. Esto define una permutación \\(\\rho: D \\to D\\) compuesta por trasposiciones (2-ciclos), donde cada ciclo vincula el par de semiaristas que conforman una arista original.\n\n\n\n\n\n\n\nNotaConteo de semiaristas\n\n\n\nSi el grafo tiene \\(E\\) aristas, tendremos \\(|D| = 2E\\) semiaristas en total, donde \\(D\\) es el conjunto de todas las semiaristas.",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#ejemplo-1-un-vértice-dos-lazos",
    "href": "capitulos/01-sistemas-rotacion.html#ejemplo-1-un-vértice-dos-lazos",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Consideremos el grafo con un vértice y dos aristas.\n\n\n\nVértices: 1\nAristas: 2 aristas\nSemiaristas: 4 (etiquetadas 1, 2, 3, 4)\n\n\n\n\nEtiquetado de semiaristas",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#definición-sistema-de-rotación",
    "href": "capitulos/01-sistemas-rotacion.html#definición-sistema-de-rotación",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Un sistema de rotación sobre un grafo \\(G\\) se define por un par de permutaciones \\((\\sigma, \\rho)\\) sobre el conjunto de semiaristas \\(D\\):\n\n\n\nEs un producto de ciclos disjuntos\nHay un ciclo por cada vértice de \\(G\\)\nCada ciclo describe el orden cíclico de las semiaristas incidentes a ese vértice\nEl orden cíclico refleja cómo las aristas se ordenan alrededor del vértice en la superficie\n\n\n\n\n\nEs un producto de 2-ciclos (transposiciones)\nCada 2-ciclo empareja las dos semiaristas que forman una arista\nEs una involución sin puntos fijos: \\(\\rho^2 = \\mathrm{id}\\)\n\n\n\n\n\n\n\nNotaContexto Histórico y Terminología\n\n\n\nLos sistemas de rotación tienen una rica historia y han sido redescubiertos en múltiples contextos:\n\nOrígenes: Fueron introducidos por Edmonds (1960) y formalizados por Youngs (1963), quien también introdujo sistemas con signo para superficies no orientables. Representaciones similares fueron propuestas independientemente por Jacques, Biggs, y Walsh & Lehman.\nDesarrollo: Tutte y Gross & Alpert extendieron estos sistemas. El encaje celular inducido que revisaremos más adelante es frecuentemente llamado encaje de Heffter-Edmonds.\nSinónimos: En la literatura se encuentran como vortex graphs, constelaciones, mapas combinatorios, fat graphs, ribbon graphs y dessins d’enfants.\n\nNuestra Convención: Adoptamos la notación de SageMath y Lando & Zvonkin, usando el par de permutaciones \\((\\sigma, \\rho)\\) sobre semiaristas y refiriéndonos a la estructura topológica como Ribbon Graph.",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#ejemplo-un-vértice-dos-lazos",
    "href": "capitulos/01-sistemas-rotacion.html#ejemplo-un-vértice-dos-lazos",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Recordando la construcción del ejemplo anterior:\n\n\nVértices: 1\nAristas: 2\nSemiaristas: 4 (etiquetadas 1, 2, 3, 4)\n\nEs importante notar que \\(\\rho\\) está fijo por la construcción del grafo (la elección de qué pares de semiaristas forman cada arista). Por lo tanto, solo podemos variar \\(\\sigma\\).\nComo tenemos 4 semiaristas incidentes al mismo vértice, el número de posibles órdenes cíclicos es \\((4-1)! = 6\\). A continuación listamos todas las posibilidades:\n\n\\(\\sigma = (1, 2, 3, 4)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 2, 4, 3)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 3, 2, 4)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 3, 4, 2)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 4, 2, 3)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 4, 3, 2)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\nCada una de estas elecciones define un sistema de rotación válido. En las siguientes secciones veremos cómo estas permutaciones determinan la topología de la superficie resultante.",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#ejemplo-2-triángulo-k₃",
    "href": "capitulos/01-sistemas-rotacion.html#ejemplo-2-triángulo-k₃",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Consideremos el grafo completo con 3 vértices: \\(K_3\\):\n\n\n\n\nVértices: 3 (A, B, C)\nAristas: 3 (AB, BC, CA)\nSemiaristas: 6 (etiquetadas 1, 2, 3, 4, 5, 6)\n\nAsignación de semiaristas:\n\nVértice A: semiaristas 1, 6\nVértice B: semiaristas 2, 3\nVértice C: semiaristas 4, 5\n\nAristas:\n\nAB: semiaristas 1 y 2\nBC: semiaristas 3 y 4\nCA: semiaristas 5 y 6\n\nPara definir el sistema de rotación, la asignación explícita de semiaristas es necesaria para fijar \\(\\rho\\).\n\n\\(\\rho\\): Queda determinado por los pares que forman las aristas. \\[\\rho = (1, 2)(3, 4)(5, 6)\\]\n\\(\\sigma\\): En este caso, como cada vértice tiene grado 2, existe un único orden cíclico posible para las semiaristas incidentes (\\((a,b)\\) es equivalente a \\((b,a)\\)). \\[\\sigma = (1, 6)(2, 3)(4, 5)\\]\n\nEste sistema describe el encaje estándar de \\(K_3\\) en la esfera (género 0).",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#el-big-bang-combinatorio-cuántos-encajes-existen",
    "href": "capitulos/01-sistemas-rotacion.html#el-big-bang-combinatorio-cuántos-encajes-existen",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Para un grafo dado (sin vértices aislados), podemos calcular exactamente cuántos Sistemas de Rotación (que generan superficies orientables) se pueden construir. La fórmula depende enteramente de la conectividad local de los vértices.\n\n\nSi llamamos \\(N(G)\\) al número total de sistemas de rotación para un grafo \\(G\\), tenemos:\n\\[ N(G) = \\prod_{v \\in V(G)} (\\deg(v) - 1)! \\]\nDonde:\n\n\\(\\prod\\): Es el símbolo de producto (multiplicamos el resultado de cada vértice).\n\\(V(G)\\): Es el conjunto de todos los vértices del grafo.\n\\(\\deg(v)\\) (Grado): Es el número de semiaristas que llegan al vértice \\(v\\).\n\\((\\deg(v) - 1)!\\): Es el número de formas de organizar las semiaristas en un círculo (permutaciones cíclicas).\n\n\n\n\n\n\nEl grafo de un vértice y dos lazos:\n\nTenemos 1 vértice con grado \\(4\\).\nCálculo: \\((4-1)! = 6\\) sistemas.\nResultado: Coincide exactamente con la lista de \\(6\\) que vimos anteriormente.\n\nEl Triángulo (\\(K_3\\)):\n\nTenemos 3 vértices, cada uno con grado \\(2\\).\nCálculo: \\((2-1)! \\times (2-1)! \\times (2-1)! = 1\\) sistema.\nResultado: Por eso el \\(K_3\\) es “rígido”; solo puede encajarse de una forma (en la esfera).\n\n\n\n\n\n\nA medida que añadimos vértices y cada uno se conecta con todos los demás, el número de universos topológicos posibles crece de forma estrepitosa:\n\n\n\nGrafo\nVértices\nGrado\nFórmula\nTotal de Sistemas\n\n\n\n\n\\(K_3\\) (Triángulo)\n3\n2\n\\((1!)^3\\)\n1\n\n\n\\(K_4\\) (Tetraedro)\n4\n3\n\\((2!)^4\\)\n16\n\n\n\\(K_5\\) (Pentáculo)\n5\n4\n\\((3!)^5\\)\n7,776\n\n\n\\(K_6\\)\n6\n5\n\\((4!)^6\\)\n191,102,976\n\n\n\\(K_7\\)\n7\n6\n\\((5!)^7\\)\n358,318,080,000,000\n\n\n\n\nNota para la reflexión: ¡Para un simple grafo de 7 vértices, existen más de 358 billones de formas de encajarlo en superficies! La gran mayoría de estas formas resultarán en superficies con muchísimos “agujeros” (género alto), y solo unas pocas tendrán género mínimo (\\(K_7\\) no es planar).",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#interpretación-geométrica",
    "href": "capitulos/01-sistemas-rotacion.html#interpretación-geométrica",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "El sistema de rotación \\((\\sigma, \\rho)\\) codifica:\n\nEl grafo subyacente\n\nLos ciclos de \\(\\sigma\\) determinan los vértices\nLos 2-ciclos de \\(\\rho\\) determinan las aristas\nPodemos reconstruir \\(G\\) desde \\((\\sigma, \\rho)\\)\n\nEl orden cíclico local\n\nCada ciclo de \\(\\sigma\\) indica cómo se ordenan las semiaristas alrededor de un vértice\nEste orden respeta la orientación de la superficie",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#construcción-en-sagemath",
    "href": "capitulos/01-sistemas-rotacion.html#construcción-en-sagemath",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "SageMath implementa ribbon graphs directamente desde sistemas de rotación:\nPuedes verificar estos cálculos rápidamente en línea usando SageMathCell.\n\n\nConstruyamos el sistema de rotación más estándar para este grafo:\n# Usamos PermutationGroupElement directamente\nsigma = PermutationGroupElement(\"(1,2,3,4)\")\nrho = PermutationGroupElement(\"(1,2)(3,4)\")\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Objeto creado: {R}\")\nprint(f\"Tipo: {type(R).__name__}\")\n\n# Recuperar las permutaciones almacenadas\nprint(f\"\\nPermutaciones:\")\nprint(f\"  σ = {R.sigma()}\")\nprint(f\"  ρ = {R.rho()}\")\n\n# Contar elementos del grafo\nnum_semiaristas = len(R.sigma().domain())\nnum_vertices = len(R.sigma().cycle_tuples(singletons=True))\nnum_aristas = len(R.rho().cycle_tuples())\n\nprint(f\"\\nEstructura del grafo:\")\nprint(f\"  Semiaristas: {num_semiaristas}\")\nprint(f\"  Vértices: {num_vertices}\")\nprint(f\"  Aristas: {num_aristas}\")\n\n\n\nPodemos etiquetar las semiaristas con cualquier numeración, no necesariamente 1,2,3,…\n# K₃ con numeración consecutiva empezando desde 10\nsigma_k3 = PermutationGroupElement(\"(10,15)(11,12)(13,14)\")\nrho_k3 = PermutationGroupElement(\"(10,11)(12,13)(14,15)\")\nR_k3 = RibbonGraph(sigma_k3, rho_k3)\n\nprint(f\"K₃ con numeración salteada:\")\nprint(f\"  σ = {R_k3.sigma()}\")\nprint(f\"  ρ = {R_k3.rho()}\")\nprint(f\"  Números usados: 10, 11, 12, 13, 14, 15\")\n\n# normalize() renumera del 1 al número de semiaristas\nR_norm = R_k3.normalize()\n\nprint(f\"\\nDespués de normalize():\")\nprint(f\"  σ = {R_norm.sigma()}\")\nprint(f\"  ρ = {R_norm.rho()}\")\nprint(f\"  Números usados: 1, 2, 3, 4, 5, 6\")\n\n# Verificar que la estructura se preserva\nprint(f\"\\nVértices: {len(R_k3.sigma().cycle_tuples())} → {len(R_norm.sigma().cycle_tuples())}\")\nprint(f\"Aristas: {len(R_k3.rho().cycle_tuples())} → {len(R_norm.rho().cycle_tuples())}\")\n\n\n\nPodemos calcular programáticamente cuántos sistemas de rotación existen para un grafo dado:\ndef contar_sistemas(R):\n    \"\"\"\n    Calcula N(G) = ∏(deg(v) - 1)! para un RibbonGraph\n    \"\"\"\n    grados = [len(ciclo) for ciclo in R.sigma().cycle_tuples(singletons=True)]\n    total = 1\n    for g in grados:\n        total *= factorial(g - 1)\n    return total, grados\n\n# Verificar con el Ejemplo 1: Un vértice, dos lazos\nsigma1 = PermutationGroupElement(\"(1,2,3,4)\")\nrho1 = PermutationGroupElement(\"(1,2)(3,4)\")\nR1 = RibbonGraph(sigma1, rho1)\n\ntotal1, grados1 = contar_sistemas(R1)\nprint(f\"Ejemplo 1: Un vértice, dos lazos\")\nprint(f\"  Grados de vértices: {grados1}\")\nprint(f\"  N(G) = (4-1)! = {total1}\")\n\n# Verificar con el Ejemplo 2: K₃\nsigma2 = PermutationGroupElement(\"(1,6)(2,3)(4,5)\")\nrho2 = PermutationGroupElement(\"(1,2)(3,4)(5,6)\")\nR2 = RibbonGraph(sigma2, rho2)\n\ntotal2, grados2 = contar_sistemas(R2)\nprint(f\"\\nEjemplo 2: Triángulo K₃\")\nprint(f\"  Grados de vértices: {grados2}\")\nprint(f\"  N(G) = (1!)³ = {total2}\")",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#ejercicios",
    "href": "capitulos/01-sistemas-rotacion.html#ejercicios",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "TipEjercicio 1\n\n\n\nConsidera un grafo con un vértice y tres self-loops (tres aristas que comienzan y terminan en el mismo vértice).\n\n¿Cuántas semiaristas tiene este sistema?\n¿Cuántos sistemas de rotación posibles existen para este grafo? Usa la fórmula manualmente.\nEscribe en Sage un sistema de rotación \\((\\sigma, \\rho)\\) para este grafo usando PermutationGroupElement.\nUsa la función contar_sistemas(R) del ejemplo para verificar tu cálculo del inciso (b).\n\n\n\n\n\n\n\n\n\nTipEjercicio 2\n\n\n\nExperimentando con numeración y normalización:\n\nCrea un RibbonGraph usando numeración salteada (por ejemplo, usando solo números pares o múltiplos de 5).\nUsa el método .normalize() para obtener la versión canónica.\nVerifica que el número de semiaristas se preserva usando len(R.sigma().domain()).\n¿Qué propiedades del grafo cambian con normalize() y cuáles se preservan?",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#referencias",
    "href": "capitulos/01-sistemas-rotacion.html#referencias",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "[GGD2011] E. Girondo, G. Gonzalez-Diez, Introduction to Compact Riemann surfaces and Dessins d’enfant, London Mathematical Society, Student Text 79, 2011.\n[LZ2004] S. Lando, A. Zvonkine, Graphs on Surfaces and Their Applications, Springer-Verlag, 2004.\n[Edmonds1960] J. Edmonds, A Combinatorial Representation for Polyhedral Surfaces, Notices Amer. Math. Soc. 7, 1960. (Tesis disponible en UMD)\n[Youngs1963] J. W. T. Youngs, The Genus of a Graph, Journal of Mathematics and Mechanics, Vol. 12, No. 2, 1963. JSTOR",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/03-invariantes.html",
    "href": "capitulos/03-invariantes.html",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Una vez que tenemos un sistema de rotación \\((\\sigma, \\rho)\\), podemos calcular todos los invariantes topológicos de la superficie resultante sin necesidad de visualizarla. Los cálculos se hacen directamente sobre las permutaciones.\nLos invariantes principales son:\n\nNúmero de vértices (\\(V\\))\nNúmero de aristas (\\(E\\))\nNúmero de caras (\\(F\\))\nCaracterística de Euler (\\(\\chi = V - E + F\\))\nGénero (\\(g\\))\nComponentes de frontera (\\(b\\))\n\n\n\n\nComo vimos en el capítulo anterior, las caras del encaje están determinadas por los ciclos de la permutación: \\[ \\varphi = \\rho \\sigma \\]\nEl número de caras \\(F\\) es simplemente el número de ciclos disjuntos en \\(\\varphi\\). Este dato es la pieza faltante para conectar la combinatoria con la topología.\n\n\n\n\nSageMath calcula automáticamente todas las caras:\nfrom sage.graphs.ribbon_graph import RibbonGraph\nfrom sage.all import PermutationGroupElement\n\n# Ejemplo: toro\nsigma = PermutationGroupElement('(1,3,2,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Obtener las caras (componentes de frontera)\ncaras = list(R.faces())\nprint(f\"Número de caras: {len(caras)}\")\nprint(f\"Caras: {caras}\")\n\n# También podemos usar boundary()\nfronteras = R.boundary()\nprint(f\"Componentes de frontera: {fronteras}\")\nSalida:\nNúmero de caras: 1\nCaras: [[1, 4, 3, 2]]\nComponentes de frontera: [[1, 4, 3, 2]]\n\n\n\n\nUna vez conocemos \\(V\\), \\(E\\) y \\(F\\), calculamos la característica de Euler:\n\\[\n\\chi = V - E + F\n\\]\n\n\n\n\\(V\\) = número de ciclos de \\(\\sigma\\)\n\\(E\\) = número de 2-ciclos de \\(\\rho\\) = \\(|D|/2\\) (donde \\(|D|\\) es el número de semiaristas)\n\\(F\\) = número de ciclos de \\(\\varphi\\)\n\n\n# Ejemplo\nsigma = PermutationGroupElement('(1,3,2,4)')  # 1 ciclo → V = 1\nrho = PermutationGroupElement('(1,2)(3,4)')   # 2 ciclos → E = 2\n# D = 4 semiaristas\n\nR = RibbonGraph(sigma, rho)\n\nV = R.num_vertices()             # 1\nE = R.num_edges()                # 2\nF = len(list(R.faces()))         # 1\n\nchi = V - E + F\nprint(f\"χ = {V} - {E} + {F} = {chi}\")\nSalida:\nχ = 1 - 2 + 1 = 0\n\n\n\n\n\nPara superficies orientables cerradas (sin frontera), la relación es:\n\\[\n\\chi = 2 - 2g\n\\]\nDe donde: \\[\ng = 1 - \\frac{\\chi}{2} = \\frac{2-\\chi}{2}\n\\]\n\n\nPara superficies con frontera, la fórmula se generaliza:\n\\[\n\\chi = 2 - 2g - b\n\\]\ndonde \\(b\\) es el número de componentes de frontera.\nDe aquí: \\[\ng = \\frac{2 - \\chi - b}{2}\n\\]\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Sage calcula directamente\ng = R.genus()\nb = R.number_boundaries()\n\nprint(f\"Género: {g}\")\nprint(f\"Componentes de frontera: {b}\")\n\n# Verificar con la fórmula\nchi = R.num_vertices() - R.num_edges() + len(list(R.faces()))\ng_calculado = (2 - chi - b) // 2\n\nprint(f\"Verificación: g = (2 - {chi} - {b})/2 = {g_calculado}\")\nSalida:\nGénero: 1\nComponentes de frontera: 0\nVerificación: g = (2 - 0 - 0)/2 = 1\n\n\n\n\n\n\n\n# Sistema con frontera\nsigma = PermutationGroupElement('(1,2,3)')\nrho = PermutationGroupElement('(1,2)')\nR = RibbonGraph(sigma, rho)\nprint(f\"Género: {R.genus()}\")\nprint(f\"Fronteras: {R.number_boundaries()}\")\n# Resultado: g=0, b=1 (Disco)\n\n\n\n# K₃ con encaje planar\nR = RibbonGraph('(1,6)(2,3)(4,5)', '(1,2)(3,4)(5,6)')\nprint(f\"Género: {R.genus()}\")\n# Resultado: g=0 (Esfera)\n\n\n\n# Un vértice con 3 self-loops\nR = RibbonGraph('(1,2,3,4,5,6)', '(1,2)(3,4)(5,6)')\nprint(f\"Género: {R.genus()}\")\n# Resultado: g=1 (Toro con 1 frontera si b=1, o Toro cerrado si b=0?)\n# Verifiquemos: V=1, E=3. Si F=1 -&gt; 1-3+1 = -1. Imposible para cerrada.\n# Debe ser superficie con frontera.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEjemplo\n\\(\\sigma\\)\n\\(\\rho\\)\n\\(V\\)\n\\(E\\)\n\\(F\\)\n\\(\\chi\\)\n\\(g\\)\n\\(b\\)\n\n\n\n\nToro\n\\((1,2,3,4)\\)\n\\((1,2)(3,4)\\)\n1\n2\n1\n0\n1\n0\n\n\nCilindro\n\\((1,2,3)\\)\n\\((1,2)\\)\n1\n1\n2\n0\n0\n2\n\n\nK₃ plano\n\\((1,6)(2,3)(4,5)\\)\n\\((1,2)(3,4)(5,6)\\)\n3\n3\n2\n2\n0\n0\n\n\nBouquet 3\n\\((1,2,3,4,5,6)\\)\n\\((1,2)(3,4)(5,6)\\)\n1\n3\n4\n2\n0\n4\n\n\n\n\n\n\nPodemos crear una función para calcular todos los invariantes:\n\ndef calcular_invariantes(sigma, rho):\n    \"\"\"\n    Calcula todos los invariantes topológicos de un sistema de rotación.\n    \"\"\"\n    # Asegurar que son permutaciones si se pasan strings\n    if isinstance(sigma, str): sigma = PermutationGroupElement(sigma)\n    if isinstance(rho, str): rho = PermutationGroupElement(rho)\n\n    R = RibbonGraph(sigma, rho)\n\n    V = R.num_vertices()\n    E = R.num_edges()\n    F = len(list(R.faces()))\n    chi = V - E + F\n    g = R.genus()\n    b = R.number_boundaries()\n\n    print(f\"{'='*50}\")\n    print(f\"Sistema de Rotación\")\n    print(f\"{'='*50}\")\n    print(f\"σ = {sigma}\")\n    print(f\"ρ = {rho}\")\n    print(f\"{'-'*50}\")\n    print(f\"Vértices (V):              {V}\")\n    print(f\"Aristas (E):               {E}\")\n    print(f\"Caras (F):                 {F}\")\n    print(f\"Característica de Euler:   χ = {chi}\")\n    print(f\"Género:                    g = {g}\")\n    print(f\"Componentes de frontera:   b = {b}\")\n    print(f\"{'='*50}\")\n    print(f\"Fórmula: χ = 2 - 2g - b = {2 - 2*g - b} ✓\")\n    print(f\"{'='*50}\")\n\n    return {\n        'V': V, 'E': E, 'F': F,\n        'chi': chi, 'g': g, 'b': b\n    }\n\n# Uso\ninv = calcular_invariantes('(1,2,3,4)', '(1,2)(3,4)')\n\n\n\n\n\n\n\n\n\n\nTipEjercicio 1: Crear tu propio ejemplo\n\n\n\nDiseña un sistema de rotación que produzca:\n\nUn bitoro (género 2, sin frontera)\nUna esfera con 3 agujeros (g=0, b=3)\nUn toro con 2 agujeros (g=1, b=2)\n\nVerifica tus construcciones con Sage.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Variaciones del bouquet\n\n\n\nExperimenta con el bouquet de 4 círculos (8 semiaristas):\n\nPrueba diferentes órdenes cíclicos en \\(\\sigma\\)\nCalcula el género para cada caso\n¿Cuál es el género máximo que puedes obtener?\n¿Cuál es el género mínimo?\n\n\n\n\n\n\n\n\n\nTipEjercicio 3: Grafos completos\n\n\n\nInvestiga los grafos completos \\(K_n\\):\n\nVerifica que K₃ tiene género 0\nCalcula el género mínimo de K₄\nBusca en la literatura el género de K₅ y K₆\n\n\n\n\n\n\n\n\nCálculo de invariantes: Se obtienen contando ciclos en las permutaciones, sin necesidad de visualización.\nElementos: \\(V\\) (ciclos de \\(\\sigma\\)), \\(E\\) (ciclos de \\(\\rho\\)), \\(F\\) (ciclos de \\(\\varphi = \\rho \\sigma\\)).\nFórmulas topológicas:\n\nCaracterística de Euler: \\(\\chi = V - E + F\\)\nGénero: \\(g = \\frac{2 - \\chi - b}{2}\\)\n\nSageMath: R.genus(), R.number_boundaries() y R.faces() para el cálculo automático.\n\nEn el siguiente capítulo estudiaremos los teoremas fundamentales que establecen la equivalencia entre sistemas de rotación y encajes celulares (Teorema de Heffter-Edmonds) y las propiedades de los mapas combinatorios."
  },
  {
    "objectID": "capitulos/03-invariantes.html#introducción",
    "href": "capitulos/03-invariantes.html#introducción",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Una vez que tenemos un sistema de rotación \\((\\sigma, \\rho)\\), podemos calcular todos los invariantes topológicos de la superficie resultante sin necesidad de visualizarla. Los cálculos se hacen directamente sobre las permutaciones.\nLos invariantes principales son:\n\nNúmero de vértices (\\(V\\))\nNúmero de aristas (\\(E\\))\nNúmero de caras (\\(F\\))\nCaracterística de Euler (\\(\\chi = V - E + F\\))\nGénero (\\(g\\))\nComponentes de frontera (\\(b\\))"
  },
  {
    "objectID": "capitulos/03-invariantes.html#recapitulación-caras-y-varphi",
    "href": "capitulos/03-invariantes.html#recapitulación-caras-y-varphi",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Como vimos en el capítulo anterior, las caras del encaje están determinadas por los ciclos de la permutación: \\[ \\varphi = \\rho \\sigma \\]\nEl número de caras \\(F\\) es simplemente el número de ciclos disjuntos en \\(\\varphi\\). Este dato es la pieza faltante para conectar la combinatoria con la topología."
  },
  {
    "objectID": "capitulos/03-invariantes.html#cálculo-en-sagemath",
    "href": "capitulos/03-invariantes.html#cálculo-en-sagemath",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "SageMath calcula automáticamente todas las caras:\nfrom sage.graphs.ribbon_graph import RibbonGraph\nfrom sage.all import PermutationGroupElement\n\n# Ejemplo: toro\nsigma = PermutationGroupElement('(1,3,2,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Obtener las caras (componentes de frontera)\ncaras = list(R.faces())\nprint(f\"Número de caras: {len(caras)}\")\nprint(f\"Caras: {caras}\")\n\n# También podemos usar boundary()\nfronteras = R.boundary()\nprint(f\"Componentes de frontera: {fronteras}\")\nSalida:\nNúmero de caras: 1\nCaras: [[1, 4, 3, 2]]\nComponentes de frontera: [[1, 4, 3, 2]]"
  },
  {
    "objectID": "capitulos/03-invariantes.html#característica-de-euler",
    "href": "capitulos/03-invariantes.html#característica-de-euler",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Una vez conocemos \\(V\\), \\(E\\) y \\(F\\), calculamos la característica de Euler:\n\\[\n\\chi = V - E + F\n\\]\n\n\n\n\\(V\\) = número de ciclos de \\(\\sigma\\)\n\\(E\\) = número de 2-ciclos de \\(\\rho\\) = \\(|D|/2\\) (donde \\(|D|\\) es el número de semiaristas)\n\\(F\\) = número de ciclos de \\(\\varphi\\)\n\n\n# Ejemplo\nsigma = PermutationGroupElement('(1,3,2,4)')  # 1 ciclo → V = 1\nrho = PermutationGroupElement('(1,2)(3,4)')   # 2 ciclos → E = 2\n# D = 4 semiaristas\n\nR = RibbonGraph(sigma, rho)\n\nV = R.num_vertices()             # 1\nE = R.num_edges()                # 2\nF = len(list(R.faces()))         # 1\n\nchi = V - E + F\nprint(f\"χ = {V} - {E} + {F} = {chi}\")\nSalida:\nχ = 1 - 2 + 1 = 0"
  },
  {
    "objectID": "capitulos/03-invariantes.html#género",
    "href": "capitulos/03-invariantes.html#género",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Para superficies orientables cerradas (sin frontera), la relación es:\n\\[\n\\chi = 2 - 2g\n\\]\nDe donde: \\[\ng = 1 - \\frac{\\chi}{2} = \\frac{2-\\chi}{2}\n\\]\n\n\nPara superficies con frontera, la fórmula se generaliza:\n\\[\n\\chi = 2 - 2g - b\n\\]\ndonde \\(b\\) es el número de componentes de frontera.\nDe aquí: \\[\ng = \\frac{2 - \\chi - b}{2}\n\\]\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Sage calcula directamente\ng = R.genus()\nb = R.number_boundaries()\n\nprint(f\"Género: {g}\")\nprint(f\"Componentes de frontera: {b}\")\n\n# Verificar con la fórmula\nchi = R.num_vertices() - R.num_edges() + len(list(R.faces()))\ng_calculado = (2 - chi - b) // 2\n\nprint(f\"Verificación: g = (2 - {chi} - {b})/2 = {g_calculado}\")\nSalida:\nGénero: 1\nComponentes de frontera: 0\nVerificación: g = (2 - 0 - 0)/2 = 1"
  },
  {
    "objectID": "capitulos/03-invariantes.html#ejemplos-de-cálculo",
    "href": "capitulos/03-invariantes.html#ejemplos-de-cálculo",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "# Sistema con frontera\nsigma = PermutationGroupElement('(1,2,3)')\nrho = PermutationGroupElement('(1,2)')\nR = RibbonGraph(sigma, rho)\nprint(f\"Género: {R.genus()}\")\nprint(f\"Fronteras: {R.number_boundaries()}\")\n# Resultado: g=0, b=1 (Disco)\n\n\n\n# K₃ con encaje planar\nR = RibbonGraph('(1,6)(2,3)(4,5)', '(1,2)(3,4)(5,6)')\nprint(f\"Género: {R.genus()}\")\n# Resultado: g=0 (Esfera)\n\n\n\n# Un vértice con 3 self-loops\nR = RibbonGraph('(1,2,3,4,5,6)', '(1,2)(3,4)(5,6)')\nprint(f\"Género: {R.genus()}\")\n# Resultado: g=1 (Toro con 1 frontera si b=1, o Toro cerrado si b=0?)\n# Verifiquemos: V=1, E=3. Si F=1 -&gt; 1-3+1 = -1. Imposible para cerrada.\n# Debe ser superficie con frontera."
  },
  {
    "objectID": "capitulos/03-invariantes.html#tabla-de-ejemplos",
    "href": "capitulos/03-invariantes.html#tabla-de-ejemplos",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Ejemplo\n\\(\\sigma\\)\n\\(\\rho\\)\n\\(V\\)\n\\(E\\)\n\\(F\\)\n\\(\\chi\\)\n\\(g\\)\n\\(b\\)\n\n\n\n\nToro\n\\((1,2,3,4)\\)\n\\((1,2)(3,4)\\)\n1\n2\n1\n0\n1\n0\n\n\nCilindro\n\\((1,2,3)\\)\n\\((1,2)\\)\n1\n1\n2\n0\n0\n2\n\n\nK₃ plano\n\\((1,6)(2,3)(4,5)\\)\n\\((1,2)(3,4)(5,6)\\)\n3\n3\n2\n2\n0\n0\n\n\nBouquet 3\n\\((1,2,3,4,5,6)\\)\n\\((1,2)(3,4)(5,6)\\)\n1\n3\n4\n2\n0\n4"
  },
  {
    "objectID": "capitulos/03-invariantes.html#implementación-función-auxiliar",
    "href": "capitulos/03-invariantes.html#implementación-función-auxiliar",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Podemos crear una función para calcular todos los invariantes:\n\ndef calcular_invariantes(sigma, rho):\n    \"\"\"\n    Calcula todos los invariantes topológicos de un sistema de rotación.\n    \"\"\"\n    # Asegurar que son permutaciones si se pasan strings\n    if isinstance(sigma, str): sigma = PermutationGroupElement(sigma)\n    if isinstance(rho, str): rho = PermutationGroupElement(rho)\n\n    R = RibbonGraph(sigma, rho)\n\n    V = R.num_vertices()\n    E = R.num_edges()\n    F = len(list(R.faces()))\n    chi = V - E + F\n    g = R.genus()\n    b = R.number_boundaries()\n\n    print(f\"{'='*50}\")\n    print(f\"Sistema de Rotación\")\n    print(f\"{'='*50}\")\n    print(f\"σ = {sigma}\")\n    print(f\"ρ = {rho}\")\n    print(f\"{'-'*50}\")\n    print(f\"Vértices (V):              {V}\")\n    print(f\"Aristas (E):               {E}\")\n    print(f\"Caras (F):                 {F}\")\n    print(f\"Característica de Euler:   χ = {chi}\")\n    print(f\"Género:                    g = {g}\")\n    print(f\"Componentes de frontera:   b = {b}\")\n    print(f\"{'='*50}\")\n    print(f\"Fórmula: χ = 2 - 2g - b = {2 - 2*g - b} ✓\")\n    print(f\"{'='*50}\")\n\n    return {\n        'V': V, 'E': E, 'F': F,\n        'chi': chi, 'g': g, 'b': b\n    }\n\n# Uso\ninv = calcular_invariantes('(1,2,3,4)', '(1,2)(3,4)')"
  },
  {
    "objectID": "capitulos/03-invariantes.html#ejercicios",
    "href": "capitulos/03-invariantes.html#ejercicios",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "TipEjercicio 1: Crear tu propio ejemplo\n\n\n\nDiseña un sistema de rotación que produzca:\n\nUn bitoro (género 2, sin frontera)\nUna esfera con 3 agujeros (g=0, b=3)\nUn toro con 2 agujeros (g=1, b=2)\n\nVerifica tus construcciones con Sage.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Variaciones del bouquet\n\n\n\nExperimenta con el bouquet de 4 círculos (8 semiaristas):\n\nPrueba diferentes órdenes cíclicos en \\(\\sigma\\)\nCalcula el género para cada caso\n¿Cuál es el género máximo que puedes obtener?\n¿Cuál es el género mínimo?\n\n\n\n\n\n\n\n\n\nTipEjercicio 3: Grafos completos\n\n\n\nInvestiga los grafos completos \\(K_n\\):\n\nVerifica que K₃ tiene género 0\nCalcula el género mínimo de K₄\nBusca en la literatura el género de K₅ y K₆"
  },
  {
    "objectID": "capitulos/03-invariantes.html#resumen",
    "href": "capitulos/03-invariantes.html#resumen",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Cálculo de invariantes: Se obtienen contando ciclos en las permutaciones, sin necesidad de visualización.\nElementos: \\(V\\) (ciclos de \\(\\sigma\\)), \\(E\\) (ciclos de \\(\\rho\\)), \\(F\\) (ciclos de \\(\\varphi = \\rho \\sigma\\)).\nFórmulas topológicas:\n\nCaracterística de Euler: \\(\\chi = V - E + F\\)\nGénero: \\(g = \\frac{2 - \\chi - b}{2}\\)\n\nSageMath: R.genus(), R.number_boundaries() y R.faces() para el cálculo automático.\n\nEn el siguiente capítulo estudiaremos los teoremas fundamentales que establecen la equivalencia entre sistemas de rotación y encajes celulares (Teorema de Heffter-Edmonds) y las propiedades de los mapas combinatorios."
  },
  {
    "objectID": "notas/ejemplos.html",
    "href": "notas/ejemplos.html",
    "title": "Ejemplos Clásicos de Ribbon Graphs",
    "section": "",
    "text": "Permutaciones: - σ = (1,2,3)(4,5,6) - ρ = (1,4)(2,5)(3,6)\nInvariantes: - Género: 1 (toro) - Vértices: 2, Aristas: 3, Caras: 1 - Fronteras: 1\n\n\n\n\n\n\nGrafo Base\n\n\n\n\n\n\n\nRibbon Completo\n\n\n\n\n\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\nviz.generar_secuencia_completa(prefix='toro_')\n\n\n\n\n\n\nPermutaciones: - σ = (1,2,3,4) - ρ = (1,2)(3,4)\nInvariantes: - Género: 0 (esfera) - Vértices: 1, Aristas: 2, Caras: 1 - Fronteras: 3\n\n\n\n\n\n\nGrafo Base\n\n\n\n\n\n\n\nRibbon Completo\n\n\n\n\n\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1,2,3,4)', '(1,2)(3,4)')\nviz.generar_secuencia_completa(prefix='selfloop_')\n\n\n\n\n\n\nPermutaciones: - σ = (1,2)(3,4)(5,6) - ρ = (1,3)(2,5)(4,6)\nInvariantes: - Género: 0 (esfera) - Vértices: 3, Aristas: 3, Caras: 2 - Fronteras: 2\n\n\n\n\n\n\nGrafo Base\n\n\n\n\n\n\n\nRibbon Completo\n\n\n\n\n\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1,2)(3,4)(5,6)', '(1,3)(2,5)(4,6)')\nviz.generar_secuencia_completa(prefix='triangulo_')\n\n\n\n\n\n\nPermutaciones: - σ = (1,2,3)(4,5,6) - ρ = (1,6)(2,4)(3,5)\nInvariantes: - Género: 1 (toro) - Vértices: 2, Aristas: 3, Caras: 1 - Fronteras: 1\n\n\n\n\n\n\nGrafo Base\n\n\n\n\n\n\n\nRibbon Completo\n\n\n\n\n\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,6)(2,4)(3,5)')\nviz.generar_secuencia_completa(prefix='theta_')\n\n\nNota: A pesar de tener la misma estructura de σ que el ejemplo 1, el cambio en ρ produce una configuración diferente.\n\n\n\n\nUn bouquet con 3 pétalos:\nPermutaciones: - σ = (1,2,3,4,5,6) - ρ = (1,2)(3,4)(5,6)\nInvariantes: - Género: 0 (esfera) - Vértices: 1, Aristas: 3, Caras: 1 - Fronteras: 4\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1,2,3,4,5,6)', '(1,2)(3,4)(5,6)')\nviz.generar_secuencia_completa(prefix='bouquet_')\n\n\n\n\n\n\nPermutaciones: - σ = (1,2)(3,4)(5,6)(7,8) - ρ = (1,3)(2,5)(4,7)(6,8)\nInvariantes: - Género: 0 (esfera) - Vértices: 4, Aristas: 4, Caras: ? - Fronteras: ?\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1,2)(3,4)(5,6)(7,8)', '(1,3)(2,5)(4,7)(6,8)')\nviz.generar_secuencia_completa(prefix='cuadrado_')\n\n\n\n\n\n\nLa configuración más simple:\nPermutaciones: - σ = (1)(2) - ρ = (1,2)\nInvariantes: - Género: 0 (esfera) - Vértices: 2, Aristas: 1, Caras: 1 - Fronteras: 1\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1)(2)', '(1,2)')\nviz.generar_secuencia_completa(prefix='dumbell_')\n\n\n\n\n\n\n\n\n\nEjemplo\nV\nE\nF\ng\nb\nχ\nDescripción\n\n\n\n\nToro\n2\n3\n1\n1\n1\n-1\n2 vértices, 3 aristas\n\n\nSelf-loops\n1\n2\n1\n0\n3\n-1\n1 vértice, 2 loops\n\n\nTriángulo\n3\n3\n2\n0\n2\n0\nGrafo completo K₃\n\n\nTheta\n2\n3\n1\n1\n1\n-1\n3 aristas paralelas\n\n\nBouquet\n1\n3\n1\n0\n4\n-2\n3 pétalos\n\n\nCuadrado\n4\n4\n?\n0\n?\n?\nCiclo de 4 vértices\n\n\nDumbell\n2\n1\n1\n0\n1\n1\nMás simple\n\n\n\n\n\n\n\n\n\nRibbon graphs con g = 0: - Self-loops - Triángulo K₃ - Bouquet - Dumbell\n\n\n\nRibbon graphs con g = 1: - Toro simple - Theta graph\n\n\n\nPara ribbon graphs en esfera (g=0): - Si V &gt; E: tiende a tener múltiples fronteras - Si V = E: configuración balanceada - Si V &lt; E: no puede existir (violaría χ)\n\n\n\n\n\nPlantilla general:\n\n# Define tus permutaciones\nmi_sigma = '(1,2,3)(...)'\nmi_rho = '(1,?)(2,?)(3,?)...'\n\n# Crear visualizador\nviz = RibbonGraphVisualizer(mi_sigma, mi_rho)\n\n# Ver invariantes\nprint(viz.invariantes())\n\n# Generar visualizaciones\nviz.generar_secuencia_completa(prefix='mi_ejemplo_')\n\n\n\n\n\n\nTutorial 1: Introducción\nTutorial 3: Invariantes\nTeoría de Ribbon Graphs"
  },
  {
    "objectID": "notas/ejemplos.html#el-toro-simple",
    "href": "notas/ejemplos.html#el-toro-simple",
    "title": "Ejemplos Clásicos de Ribbon Graphs",
    "section": "",
    "text": "Permutaciones: - σ = (1,2,3)(4,5,6) - ρ = (1,4)(2,5)(3,6)\nInvariantes: - Género: 1 (toro) - Vértices: 2, Aristas: 3, Caras: 1 - Fronteras: 1\n\n\n\n\n\n\nGrafo Base\n\n\n\n\n\n\n\nRibbon Completo\n\n\n\n\n\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,4)(2,5)(3,6)')\nviz.generar_secuencia_completa(prefix='toro_')"
  },
  {
    "objectID": "notas/ejemplos.html#vértice-con-self-loops",
    "href": "notas/ejemplos.html#vértice-con-self-loops",
    "title": "Ejemplos Clásicos de Ribbon Graphs",
    "section": "",
    "text": "Permutaciones: - σ = (1,2,3,4) - ρ = (1,2)(3,4)\nInvariantes: - Género: 0 (esfera) - Vértices: 1, Aristas: 2, Caras: 1 - Fronteras: 3\n\n\n\n\n\n\nGrafo Base\n\n\n\n\n\n\n\nRibbon Completo\n\n\n\n\n\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1,2,3,4)', '(1,2)(3,4)')\nviz.generar_secuencia_completa(prefix='selfloop_')"
  },
  {
    "objectID": "notas/ejemplos.html#triángulo-k₃",
    "href": "notas/ejemplos.html#triángulo-k₃",
    "title": "Ejemplos Clásicos de Ribbon Graphs",
    "section": "",
    "text": "Permutaciones: - σ = (1,2)(3,4)(5,6) - ρ = (1,3)(2,5)(4,6)\nInvariantes: - Género: 0 (esfera) - Vértices: 3, Aristas: 3, Caras: 2 - Fronteras: 2\n\n\n\n\n\n\nGrafo Base\n\n\n\n\n\n\n\nRibbon Completo\n\n\n\n\n\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1,2)(3,4)(5,6)', '(1,3)(2,5)(4,6)')\nviz.generar_secuencia_completa(prefix='triangulo_')"
  },
  {
    "objectID": "notas/ejemplos.html#theta-graph",
    "href": "notas/ejemplos.html#theta-graph",
    "title": "Ejemplos Clásicos de Ribbon Graphs",
    "section": "",
    "text": "Permutaciones: - σ = (1,2,3)(4,5,6) - ρ = (1,6)(2,4)(3,5)\nInvariantes: - Género: 1 (toro) - Vértices: 2, Aristas: 3, Caras: 1 - Fronteras: 1\n\n\n\n\n\n\nGrafo Base\n\n\n\n\n\n\n\nRibbon Completo\n\n\n\n\n\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1,2,3)(4,5,6)', '(1,6)(2,4)(3,5)')\nviz.generar_secuencia_completa(prefix='theta_')\n\n\nNota: A pesar de tener la misma estructura de σ que el ejemplo 1, el cambio en ρ produce una configuración diferente."
  },
  {
    "objectID": "notas/ejemplos.html#bouquet-de-círculos",
    "href": "notas/ejemplos.html#bouquet-de-círculos",
    "title": "Ejemplos Clásicos de Ribbon Graphs",
    "section": "",
    "text": "Un bouquet con 3 pétalos:\nPermutaciones: - σ = (1,2,3,4,5,6) - ρ = (1,2)(3,4)(5,6)\nInvariantes: - Género: 0 (esfera) - Vértices: 1, Aristas: 3, Caras: 1 - Fronteras: 4\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1,2,3,4,5,6)', '(1,2)(3,4)(5,6)')\nviz.generar_secuencia_completa(prefix='bouquet_')"
  },
  {
    "objectID": "notas/ejemplos.html#cuadrado-k₄-completo",
    "href": "notas/ejemplos.html#cuadrado-k₄-completo",
    "title": "Ejemplos Clásicos de Ribbon Graphs",
    "section": "",
    "text": "Permutaciones: - σ = (1,2)(3,4)(5,6)(7,8) - ρ = (1,3)(2,5)(4,7)(6,8)\nInvariantes: - Género: 0 (esfera) - Vértices: 4, Aristas: 4, Caras: ? - Fronteras: ?\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1,2)(3,4)(5,6)(7,8)', '(1,3)(2,5)(4,7)(6,8)')\nviz.generar_secuencia_completa(prefix='cuadrado_')"
  },
  {
    "objectID": "notas/ejemplos.html#dumbell-dos-vértices-una-arista",
    "href": "notas/ejemplos.html#dumbell-dos-vértices-una-arista",
    "title": "Ejemplos Clásicos de Ribbon Graphs",
    "section": "",
    "text": "La configuración más simple:\nPermutaciones: - σ = (1)(2) - ρ = (1,2)\nInvariantes: - Género: 0 (esfera) - Vértices: 2, Aristas: 1, Caras: 1 - Fronteras: 1\n\n\nCódigo\nviz = RibbonGraphVisualizer('(1)(2)', '(1,2)')\nviz.generar_secuencia_completa(prefix='dumbell_')"
  },
  {
    "objectID": "notas/ejemplos.html#tabla-comparativa",
    "href": "notas/ejemplos.html#tabla-comparativa",
    "title": "Ejemplos Clásicos de Ribbon Graphs",
    "section": "",
    "text": "Ejemplo\nV\nE\nF\ng\nb\nχ\nDescripción\n\n\n\n\nToro\n2\n3\n1\n1\n1\n-1\n2 vértices, 3 aristas\n\n\nSelf-loops\n1\n2\n1\n0\n3\n-1\n1 vértice, 2 loops\n\n\nTriángulo\n3\n3\n2\n0\n2\n0\nGrafo completo K₃\n\n\nTheta\n2\n3\n1\n1\n1\n-1\n3 aristas paralelas\n\n\nBouquet\n1\n3\n1\n0\n4\n-2\n3 pétalos\n\n\nCuadrado\n4\n4\n?\n0\n?\n?\nCiclo de 4 vértices\n\n\nDumbell\n2\n1\n1\n0\n1\n1\nMás simple"
  },
  {
    "objectID": "notas/ejemplos.html#patrones-observados",
    "href": "notas/ejemplos.html#patrones-observados",
    "title": "Ejemplos Clásicos de Ribbon Graphs",
    "section": "",
    "text": "Ribbon graphs con g = 0: - Self-loops - Triángulo K₃ - Bouquet - Dumbell\n\n\n\nRibbon graphs con g = 1: - Toro simple - Theta graph\n\n\n\nPara ribbon graphs en esfera (g=0): - Si V &gt; E: tiende a tener múltiples fronteras - Si V = E: configuración balanceada - Si V &lt; E: no puede existir (violaría χ)"
  },
  {
    "objectID": "notas/ejemplos.html#crear-tus-propios-ejemplos",
    "href": "notas/ejemplos.html#crear-tus-propios-ejemplos",
    "title": "Ejemplos Clásicos de Ribbon Graphs",
    "section": "",
    "text": "Plantilla general:\n\n# Define tus permutaciones\nmi_sigma = '(1,2,3)(...)'\nmi_rho = '(1,?)(2,?)(3,?)...'\n\n# Crear visualizador\nviz = RibbonGraphVisualizer(mi_sigma, mi_rho)\n\n# Ver invariantes\nprint(viz.invariantes())\n\n# Generar visualizaciones\nviz.generar_secuencia_completa(prefix='mi_ejemplo_')"
  },
  {
    "objectID": "notas/ejemplos.html#referencias",
    "href": "notas/ejemplos.html#referencias",
    "title": "Ejemplos Clásicos de Ribbon Graphs",
    "section": "",
    "text": "Tutorial 1: Introducción\nTutorial 3: Invariantes\nTeoría de Ribbon Graphs"
  }
]