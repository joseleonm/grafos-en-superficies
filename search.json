[
  {
    "objectID": "capitulos/02-trazado-de-caras.html",
    "href": "capitulos/02-trazado-de-caras.html",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "Para determinar las caras de un encaje celular dado por un sistema de rotación \\((\\sigma, \\rho)\\), utilizamos el algoritmo de trazado de caras (Face Tracing). Este procedimiento nos permite identificar los ciclos de semiaristas que conforman los bordes de las caras.\n\n\nEn la convención de SageMath para ribbon graphs, las caras están determinadas por las órbitas de la permutación \\(\\varphi\\), definida como:\n\\[ \\varphi = \\rho \\sigma \\]\nEsta es la fórmula utilizada internamente por el método boundary() de la clase RibbonGraph en Sage.\n\n\n\n\n\n\nImportanteConvención de Multiplicación (SageMath)\n\n\n\nEn este curso y en SageMath, la multiplicación de permutaciones se lee de izquierda a derecha. La expresión \\(\\varphi = \\rho \\sigma\\) significa: primero aplicamos \\(\\rho\\) (cruzar la arista) y luego aplicamos \\(\\sigma\\) (girar en el vértice en el orden dado).\n\n\n\n\n\n\n\n\nNotaNota sobre Convenciones Alternativas\n\n\n\nAlgunos textos usan \\(\\varphi = \\rho \\sigma^{-1}\\), \\(\\varphi = \\sigma^{-1} \\rho\\), o \\(\\varphi = (\\sigma\\rho)^{-1}\\). Todas estas convenciones dan el mismo número de caras, pero los ciclos específicos pueden diferir. Usamos \\(\\varphi = \\rho \\sigma\\) para coincidir exactamente con la implementación de SageMath y simplificar los cálculos (no hay que invertir σ).\n\n\n\n\n\nEl cálculo de \\(\\varphi(d)\\) para una semiarista \\(d\\) sigue estos pasos geométricos:\n\nCruzar la arista: Desde \\(d\\), vamos al otro extremo de la arista aplicando \\(\\rho\\).\nGirar en el vértice: En el nuevo vértice, tomamos la siguiente semiarista según el orden de rotación \\(\\sigma\\).\n\nEsto corresponde a recorrer el borde de la cara siguiendo la orientación dada por el ribbon graph.\n\n\n\nConsideremos el grafo con un vértice y dos lazos (aristas que empiezan y terminan en el mismo vértice). Tenemos 4 semiaristas: \\(D = \\{1, 2, 3, 4\\}\\). La permutación de aristas es fija: \\(\\rho = (1, 2)(3, 4)\\).\n\nVamos a calcular las caras para dos elecciones distintas de \\(\\sigma\\), mostrando cómo el orden cíclico afecta la topología.\n\n\nElegimos el orden cíclico natural: \\[ \\sigma = (1, 2, 3, 4) \\]\nCalculamos \\(\\varphi = \\rho \\sigma\\):\n\nPaso a paso (Cruzar \\(\\to\\) Girar):\n\n\\(1 \\xrightarrow{\\rho} 2 \\xrightarrow{\\sigma} 3\\). (Sigue \\(1 \\to 3\\))\n\\(3 \\xrightarrow{\\rho} 4 \\xrightarrow{\\sigma} 1\\). (Cierra el ciclo \\((1, 3)\\))\n\\(2 \\xrightarrow{\\rho} 1 \\xrightarrow{\\sigma} 2\\). (Ciclo cerrado \\((2)\\))\n\\(4 \\xrightarrow{\\rho} 3 \\xrightarrow{\\sigma} 4\\). (Ciclo cerrado \\((4)\\))\n\n\nResultado: \\(\\varphi = (1, 3)(2)(4)\\). Tenemos \\(F=3\\) caras (Roja, Verde, Azul).\n \n\n\n\n\n\n\nTipVerificación con SageMath\n\n\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nphi = rho * sigma  # φ = ρσ\nprint(phi)  # (1,3)\nprint(phi.cycle_tuples(singletons=True))  # [(1, 3), (2,), (4,)]\n\nR = RibbonGraph(sigma, rho)\nprint(R.boundary())  # [[1, 2, 3, 4], [2, 1], [4, 3]]\nprint(R.number_boundaries())  # 3\n\n\n\n\n\nCambiamos el orden cíclico intercalando las semiaristas: \\[ \\sigma = (1, 3, 2, 4) \\]\nCalculamos \\(\\varphi = \\rho \\sigma\\):\n\nPaso a paso (Cruzar \\(\\to\\) Girar):\n\n\\(1 \\xrightarrow{\\rho} 2 \\xrightarrow{\\sigma} 4\\).\n\\(4 \\xrightarrow{\\rho} 3 \\xrightarrow{\\sigma} 2\\).\n\n\\(2 \\xrightarrow{\\rho} 1 \\xrightarrow{\\sigma} 3\\).\n\\(3 \\xrightarrow{\\rho} 4 \\xrightarrow{\\sigma} 1\\).\n\n\nResultado: \\(\\varphi = (1, 4, 2, 3)\\). Tenemos \\(F=1\\) cara (Morada).\n\n\n\n\n\n\n\nTipVerificación con SageMath\n\n\n\nsigma = PermutationGroupElement('(1,3,2,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nphi = rho * sigma  # φ = ρσ\nprint(phi)  # (1,4,2,3)\nprint(phi.cycle_tuples(singletons=True))  # [(1, 4, 2, 3)]\n\nR = RibbonGraph(sigma, rho)\nprint(R.boundary())  # [[1, 2, 4, 3, 2, 1, 3, 4]]\nprint(R.number_boundaries())  # 1\n\n\n\n\n\n\n\n\nNotaSuperficie Cerrada\n\n\n\nEste encaje produce un toro (género 1, con una componente de frontera). ¡Una simple transposición en el orden de las semiaristas alrededor del vértice transformó la superficie de tres componentes disjuntas a un toro!\n\n\n\n\n\n\nEl conjunto de órbitas (ciclos disjuntos) de la permutación \\(\\varphi\\) es exactamente el conjunto de caras del encaje.\n\\[ F = \\text{número de ciclos de } \\varphi \\]\n\n\n\n\n\n\n\n\n\n\nTipEjercicio 1: Cálculo Manual\n\n\n\nToma el sistema de rotación:\n\n\\(\\sigma = (1,2)(3,4)(5,6)\\)\n\\(\\rho = (1,2)(3,4)(5,6)\\)\n\nCalcula manualmente la permutación de caras \\(\\varphi = \\rho\\sigma\\) y determina cuántas caras tiene este encaje.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Exploración Visual\n\n\n\nConsidera el bouquet de 3 círculos: un vértice con 3 self-loops (6 semiaristas). \\(\\rho\\) está fijo como \\((1,2)(3,4)(5,6)\\).\n\nUsa el visualizador para probar diferentes permutaciones \\(\\sigma\\) (por ejemplo, \\((1,2,3,4,5,6)\\) vs \\((1,6,2,5,3,4)\\)).\nObserva cómo cambia la conectividad de las cintas azules.\n¿Puedes encontrar un \\(\\sigma\\) que produzca una superficie con solo 1 cara?\n\n\n\n\n\n\n\n\n\nTipEjercicio 3: Experimento Computacional con SageMath\n\n\n\nEscribe un script en SageMath para verificar la fórmula de las caras:\n\nDefine un conjunto de semiaristas \\(D = \\{1, \\dots, 20\\}\\).\nDefine un \\(\\rho\\) fijo (ej. (1,2)(3,4)...(19,20)).\nGenera un \\(\\sigma\\) aleatorio usando SymmetricGroup(20).random_element().\nCalcula el número de ciclos de \\(\\varphi = \\rho\\sigma\\).\nCompara este resultado con RibbonGraph(sigma, rho).number_boundaries().\n\nReto: Ejecuta este experimento 100 veces en un bucle. ¿Cuál es el número mínimo y máximo de caras que observas?\n\n\n\n\n\n\n\nEl Algoritmo de Trazado de Caras permite identificar las regiones del encaje mediante recorridos en el grafo.\nLa permutación de caras se define como \\(\\varphi = \\rho \\sigma\\) (convención de SageMath).\nLa regla geométrica es “Cruzar y Girar”: aplicar \\(\\rho\\) y luego \\(\\sigma\\).\nEl número de caras \\(F\\) es exactamente el número de ciclos disjuntos de \\(\\varphi\\).\nEl orden cíclico \\(\\sigma\\) determina la topología de la superficie (ej. Esfera vs. Toro).\n\nEn el siguiente capítulo utilizaremos este conteo de caras para calcular los invariantes topológicos (característica de Euler y género) directamente desde las permutaciones."
  },
  {
    "objectID": "capitulos/02-trazado-de-caras.html#la-permutación-de-caras-varphi",
    "href": "capitulos/02-trazado-de-caras.html#la-permutación-de-caras-varphi",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "En la convención de SageMath para ribbon graphs, las caras están determinadas por las órbitas de la permutación \\(\\varphi\\), definida como:\n\\[ \\varphi = \\rho \\sigma \\]\nEsta es la fórmula utilizada internamente por el método boundary() de la clase RibbonGraph en Sage.\n\n\n\n\n\n\nImportanteConvención de Multiplicación (SageMath)\n\n\n\nEn este curso y en SageMath, la multiplicación de permutaciones se lee de izquierda a derecha. La expresión \\(\\varphi = \\rho \\sigma\\) significa: primero aplicamos \\(\\rho\\) (cruzar la arista) y luego aplicamos \\(\\sigma\\) (girar en el vértice en el orden dado).\n\n\n\n\n\n\n\n\nNotaNota sobre Convenciones Alternativas\n\n\n\nAlgunos textos usan \\(\\varphi = \\rho \\sigma^{-1}\\), \\(\\varphi = \\sigma^{-1} \\rho\\), o \\(\\varphi = (\\sigma\\rho)^{-1}\\). Todas estas convenciones dan el mismo número de caras, pero los ciclos específicos pueden diferir. Usamos \\(\\varphi = \\rho \\sigma\\) para coincidir exactamente con la implementación de SageMath y simplificar los cálculos (no hay que invertir σ)."
  },
  {
    "objectID": "capitulos/02-trazado-de-caras.html#la-receta-geométrica-cruzar-y-girar",
    "href": "capitulos/02-trazado-de-caras.html#la-receta-geométrica-cruzar-y-girar",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "El cálculo de \\(\\varphi(d)\\) para una semiarista \\(d\\) sigue estos pasos geométricos:\n\nCruzar la arista: Desde \\(d\\), vamos al otro extremo de la arista aplicando \\(\\rho\\).\nGirar en el vértice: En el nuevo vértice, tomamos la siguiente semiarista según el orden de rotación \\(\\sigma\\).\n\nEsto corresponde a recorrer el borde de la cara siguiendo la orientación dada por el ribbon graph."
  },
  {
    "objectID": "capitulos/02-trazado-de-caras.html#ejemplo-un-vértice-dos-lazos",
    "href": "capitulos/02-trazado-de-caras.html#ejemplo-un-vértice-dos-lazos",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "Consideremos el grafo con un vértice y dos lazos (aristas que empiezan y terminan en el mismo vértice). Tenemos 4 semiaristas: \\(D = \\{1, 2, 3, 4\\}\\). La permutación de aristas es fija: \\(\\rho = (1, 2)(3, 4)\\).\n\nVamos a calcular las caras para dos elecciones distintas de \\(\\sigma\\), mostrando cómo el orden cíclico afecta la topología.\n\n\nElegimos el orden cíclico natural: \\[ \\sigma = (1, 2, 3, 4) \\]\nCalculamos \\(\\varphi = \\rho \\sigma\\):\n\nPaso a paso (Cruzar \\(\\to\\) Girar):\n\n\\(1 \\xrightarrow{\\rho} 2 \\xrightarrow{\\sigma} 3\\). (Sigue \\(1 \\to 3\\))\n\\(3 \\xrightarrow{\\rho} 4 \\xrightarrow{\\sigma} 1\\). (Cierra el ciclo \\((1, 3)\\))\n\\(2 \\xrightarrow{\\rho} 1 \\xrightarrow{\\sigma} 2\\). (Ciclo cerrado \\((2)\\))\n\\(4 \\xrightarrow{\\rho} 3 \\xrightarrow{\\sigma} 4\\). (Ciclo cerrado \\((4)\\))\n\n\nResultado: \\(\\varphi = (1, 3)(2)(4)\\). Tenemos \\(F=3\\) caras (Roja, Verde, Azul).\n \n\n\n\n\n\n\nTipVerificación con SageMath\n\n\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nphi = rho * sigma  # φ = ρσ\nprint(phi)  # (1,3)\nprint(phi.cycle_tuples(singletons=True))  # [(1, 3), (2,), (4,)]\n\nR = RibbonGraph(sigma, rho)\nprint(R.boundary())  # [[1, 2, 3, 4], [2, 1], [4, 3]]\nprint(R.number_boundaries())  # 3\n\n\n\n\n\nCambiamos el orden cíclico intercalando las semiaristas: \\[ \\sigma = (1, 3, 2, 4) \\]\nCalculamos \\(\\varphi = \\rho \\sigma\\):\n\nPaso a paso (Cruzar \\(\\to\\) Girar):\n\n\\(1 \\xrightarrow{\\rho} 2 \\xrightarrow{\\sigma} 4\\).\n\\(4 \\xrightarrow{\\rho} 3 \\xrightarrow{\\sigma} 2\\).\n\n\\(2 \\xrightarrow{\\rho} 1 \\xrightarrow{\\sigma} 3\\).\n\\(3 \\xrightarrow{\\rho} 4 \\xrightarrow{\\sigma} 1\\).\n\n\nResultado: \\(\\varphi = (1, 4, 2, 3)\\). Tenemos \\(F=1\\) cara (Morada).\n\n\n\n\n\n\n\nTipVerificación con SageMath\n\n\n\nsigma = PermutationGroupElement('(1,3,2,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nphi = rho * sigma  # φ = ρσ\nprint(phi)  # (1,4,2,3)\nprint(phi.cycle_tuples(singletons=True))  # [(1, 4, 2, 3)]\n\nR = RibbonGraph(sigma, rho)\nprint(R.boundary())  # [[1, 2, 4, 3, 2, 1, 3, 4]]\nprint(R.number_boundaries())  # 1\n\n\n\n\n\n\n\n\nNotaSuperficie Cerrada\n\n\n\nEste encaje produce un toro (género 1, con una componente de frontera). ¡Una simple transposición en el orden de las semiaristas alrededor del vértice transformó la superficie de tres componentes disjuntas a un toro!"
  },
  {
    "objectID": "capitulos/02-trazado-de-caras.html#propiedad-fundamental",
    "href": "capitulos/02-trazado-de-caras.html#propiedad-fundamental",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "El conjunto de órbitas (ciclos disjuntos) de la permutación \\(\\varphi\\) es exactamente el conjunto de caras del encaje.\n\\[ F = \\text{número de ciclos de } \\varphi \\]"
  },
  {
    "objectID": "capitulos/02-trazado-de-caras.html#ejercicios",
    "href": "capitulos/02-trazado-de-caras.html#ejercicios",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "TipEjercicio 1: Cálculo Manual\n\n\n\nToma el sistema de rotación:\n\n\\(\\sigma = (1,2)(3,4)(5,6)\\)\n\\(\\rho = (1,2)(3,4)(5,6)\\)\n\nCalcula manualmente la permutación de caras \\(\\varphi = \\rho\\sigma\\) y determina cuántas caras tiene este encaje.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Exploración Visual\n\n\n\nConsidera el bouquet de 3 círculos: un vértice con 3 self-loops (6 semiaristas). \\(\\rho\\) está fijo como \\((1,2)(3,4)(5,6)\\).\n\nUsa el visualizador para probar diferentes permutaciones \\(\\sigma\\) (por ejemplo, \\((1,2,3,4,5,6)\\) vs \\((1,6,2,5,3,4)\\)).\nObserva cómo cambia la conectividad de las cintas azules.\n¿Puedes encontrar un \\(\\sigma\\) que produzca una superficie con solo 1 cara?\n\n\n\n\n\n\n\n\n\nTipEjercicio 3: Experimento Computacional con SageMath\n\n\n\nEscribe un script en SageMath para verificar la fórmula de las caras:\n\nDefine un conjunto de semiaristas \\(D = \\{1, \\dots, 20\\}\\).\nDefine un \\(\\rho\\) fijo (ej. (1,2)(3,4)...(19,20)).\nGenera un \\(\\sigma\\) aleatorio usando SymmetricGroup(20).random_element().\nCalcula el número de ciclos de \\(\\varphi = \\rho\\sigma\\).\nCompara este resultado con RibbonGraph(sigma, rho).number_boundaries().\n\nReto: Ejecuta este experimento 100 veces en un bucle. ¿Cuál es el número mínimo y máximo de caras que observas?"
  },
  {
    "objectID": "capitulos/02-trazado-de-caras.html#resumen",
    "href": "capitulos/02-trazado-de-caras.html#resumen",
    "title": "2. Trazado de Caras",
    "section": "",
    "text": "El Algoritmo de Trazado de Caras permite identificar las regiones del encaje mediante recorridos en el grafo.\nLa permutación de caras se define como \\(\\varphi = \\rho \\sigma\\) (convención de SageMath).\nLa regla geométrica es “Cruzar y Girar”: aplicar \\(\\rho\\) y luego \\(\\sigma\\).\nEl número de caras \\(F\\) es exactamente el número de ciclos disjuntos de \\(\\varphi\\).\nEl orden cíclico \\(\\sigma\\) determina la topología de la superficie (ej. Esfera vs. Toro).\n\nEn el siguiente capítulo utilizaremos este conteo de caras para calcular los invariantes topológicos (característica de Euler y género) directamente desde las permutaciones."
  },
  {
    "objectID": "capitulos/04-teoremas.html",
    "href": "capitulos/04-teoremas.html",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "El Teorema de Heffter-Edmonds es la piedra angular de la teoría de grafos topológicos. No solo establece que todo sistema de rotación genera una superficie, sino que la correspondencia es estructuralmente perfecta: clasifica los encajes salvo equivalencia.\n\n\nAntes de enunciar el teorema en su forma fuerte, debemos precisar qué significa que dos sistemas sean “el mismo” desde el punto de vista combinatorio.\nDos sistemas de rotación \\((\\sigma_1, \\rho_1)\\) sobre un conjunto de semiaristas \\(D_1\\) y \\((\\sigma_2, \\rho_2)\\) sobre \\(D_2\\) son equivalentes (o isomorfos) si existe una biyección \\(\\tau: D_1 \\to D_2\\) tal que:\n\\[\n\\sigma_2 = \\tau \\sigma_1 \\tau^{-1} \\quad \\text{y} \\quad \\rho_2 = \\tau \\rho_1 \\tau^{-1}\n\\]\nEsta biyección \\(\\tau\\) preserva toda la estructura combinatoria: mapea vértices a vértices (ciclos de \\(\\sigma\\)) y aristas a aristas (ciclos de \\(\\rho\\)).\n\n\n\nGeométricamente, dos encajes de grafos \\(G_1 \\subset S_1\\) y \\(G_2 \\subset S_2\\) son equivalentes si existe un homeomorfismo que preserva la orientación \\(h: S_1 \\to S_2\\) tal que \\(h(G_1) = G_2\\). Esto implica que \\(h\\) induce un isomorfismo entre los grafos abstractos subyacentes.\n\n\n\n\n\n\n\n\n\nImportanteTeorema Fuerte de Heffter-Edmonds\n\n\n\nExiste una correspondencia biunívoca natural entre:\n\nClases de equivalencia de sistemas de rotación \\((\\sigma, \\rho)\\).\nClases de equivalencia de encajes celulares de grafos en superficies orientables.\n\nEsto significa que el álgebra de las permutaciones \\((\\sigma, \\rho)\\) captura toda la información topológica del encaje, sin pérdida ni ambigüedad.\n\n\n\n\n\nEste resultado transforma problemas topológicos en problemas puramente combinatorios:\n\nHeffter (1891): Primeros trabajos sobre encajes de grafos en superficies\nEdmonds (1960): Formulación moderna en términos de permutaciones\nTambién conocido como el teorema de representación de superficies\n\n\n\n\n\n\n\n\n\n\n\n\nImportanteProposición fundamental\n\n\n\nExiste una correspondencia biunívoca natural entre:\n\nSistemas de rotación \\((\\sigma, \\rho)\\)\nRibbon graphs\nEncajes celulares en superficies orientables\n\nEstas tres formas de describir el mismo objeto matemático son completamente equivalentes.\n\n\n\n\nLa construcción del trazado de caras (capítulo 2) proporciona la transformación explícita:\n\\[\n(\\sigma, \\rho) \\quad \\xrightarrow{\\text{engrosamiento}} \\quad \\text{Ribbon graph}\n\\]\n\n\n\nDado un ribbon graph (superficie con grafo encajado):\n\nIdentificar las semiaristas en el borde de cada vértice\nLeer el orden cíclico \\(\\to\\) permutación \\(\\sigma\\)\nEmparejar semiaristas de cada arista \\(\\to\\) permutación \\(\\rho\\)\n\n\n\n\n\n\nComo hemos visto en los capítulos anteriores, el sistema \\((\\sigma, \\rho)\\) determina completamente el grafo (\\(V, E\\)) y la topología de la superficie (\\(F, g\\)). Sin embargo, hay una propiedad topológica fundamental que está implícita en esta construcción: la orientabilidad.\n\n\nTodo sistema de rotación \\((\\sigma, \\rho)\\) genera necesariamente una superficie orientable. Esto no es una coincidencia, sino una consecuencia de la definición misma.\n\nOrientación Local: La permutación \\(\\sigma\\) define un orden cíclico estricto en cada vértice. Geométricamente, esto equivale a elegir una dirección de “giro” (por ejemplo, antihorario) en el disco que representa cada vértice.\nConsistencia Global: Al conectar estos vértices mediante aristas (las bandas o ribbons), asumimos implícitamente que no hay torsiones. Conectamos el borde del disco \\(u\\) con el borde del disco \\(v\\) sin voltear la cinta.\nDos Lados: Como resultado, la superficie resultante tiene dos lados bien definidos (“arriba” y “abajo”). Es posible pintar un lado de rojo y otro de azul sin que los colores se mezclen, lo cual es la definición intuitiva de orientabilidad.\n\n\n\n\nPara representar superficies no orientables (como la Banda de Möbius o la Botella de Klein), el modelo de permutaciones \\((\\sigma, \\rho)\\) es insuficiente. Se requiere información adicional:\n\nSistemas de rotación con signo: Se añade una función de firma \\(\\lambda: E \\to \\{+1, -1\\}\\).\nSi una arista tiene signo \\(-1\\), la cinta se “tuerce” al conectar los vértices, invirtiendo la orientación local.\n\nDado que nuestros sistemas de rotación no incluyen esta firma (son “puros”), estamos restringidos exclusivamente al universo de las superficies orientables.\n\n\n\n\n\nUn encaje celular de un grafo en una superficie es equivalente a un complejo celular 2-dimensional donde:\n\n0-celdas = vértices del grafo\n1-celdas = aristas del grafo\n2-celdas = caras del encaje\n\nEl sistema de rotación \\((\\sigma, \\rho)\\) codifica completamente la información combinatoria de este complejo celular.\n\n\n\n\n\n\n# ¿Cuál es el género mínimo en el que K₃ se puede encajar?\nR = RibbonGraph('(1,6)(2,3)(4,5)', '(1,2)(3,4)(5,6)')\nprint(f\"Género de este encaje: {R.genus()}\")\n\n# K₃ es planar, por lo que g = 0 es posible\n\n\n\n# Queremos género 1 (toro)\n# Usamos la fórmula: chi = 2 - 2g - b\n# Para g=1, b=0: chi = 0\n# Necesitamos V - E + F = 0\n\n# Ejemplo: V=1, E=2, F=1\nR = RibbonGraph('(1,2,3,4)', '(1,2)(3,4)')\nprint(f\"χ = {R.num_vertices() - R.num_edges() + len(list(R.faces()))}\")\nprint(f\"g = {R.genus()}\")\n\n\n\n\n\n\n\n\n\n\n\nTipEjercicio 1: Teorema de Heffter-Edmonds\n\n\n\nConsidera el sistema \\(\\sigma = (1,2,3)\\), \\(\\rho = (1,2)(3)\\).\n\n¿Es válido este sistema? (¿\\(\\rho\\) tiene solo 2-ciclos?)\nSi no es válido, corrige \\(\\rho\\)\nCalcula los invariantes del sistema corregido\n\n\n\n\n\n\n\n\n\nTipEjercicio 2: Superficies con frontera\n\n\n\nEncuentra sistemas de rotación que produzcan:\n\nUn anillo (cilindro topológico: g=0, b=2)\nUn toro con un agujero (g=1, b=1)\nUn bitoro con dos agujeros (g=2, b=2)\n\n\n\n\n\n\n\n\nTeorema de Heffter-Edmonds: establece la equivalencia entre sistemas de rotación y encajes celulares\nEquivalencia: sistemas de rotación ↔︎ ribbon graphs ↔︎ encajes celulares\nPropiedades: determinación del grafo, cálculo de invariantes, orientabilidad\nClasificación: superficies orientables compactas caracterizadas por \\((g, b)\\)\n\nEn el siguiente capítulo veremos una galería de ejemplos clásicos con análisis completo de sus propiedades."
  },
  {
    "objectID": "capitulos/04-teoremas.html#el-teorema-de-heffter-edmonds",
    "href": "capitulos/04-teoremas.html#el-teorema-de-heffter-edmonds",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "El Teorema de Heffter-Edmonds es la piedra angular de la teoría de grafos topológicos. No solo establece que todo sistema de rotación genera una superficie, sino que la correspondencia es estructuralmente perfecta: clasifica los encajes salvo equivalencia.\n\n\nAntes de enunciar el teorema en su forma fuerte, debemos precisar qué significa que dos sistemas sean “el mismo” desde el punto de vista combinatorio.\nDos sistemas de rotación \\((\\sigma_1, \\rho_1)\\) sobre un conjunto de semiaristas \\(D_1\\) y \\((\\sigma_2, \\rho_2)\\) sobre \\(D_2\\) son equivalentes (o isomorfos) si existe una biyección \\(\\tau: D_1 \\to D_2\\) tal que:\n\\[\n\\sigma_2 = \\tau \\sigma_1 \\tau^{-1} \\quad \\text{y} \\quad \\rho_2 = \\tau \\rho_1 \\tau^{-1}\n\\]\nEsta biyección \\(\\tau\\) preserva toda la estructura combinatoria: mapea vértices a vértices (ciclos de \\(\\sigma\\)) y aristas a aristas (ciclos de \\(\\rho\\)).\n\n\n\nGeométricamente, dos encajes de grafos \\(G_1 \\subset S_1\\) y \\(G_2 \\subset S_2\\) son equivalentes si existe un homeomorfismo que preserva la orientación \\(h: S_1 \\to S_2\\) tal que \\(h(G_1) = G_2\\). Esto implica que \\(h\\) induce un isomorfismo entre los grafos abstractos subyacentes.\n\n\n\n\n\n\n\n\n\nImportanteTeorema Fuerte de Heffter-Edmonds\n\n\n\nExiste una correspondencia biunívoca natural entre:\n\nClases de equivalencia de sistemas de rotación \\((\\sigma, \\rho)\\).\nClases de equivalencia de encajes celulares de grafos en superficies orientables.\n\nEsto significa que el álgebra de las permutaciones \\((\\sigma, \\rho)\\) captura toda la información topológica del encaje, sin pérdida ni ambigüedad.\n\n\n\n\n\nEste resultado transforma problemas topológicos en problemas puramente combinatorios:\n\nHeffter (1891): Primeros trabajos sobre encajes de grafos en superficies\nEdmonds (1960): Formulación moderna en términos de permutaciones\nTambién conocido como el teorema de representación de superficies"
  },
  {
    "objectID": "capitulos/04-teoremas.html#equivalencia-con-ribbon-graphs",
    "href": "capitulos/04-teoremas.html#equivalencia-con-ribbon-graphs",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "ImportanteProposición fundamental\n\n\n\nExiste una correspondencia biunívoca natural entre:\n\nSistemas de rotación \\((\\sigma, \\rho)\\)\nRibbon graphs\nEncajes celulares en superficies orientables\n\nEstas tres formas de describir el mismo objeto matemático son completamente equivalentes.\n\n\n\n\nLa construcción del trazado de caras (capítulo 2) proporciona la transformación explícita:\n\\[\n(\\sigma, \\rho) \\quad \\xrightarrow{\\text{engrosamiento}} \\quad \\text{Ribbon graph}\n\\]\n\n\n\nDado un ribbon graph (superficie con grafo encajado):\n\nIdentificar las semiaristas en el borde de cada vértice\nLeer el orden cíclico \\(\\to\\) permutación \\(\\sigma\\)\nEmparejar semiaristas de cada arista \\(\\to\\) permutación \\(\\rho\\)"
  },
  {
    "objectID": "capitulos/04-teoremas.html#propiedades-la-cuestión-de-la-orientabilidad",
    "href": "capitulos/04-teoremas.html#propiedades-la-cuestión-de-la-orientabilidad",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "Como hemos visto en los capítulos anteriores, el sistema \\((\\sigma, \\rho)\\) determina completamente el grafo (\\(V, E\\)) y la topología de la superficie (\\(F, g\\)). Sin embargo, hay una propiedad topológica fundamental que está implícita en esta construcción: la orientabilidad.\n\n\nTodo sistema de rotación \\((\\sigma, \\rho)\\) genera necesariamente una superficie orientable. Esto no es una coincidencia, sino una consecuencia de la definición misma.\n\nOrientación Local: La permutación \\(\\sigma\\) define un orden cíclico estricto en cada vértice. Geométricamente, esto equivale a elegir una dirección de “giro” (por ejemplo, antihorario) en el disco que representa cada vértice.\nConsistencia Global: Al conectar estos vértices mediante aristas (las bandas o ribbons), asumimos implícitamente que no hay torsiones. Conectamos el borde del disco \\(u\\) con el borde del disco \\(v\\) sin voltear la cinta.\nDos Lados: Como resultado, la superficie resultante tiene dos lados bien definidos (“arriba” y “abajo”). Es posible pintar un lado de rojo y otro de azul sin que los colores se mezclen, lo cual es la definición intuitiva de orientabilidad.\n\n\n\n\nPara representar superficies no orientables (como la Banda de Möbius o la Botella de Klein), el modelo de permutaciones \\((\\sigma, \\rho)\\) es insuficiente. Se requiere información adicional:\n\nSistemas de rotación con signo: Se añade una función de firma \\(\\lambda: E \\to \\{+1, -1\\}\\).\nSi una arista tiene signo \\(-1\\), la cinta se “tuerce” al conectar los vértices, invirtiendo la orientación local.\n\nDado que nuestros sistemas de rotación no incluyen esta firma (son “puros”), estamos restringidos exclusivamente al universo de las superficies orientables."
  },
  {
    "objectID": "capitulos/04-teoremas.html#relación-con-complejos-celulares",
    "href": "capitulos/04-teoremas.html#relación-con-complejos-celulares",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "Un encaje celular de un grafo en una superficie es equivalente a un complejo celular 2-dimensional donde:\n\n0-celdas = vértices del grafo\n1-celdas = aristas del grafo\n2-celdas = caras del encaje\n\nEl sistema de rotación \\((\\sigma, \\rho)\\) codifica completamente la información combinatoria de este complejo celular."
  },
  {
    "objectID": "capitulos/04-teoremas.html#ejemplos-de-aplicación",
    "href": "capitulos/04-teoremas.html#ejemplos-de-aplicación",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "# ¿Cuál es el género mínimo en el que K₃ se puede encajar?\nR = RibbonGraph('(1,6)(2,3)(4,5)', '(1,2)(3,4)(5,6)')\nprint(f\"Género de este encaje: {R.genus()}\")\n\n# K₃ es planar, por lo que g = 0 es posible\n\n\n\n# Queremos género 1 (toro)\n# Usamos la fórmula: chi = 2 - 2g - b\n# Para g=1, b=0: chi = 0\n# Necesitamos V - E + F = 0\n\n# Ejemplo: V=1, E=2, F=1\nR = RibbonGraph('(1,2,3,4)', '(1,2)(3,4)')\nprint(f\"χ = {R.num_vertices() - R.num_edges() + len(list(R.faces()))}\")\nprint(f\"g = {R.genus()}\")"
  },
  {
    "objectID": "capitulos/04-teoremas.html#ejercicios",
    "href": "capitulos/04-teoremas.html#ejercicios",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "TipEjercicio 1: Teorema de Heffter-Edmonds\n\n\n\nConsidera el sistema \\(\\sigma = (1,2,3)\\), \\(\\rho = (1,2)(3)\\).\n\n¿Es válido este sistema? (¿\\(\\rho\\) tiene solo 2-ciclos?)\nSi no es válido, corrige \\(\\rho\\)\nCalcula los invariantes del sistema corregido\n\n\n\n\n\n\n\n\n\nTipEjercicio 2: Superficies con frontera\n\n\n\nEncuentra sistemas de rotación que produzcan:\n\nUn anillo (cilindro topológico: g=0, b=2)\nUn toro con un agujero (g=1, b=1)\nUn bitoro con dos agujeros (g=2, b=2)"
  },
  {
    "objectID": "capitulos/04-teoremas.html#resumen",
    "href": "capitulos/04-teoremas.html#resumen",
    "title": "4. Teorema de Heffter-Edmonds",
    "section": "",
    "text": "Teorema de Heffter-Edmonds: establece la equivalencia entre sistemas de rotación y encajes celulares\nEquivalencia: sistemas de rotación ↔︎ ribbon graphs ↔︎ encajes celulares\nPropiedades: determinación del grafo, cálculo de invariantes, orientabilidad\nClasificación: superficies orientables compactas caracterizadas por \\((g, b)\\)\n\nEn el siguiente capítulo veremos una galería de ejemplos clásicos con análisis completo de sus propiedades."
  },
  {
    "objectID": "capitulos/05-ejemplos.html",
    "href": "capitulos/05-ejemplos.html",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "En este capítulo exploramos operaciones avanzadas sobre ribbon graphs, invariantes topológicos adicionales, y culminamos con el estudio del polinomio de Bollobás-Riordan, una generalización del polinomio de Tutte para grafos encajados en superficies.\n\n\n\nLa clase RibbonGraph en SageMath proporciona herramientas poderosas para analizar sistemas de rotación:\n\n\nfrom sage.all import RibbonGraph, PermutationGroupElement\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Acceso a las permutaciones\nprint(R.sigma())          # (1,2,3,4)\nprint(R.rho())            # (1,2)(3,4)\n\n# Invariantes topológicos\nprint(R.genus())          # 0\nprint(R.number_boundaries())  # 3\nprint(R.boundary())       # Lista de fronteras\n\n# Base de homología\nprint(R.homology_basis()) # Ciclos fundamentales\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\nsigma()\nDevuelve la permutación de vértices\n\n\nrho()\nDevuelve la permutación de aristas\n\n\ngenus()\nCalcula el género de la superficie\n\n\nnumber_boundaries()\nCuenta componentes de frontera\n\n\nboundary()\nDevuelve las secuencias de darts en cada frontera\n\n\nhomology_basis()\nBase para H₁(superficie)\n\n\ncontract_edge(d)\nContrae la arista que contiene el dart d\n\n\nreduced()\nElimina vértices de valencia 1\n\n\n\n\n\n\n\n\n\n\nLa contracción de una arista consiste en colapsar la arista a un punto, fusionando sus vértices extremos.\n\n\n\n\n\n\nNotaDefinición: Contracción\n\n\n\nDada una arista \\(e = \\{d, \\rho(d)\\}\\) en un ribbon graph, la contracción \\(G/e\\) resulta en: - Eliminar la arista \\(e\\) - Fusionar los vértices en los extremos de \\(e\\) - Preservar el orden cíclico de las aristas restantes\n\n\nEjemplo en Sage:\n# Triángulo K₃ encajado\nsigma = PermutationGroupElement('(1,6)(2,3)(4,5)')\nrho = PermutationGroupElement('(1,2)(3,4)(5,6)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Original: V={len(R.sigma().cycle_tuples(singletons=True))}, \"\n      f\"E={len(R.rho().cycle_tuples())}, \"\n      f\"g={R.genus()}\")\n\n# Contraer la arista que contiene el dart 1\nR_contraido = R.contract_edge(1)\nprint(f\"Contraído: V={len(R_contraido.sigma().cycle_tuples(singletons=True))}, \"\n      f\"E={len(R_contraido.rho().cycle_tuples())}, \"\n      f\"g={R_contraido.genus()}\")\nPropiedades: - La contracción puede cambiar el género - \\(\\chi(G/e) = \\chi(G) + 1\\) si \\(e\\) no es un loop - Útil para definir invariantes recursivos (como el polinomio de Tutte)\n\n\n\nEl método reduced() elimina sistemáticamente vértices de valencia 1:\n# Grafo con un vértice colgante\nsigma = PermutationGroupElement('(1,2,3)(4,5,6)(7,8,9)(10,11,12)(13,14,15)(16,17,18,19)')\nrho = PermutationGroupElement('(1,16)(2,13)(3,10)(4,17)(5,14)(6,11)(7,18)(8,15)(9,12)(19,20)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Original: {len(R.sigma().cycle_tuples(singletons=True))} vértices\")\nprint(f\"          {len(R.rho().cycle_tuples())} aristas\")\n\nR_reducido = R.reduced()\nprint(f\"Reducido: {len(R_reducido.sigma().cycle_tuples(singletons=True))} vértices\")\nprint(f\"          {len(R_reducido.rho().cycle_tuples())} aristas\")\n\n\n\n\n\n\nTipUso de reduced()\n\n\n\nLa reducción es útil para: - Simplificar ribbon graphs antes de calcular invariantes - Remover “hojas” que no contribuyen a la topología - Encontrar el “núcleo” topológico del grafo\n\n\n\n\n\nLa dual de un ribbon graph intercambia roles entre vértices y caras.\n\n\n\n\n\n\nImportanteConstrucción de la Dual\n\n\n\nDado un ribbon graph con sistema de rotación \\((\\sigma, \\rho)\\): - La dual tiene sistema \\((\\varphi, \\rho)\\) donde \\(\\varphi = \\rho\\sigma\\) es la permutación de caras - Los vértices de la dual corresponden a las caras del original - Las aristas se preservan (misma \\(\\rho\\)) - Las caras de la dual corresponden a los vértices del original\n\n\nImplementación manual de la dual:\ndef construir_dual(R):\n    \"\"\"\n    Construye la dual de un ribbon graph.\n\n    Args:\n        R: RibbonGraph original\n\n    Returns:\n        RibbonGraph dual\n    \"\"\"\n    # Obtener permutaciones originales\n    sigma = R.sigma()\n    rho = R.rho()\n\n    # Calcular phi = rho * sigma (caras)\n    phi = rho * sigma\n\n    # La dual tiene sigma_dual = phi, rho_dual = rho\n    R_dual = RibbonGraph(phi, rho)\n\n    return R_dual\n\n# Ejemplo: esfera con 3 fronteras\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\nR_dual = construir_dual(R)\n\nprint(\"Original:\")\nprint(f\"  V = {len(R.sigma().cycle_tuples(singletons=True))}\")\nprint(f\"  E = {len(R.rho().cycle_tuples())}\")\nprint(f\"  F = {len((R.rho() * R.sigma()).cycle_tuples(singletons=True))}\")\nprint(f\"  g = {R.genus()}\")\n\nprint(\"\\nDual:\")\nprint(f\"  V = {len(R_dual.sigma().cycle_tuples(singletons=True))}\")\nprint(f\"  E = {len(R_dual.rho().cycle_tuples())}\")\nprint(f\"  F = {len((R_dual.rho() * R_dual.sigma()).cycle_tuples(singletons=True))}\")\nprint(f\"  g = {R_dual.genus()}\")\nPropiedad fundamental: \\[ V^* = F, \\quad E^* = E, \\quad F^* = V, \\quad g^* = g \\]\ndonde \\(*\\) denota la dual.\n\n\n\n\n\nEl método homology_basis() calcula una base para el primer grupo de homología \\(H_1(S, \\mathbb{Z})\\) de la superficie:\nsigma = PermutationGroupElement('(1,3,5)(2,4,6)')\nrho = PermutationGroupElement('(1,2)(3,4)(5,6)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Género: {R.genus()}\")\nbase = R.homology_basis()\nprint(f\"Número de ciclos en la base: {len(base)}\")\nprint(f\"Base de homología:\")\nfor i, ciclo in enumerate(base, 1):\n    print(f\"  Ciclo {i}: {ciclo}\")\n\n\n\n\n\n\nNotaInterpretación\n\n\n\nPara una superficie de género \\(g\\) con \\(b\\) componentes de frontera: \\[ \\text{rank}(H_1(S)) = 2g + b - 1 \\]\nCada ciclo en la base representa un “agujero” fundamental en la superficie.\n\n\n\n\n\n\nEl polinomio de Bollobás-Riordan es una generalización del polinomio de Tutte para grafos encajados en superficies orientables. Codifica información topológica y combinatoria del encaje.\n\n\n\n\n\n\n\n\nImportantePolinomio de Bollobás-Riordan\n\n\n\nPara un ribbon graph \\(G\\) con sistema de rotación \\((\\sigma, \\rho)\\), el polinomio de Bollobás-Riordan \\(R_G(x, y, z)\\) satisface:\n\nCaso base: Si \\(G\\) es un ciclo simple (una frontera): \\[ R_G(x, y, z) = y + z \\]\nCaso base: Si \\(G\\) consiste solo de loops disjuntos: \\[ R_G(x, y, z) = x^k (y+z) \\] donde \\(k\\) es el número de loops.\nRelación de contracción-borrado: Para una arista \\(e\\) que no es loop ni istmo: \\[ R_G(x,y,z) = R_{G/e}(x,y,z) + R_{G \\setminus e}(x,y,z) \\]\nPara un loop: Si \\(e\\) es un loop: \\[ R_G(x,y,z) = x \\cdot R_{G \\setminus e}(x,y,z) \\]\nPara un istmo: Si \\(e\\) es un istmo (corta una componente de frontera): \\[ R_G(x,y,z) = z \\cdot R_{G / e}(x,y,z) \\]\n\n\n\n\n\n\n\nGeneraliza el polinomio de Tutte:\n\nPara grafos planos: \\(R_G(x, 1, 1) = T_G(x, 1)\\)\nPara grafos en superficies cerradas: codifica información adicional sobre el género\n\nInvariante topológico:\n\nDepende del encaje, no solo del grafo abstracto\nCaptura información sobre el género y componentes de frontera\n\nEvaluaciones especiales:\n\n\\(R_G(1, 1, 1)\\) cuenta spanning subgraphs\nRelación con polinomios cromáticos generalizados\n\n\n\n\n\nSage no tiene implementación nativa del polinomio de Bollobás-Riordan para RibbonGraph, pero podemos implementarlo nosotros mismos:\nfrom sage.all import PolynomialRing, QQ\n\ndef es_loop(R, dart):\n    \"\"\"\n    Verifica si un dart pertenece a un loop (self-loop).\n    Un loop conecta un vértice consigo mismo.\n    \"\"\"\n    rho = R.rho()\n    pareja = rho(dart)\n\n    # Verificar si ambos darts están en el mismo ciclo de sigma\n    sigma = R.sigma()\n    for ciclo in sigma.cycle_tuples():\n        if dart in ciclo and pareja in ciclo:\n            return True\n    return False\n\ndef es_istmo(R, dart):\n    \"\"\"\n    Verifica si un dart pertenece a un istmo (bridge).\n    Un istmo, cuando se elimina, incrementa el número de componentes de frontera.\n    \"\"\"\n    # Método aproximado: un istmo no puede ser un loop\n    # y al eliminarlo debe aumentar las componentes de frontera\n    if es_loop(R, dart):\n        return False\n\n    # Crear una versión sin esta arista requeriría\n    # manipular las permutaciones manualmente\n    # Por simplicidad, asumimos que no es istmo si no es loop\n    # (una implementación completa requeriría más lógica)\n    return False\n\ndef bollobas_riordan(R, x, y, z, memo=None):\n    \"\"\"\n    Calcula el polinomio de Bollobás-Riordan de un ribbon graph.\n\n    Args:\n        R: RibbonGraph\n        x, y, z: variables del polinomio\n        memo: diccionario para memoización\n\n    Returns:\n        Polinomio en Q[x,y,z]\n    \"\"\"\n    if memo is None:\n        memo = {}\n\n    # Convertir ribbon graph a una clave hasheable\n    sigma_str = str(R.sigma())\n    rho_str = str(R.rho())\n    clave = (sigma_str, rho_str)\n\n    if clave in memo:\n        return memo[clave]\n\n    # Casos base\n    num_edges = len(R.rho().cycle_tuples())\n    num_boundaries = R.number_boundaries()\n\n    # Caso 1: Sin aristas (solo vértices aislados)\n    if num_edges == 0:\n        # Solo componentes de frontera triviales\n        resultado = (y + z)\n        memo[clave] = resultado\n        return resultado\n\n    # Caso 2: Un ciclo simple (una frontera, una arista)\n    if num_edges == 1 and num_boundaries == 1:\n        resultado = y + z\n        memo[clave] = resultado\n        return resultado\n\n    # Caso recursivo: elegir una arista\n    # Tomamos el primer dart disponible\n    darts = []\n    for ciclo in R.rho().cycle_tuples():\n        darts.extend(ciclo)\n\n    if not darts:\n        resultado = y + z\n        memo[clave] = resultado\n        return resultado\n\n    dart = darts[0]\n\n    # Verificar si es loop\n    if es_loop(R, dart):\n        # R_G = x * R_{G\\e}\n        # Para implementar G\\e necesitamos remover el ciclo de rho\n        # Esto es complejo, por ahora retornamos una aproximación\n        resultado = x * (y + z)  # Simplificación\n        memo[clave] = resultado\n        return resultado\n\n    # Caso general: contracción-borrado\n    # R_G = R_{G/e} + R_{G\\e}\n    try:\n        R_contraido = R.contract_edge(dart)\n        term_contraer = bollobas_riordan(R_contraido, x, y, z, memo)\n    except:\n        term_contraer = 0\n\n    # Para borrar necesitaríamos remover el dart de rho\n    # Implementación simplificada\n    term_borrar = y + z\n\n    resultado = term_contraer + term_borrar\n    memo[clave] = resultado\n    return resultado\n\n# Crear ring de polinomios\nR_poly.&lt;x, y, z&gt; = PolynomialRing(QQ)\n\n# Ejemplo: calcular para un ribbon graph simple\nsigma = PermutationGroupElement('(1,2)')\nrho = PermutationGroupElement('(1,2)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Ribbon graph: sigma={R.sigma()}, rho={R.rho()}\")\nprint(f\"Género: {R.genus()}\")\nprint(f\"Fronteras: {R.number_boundaries()}\")\nprint()\n\n# Calcular polinomio (versión simplificada)\npoly = bollobas_riordan(R, x, y, z)\nprint(f\"Polinomio de Bollobás-Riordan (aproximado): {poly}\")\n\n\n\n\n\n\nAdvertenciaNota sobre la Implementación\n\n\n\nLa implementación completa del polinomio de Bollobás-Riordan requiere: 1. Manipulación cuidadosa de las permutaciones para borrar aristas 2. Detección robusta de loops e istmos 3. Memoización eficiente para evitar recálculos 4. Manejo de casos especiales (múltiples componentes, etc.)\nLa versión presentada es una implementación pedagógica simplificada que ilustra la estructura recursiva del polinomio.\n\n\n\n\n\nUna implementación más robusta utilizaría representaciones alternativas:\ndef ribbon_to_graph_data(R):\n    \"\"\"\n    Extrae información combinatoria de un ribbon graph.\n\n    Returns:\n        dict con vértices, aristas, género, etc.\n    \"\"\"\n    sigma_cycles = R.sigma().cycle_tuples(singletons=True)\n    rho_cycles = R.rho().cycle_tuples()\n    phi = R.rho() * R.sigma()\n    phi_cycles = phi.cycle_tuples(singletons=True)\n\n    return {\n        'vertices': len(sigma_cycles),\n        'edges': len(rho_cycles),\n        'faces': len(phi_cycles),\n        'genus': R.genus(),\n        'boundaries': R.number_boundaries(),\n        'euler_char': len(sigma_cycles) - len(rho_cycles) + len(phi_cycles)\n    }\n\n# Ejemplo de uso\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\ninfo = ribbon_to_graph_data(R)\nprint(\"Información del ribbon graph:\")\nfor clave, valor in info.items():\n    print(f\"  {clave}: {valor}\")\n\n\n\n\n\n\n\n\n\n\n\nTipEjercicio 1: Dualidad\n\n\n\nImplementa una función que calcule la dual de un ribbon graph y verifica que: 1. \\((G^*)^* = G\\) 2. \\(V^* = F\\) y \\(F^* = V\\) 3. \\(g^* = g\\)\nPrueba con varios ejemplos: K₃ en la esfera, toro con un vértice, etc.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Contracción Iterada\n\n\n\nToma un grafo completo K₄ encajado en una superficie y: 1. Contrae aristas una por una 2. Registra el género después de cada contracción 3. Analiza cómo evoluciona el género\n¿Cuándo la contracción preserva el género? ¿Cuándo lo cambia?\n\n\n\n\n\n\n\n\nTipEjercicio 3: Polinomio de Bollobás-Riordan\n\n\n\nMejora la implementación del polinomio de Bollobás-Riordan para: 1. Manejar correctamente la operación de borrado de aristas 2. Detectar loops e istmos de forma robusta 3. Implementar memoización eficiente\nCalcula el polinomio para grafos pequeños (K₃, K₄, bouquet de círculos).\n\n\n\n\n\n\n\n\nTipEjercicio 4: Base de Homología\n\n\n\nPara un toro con múltiples vértices: 1. Calcula la base de homología usando homology_basis() 2. Visualiza los ciclos fundamentales 3. Verifica que rank(H₁) = 2g + b - 1\nExperimenta con diferentes encajes del mismo grafo y compara las bases.\n\n\n\n\n\n\n\nOperaciones: Contracción, reducción y dualidad son transformaciones fundamentales\nHerramientas de Sage: RibbonGraph proporciona métodos poderosos para análisis topológico\nHomología: La base de homología captura los “agujeros” de la superficie\nPolinomio de Bollobás-Riordan: Generaliza el polinomio de Tutte a superficies\nImplementación: Requiere manipulación cuidadosa de permutaciones y recursión\n\nEl polinomio de Bollobás-Riordan es un área activa de investigación con conexiones a: - Teoría de nudos (polinomios de nudos) - Física matemática (modelos de Potts) - Combinatoria enumerativa\n\n\n\n\n\nBollobás, B., & Riordan, O. (2002). “A polynomial of graphs on surfaces”. Mathematische Annalen.\nChmutov, S. (2009). “Generalized duality for graphs on surfaces and the signed Bollobás–Riordan polynomial”.\nEllis-Monaghan, J. A., & Moffatt, I. (2013). “Graphs on Surfaces: Dualities, Polynomials, and Knots”.\nSageMath - Ribbon Graphs Documentation"
  },
  {
    "objectID": "capitulos/05-ejemplos.html#herramientas-de-la-clase-ribbongraph-en-sage",
    "href": "capitulos/05-ejemplos.html#herramientas-de-la-clase-ribbongraph-en-sage",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "La clase RibbonGraph en SageMath proporciona herramientas poderosas para analizar sistemas de rotación:\n\n\nfrom sage.all import RibbonGraph, PermutationGroupElement\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Acceso a las permutaciones\nprint(R.sigma())          # (1,2,3,4)\nprint(R.rho())            # (1,2)(3,4)\n\n# Invariantes topológicos\nprint(R.genus())          # 0\nprint(R.number_boundaries())  # 3\nprint(R.boundary())       # Lista de fronteras\n\n# Base de homología\nprint(R.homology_basis()) # Ciclos fundamentales\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\nsigma()\nDevuelve la permutación de vértices\n\n\nrho()\nDevuelve la permutación de aristas\n\n\ngenus()\nCalcula el género de la superficie\n\n\nnumber_boundaries()\nCuenta componentes de frontera\n\n\nboundary()\nDevuelve las secuencias de darts en cada frontera\n\n\nhomology_basis()\nBase para H₁(superficie)\n\n\ncontract_edge(d)\nContrae la arista que contiene el dart d\n\n\nreduced()\nElimina vértices de valencia 1"
  },
  {
    "objectID": "capitulos/05-ejemplos.html#operaciones-sobre-ribbon-graphs",
    "href": "capitulos/05-ejemplos.html#operaciones-sobre-ribbon-graphs",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "La contracción de una arista consiste en colapsar la arista a un punto, fusionando sus vértices extremos.\n\n\n\n\n\n\nNotaDefinición: Contracción\n\n\n\nDada una arista \\(e = \\{d, \\rho(d)\\}\\) en un ribbon graph, la contracción \\(G/e\\) resulta en: - Eliminar la arista \\(e\\) - Fusionar los vértices en los extremos de \\(e\\) - Preservar el orden cíclico de las aristas restantes\n\n\nEjemplo en Sage:\n# Triángulo K₃ encajado\nsigma = PermutationGroupElement('(1,6)(2,3)(4,5)')\nrho = PermutationGroupElement('(1,2)(3,4)(5,6)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Original: V={len(R.sigma().cycle_tuples(singletons=True))}, \"\n      f\"E={len(R.rho().cycle_tuples())}, \"\n      f\"g={R.genus()}\")\n\n# Contraer la arista que contiene el dart 1\nR_contraido = R.contract_edge(1)\nprint(f\"Contraído: V={len(R_contraido.sigma().cycle_tuples(singletons=True))}, \"\n      f\"E={len(R_contraido.rho().cycle_tuples())}, \"\n      f\"g={R_contraido.genus()}\")\nPropiedades: - La contracción puede cambiar el género - \\(\\chi(G/e) = \\chi(G) + 1\\) si \\(e\\) no es un loop - Útil para definir invariantes recursivos (como el polinomio de Tutte)\n\n\n\nEl método reduced() elimina sistemáticamente vértices de valencia 1:\n# Grafo con un vértice colgante\nsigma = PermutationGroupElement('(1,2,3)(4,5,6)(7,8,9)(10,11,12)(13,14,15)(16,17,18,19)')\nrho = PermutationGroupElement('(1,16)(2,13)(3,10)(4,17)(5,14)(6,11)(7,18)(8,15)(9,12)(19,20)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Original: {len(R.sigma().cycle_tuples(singletons=True))} vértices\")\nprint(f\"          {len(R.rho().cycle_tuples())} aristas\")\n\nR_reducido = R.reduced()\nprint(f\"Reducido: {len(R_reducido.sigma().cycle_tuples(singletons=True))} vértices\")\nprint(f\"          {len(R_reducido.rho().cycle_tuples())} aristas\")\n\n\n\n\n\n\nTipUso de reduced()\n\n\n\nLa reducción es útil para: - Simplificar ribbon graphs antes de calcular invariantes - Remover “hojas” que no contribuyen a la topología - Encontrar el “núcleo” topológico del grafo\n\n\n\n\n\nLa dual de un ribbon graph intercambia roles entre vértices y caras.\n\n\n\n\n\n\nImportanteConstrucción de la Dual\n\n\n\nDado un ribbon graph con sistema de rotación \\((\\sigma, \\rho)\\): - La dual tiene sistema \\((\\varphi, \\rho)\\) donde \\(\\varphi = \\rho\\sigma\\) es la permutación de caras - Los vértices de la dual corresponden a las caras del original - Las aristas se preservan (misma \\(\\rho\\)) - Las caras de la dual corresponden a los vértices del original\n\n\nImplementación manual de la dual:\ndef construir_dual(R):\n    \"\"\"\n    Construye la dual de un ribbon graph.\n\n    Args:\n        R: RibbonGraph original\n\n    Returns:\n        RibbonGraph dual\n    \"\"\"\n    # Obtener permutaciones originales\n    sigma = R.sigma()\n    rho = R.rho()\n\n    # Calcular phi = rho * sigma (caras)\n    phi = rho * sigma\n\n    # La dual tiene sigma_dual = phi, rho_dual = rho\n    R_dual = RibbonGraph(phi, rho)\n\n    return R_dual\n\n# Ejemplo: esfera con 3 fronteras\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\nR_dual = construir_dual(R)\n\nprint(\"Original:\")\nprint(f\"  V = {len(R.sigma().cycle_tuples(singletons=True))}\")\nprint(f\"  E = {len(R.rho().cycle_tuples())}\")\nprint(f\"  F = {len((R.rho() * R.sigma()).cycle_tuples(singletons=True))}\")\nprint(f\"  g = {R.genus()}\")\n\nprint(\"\\nDual:\")\nprint(f\"  V = {len(R_dual.sigma().cycle_tuples(singletons=True))}\")\nprint(f\"  E = {len(R_dual.rho().cycle_tuples())}\")\nprint(f\"  F = {len((R_dual.rho() * R_dual.sigma()).cycle_tuples(singletons=True))}\")\nprint(f\"  g = {R_dual.genus()}\")\nPropiedad fundamental: \\[ V^* = F, \\quad E^* = E, \\quad F^* = V, \\quad g^* = g \\]\ndonde \\(*\\) denota la dual."
  },
  {
    "objectID": "capitulos/05-ejemplos.html#base-de-homología",
    "href": "capitulos/05-ejemplos.html#base-de-homología",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "El método homology_basis() calcula una base para el primer grupo de homología \\(H_1(S, \\mathbb{Z})\\) de la superficie:\nsigma = PermutationGroupElement('(1,3,5)(2,4,6)')\nrho = PermutationGroupElement('(1,2)(3,4)(5,6)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Género: {R.genus()}\")\nbase = R.homology_basis()\nprint(f\"Número de ciclos en la base: {len(base)}\")\nprint(f\"Base de homología:\")\nfor i, ciclo in enumerate(base, 1):\n    print(f\"  Ciclo {i}: {ciclo}\")\n\n\n\n\n\n\nNotaInterpretación\n\n\n\nPara una superficie de género \\(g\\) con \\(b\\) componentes de frontera: \\[ \\text{rank}(H_1(S)) = 2g + b - 1 \\]\nCada ciclo en la base representa un “agujero” fundamental en la superficie."
  },
  {
    "objectID": "capitulos/05-ejemplos.html#el-polinomio-de-bollobás-riordan",
    "href": "capitulos/05-ejemplos.html#el-polinomio-de-bollobás-riordan",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "El polinomio de Bollobás-Riordan es una generalización del polinomio de Tutte para grafos encajados en superficies orientables. Codifica información topológica y combinatoria del encaje.\n\n\n\n\n\n\n\n\nImportantePolinomio de Bollobás-Riordan\n\n\n\nPara un ribbon graph \\(G\\) con sistema de rotación \\((\\sigma, \\rho)\\), el polinomio de Bollobás-Riordan \\(R_G(x, y, z)\\) satisface:\n\nCaso base: Si \\(G\\) es un ciclo simple (una frontera): \\[ R_G(x, y, z) = y + z \\]\nCaso base: Si \\(G\\) consiste solo de loops disjuntos: \\[ R_G(x, y, z) = x^k (y+z) \\] donde \\(k\\) es el número de loops.\nRelación de contracción-borrado: Para una arista \\(e\\) que no es loop ni istmo: \\[ R_G(x,y,z) = R_{G/e}(x,y,z) + R_{G \\setminus e}(x,y,z) \\]\nPara un loop: Si \\(e\\) es un loop: \\[ R_G(x,y,z) = x \\cdot R_{G \\setminus e}(x,y,z) \\]\nPara un istmo: Si \\(e\\) es un istmo (corta una componente de frontera): \\[ R_G(x,y,z) = z \\cdot R_{G / e}(x,y,z) \\]\n\n\n\n\n\n\n\nGeneraliza el polinomio de Tutte:\n\nPara grafos planos: \\(R_G(x, 1, 1) = T_G(x, 1)\\)\nPara grafos en superficies cerradas: codifica información adicional sobre el género\n\nInvariante topológico:\n\nDepende del encaje, no solo del grafo abstracto\nCaptura información sobre el género y componentes de frontera\n\nEvaluaciones especiales:\n\n\\(R_G(1, 1, 1)\\) cuenta spanning subgraphs\nRelación con polinomios cromáticos generalizados\n\n\n\n\n\nSage no tiene implementación nativa del polinomio de Bollobás-Riordan para RibbonGraph, pero podemos implementarlo nosotros mismos:\nfrom sage.all import PolynomialRing, QQ\n\ndef es_loop(R, dart):\n    \"\"\"\n    Verifica si un dart pertenece a un loop (self-loop).\n    Un loop conecta un vértice consigo mismo.\n    \"\"\"\n    rho = R.rho()\n    pareja = rho(dart)\n\n    # Verificar si ambos darts están en el mismo ciclo de sigma\n    sigma = R.sigma()\n    for ciclo in sigma.cycle_tuples():\n        if dart in ciclo and pareja in ciclo:\n            return True\n    return False\n\ndef es_istmo(R, dart):\n    \"\"\"\n    Verifica si un dart pertenece a un istmo (bridge).\n    Un istmo, cuando se elimina, incrementa el número de componentes de frontera.\n    \"\"\"\n    # Método aproximado: un istmo no puede ser un loop\n    # y al eliminarlo debe aumentar las componentes de frontera\n    if es_loop(R, dart):\n        return False\n\n    # Crear una versión sin esta arista requeriría\n    # manipular las permutaciones manualmente\n    # Por simplicidad, asumimos que no es istmo si no es loop\n    # (una implementación completa requeriría más lógica)\n    return False\n\ndef bollobas_riordan(R, x, y, z, memo=None):\n    \"\"\"\n    Calcula el polinomio de Bollobás-Riordan de un ribbon graph.\n\n    Args:\n        R: RibbonGraph\n        x, y, z: variables del polinomio\n        memo: diccionario para memoización\n\n    Returns:\n        Polinomio en Q[x,y,z]\n    \"\"\"\n    if memo is None:\n        memo = {}\n\n    # Convertir ribbon graph a una clave hasheable\n    sigma_str = str(R.sigma())\n    rho_str = str(R.rho())\n    clave = (sigma_str, rho_str)\n\n    if clave in memo:\n        return memo[clave]\n\n    # Casos base\n    num_edges = len(R.rho().cycle_tuples())\n    num_boundaries = R.number_boundaries()\n\n    # Caso 1: Sin aristas (solo vértices aislados)\n    if num_edges == 0:\n        # Solo componentes de frontera triviales\n        resultado = (y + z)\n        memo[clave] = resultado\n        return resultado\n\n    # Caso 2: Un ciclo simple (una frontera, una arista)\n    if num_edges == 1 and num_boundaries == 1:\n        resultado = y + z\n        memo[clave] = resultado\n        return resultado\n\n    # Caso recursivo: elegir una arista\n    # Tomamos el primer dart disponible\n    darts = []\n    for ciclo in R.rho().cycle_tuples():\n        darts.extend(ciclo)\n\n    if not darts:\n        resultado = y + z\n        memo[clave] = resultado\n        return resultado\n\n    dart = darts[0]\n\n    # Verificar si es loop\n    if es_loop(R, dart):\n        # R_G = x * R_{G\\e}\n        # Para implementar G\\e necesitamos remover el ciclo de rho\n        # Esto es complejo, por ahora retornamos una aproximación\n        resultado = x * (y + z)  # Simplificación\n        memo[clave] = resultado\n        return resultado\n\n    # Caso general: contracción-borrado\n    # R_G = R_{G/e} + R_{G\\e}\n    try:\n        R_contraido = R.contract_edge(dart)\n        term_contraer = bollobas_riordan(R_contraido, x, y, z, memo)\n    except:\n        term_contraer = 0\n\n    # Para borrar necesitaríamos remover el dart de rho\n    # Implementación simplificada\n    term_borrar = y + z\n\n    resultado = term_contraer + term_borrar\n    memo[clave] = resultado\n    return resultado\n\n# Crear ring de polinomios\nR_poly.&lt;x, y, z&gt; = PolynomialRing(QQ)\n\n# Ejemplo: calcular para un ribbon graph simple\nsigma = PermutationGroupElement('(1,2)')\nrho = PermutationGroupElement('(1,2)')\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Ribbon graph: sigma={R.sigma()}, rho={R.rho()}\")\nprint(f\"Género: {R.genus()}\")\nprint(f\"Fronteras: {R.number_boundaries()}\")\nprint()\n\n# Calcular polinomio (versión simplificada)\npoly = bollobas_riordan(R, x, y, z)\nprint(f\"Polinomio de Bollobás-Riordan (aproximado): {poly}\")\n\n\n\n\n\n\nAdvertenciaNota sobre la Implementación\n\n\n\nLa implementación completa del polinomio de Bollobás-Riordan requiere: 1. Manipulación cuidadosa de las permutaciones para borrar aristas 2. Detección robusta de loops e istmos 3. Memoización eficiente para evitar recálculos 4. Manejo de casos especiales (múltiples componentes, etc.)\nLa versión presentada es una implementación pedagógica simplificada que ilustra la estructura recursiva del polinomio.\n\n\n\n\n\nUna implementación más robusta utilizaría representaciones alternativas:\ndef ribbon_to_graph_data(R):\n    \"\"\"\n    Extrae información combinatoria de un ribbon graph.\n\n    Returns:\n        dict con vértices, aristas, género, etc.\n    \"\"\"\n    sigma_cycles = R.sigma().cycle_tuples(singletons=True)\n    rho_cycles = R.rho().cycle_tuples()\n    phi = R.rho() * R.sigma()\n    phi_cycles = phi.cycle_tuples(singletons=True)\n\n    return {\n        'vertices': len(sigma_cycles),\n        'edges': len(rho_cycles),\n        'faces': len(phi_cycles),\n        'genus': R.genus(),\n        'boundaries': R.number_boundaries(),\n        'euler_char': len(sigma_cycles) - len(rho_cycles) + len(phi_cycles)\n    }\n\n# Ejemplo de uso\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\ninfo = ribbon_to_graph_data(R)\nprint(\"Información del ribbon graph:\")\nfor clave, valor in info.items():\n    print(f\"  {clave}: {valor}\")"
  },
  {
    "objectID": "capitulos/05-ejemplos.html#ejercicios",
    "href": "capitulos/05-ejemplos.html#ejercicios",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "TipEjercicio 1: Dualidad\n\n\n\nImplementa una función que calcule la dual de un ribbon graph y verifica que: 1. \\((G^*)^* = G\\) 2. \\(V^* = F\\) y \\(F^* = V\\) 3. \\(g^* = g\\)\nPrueba con varios ejemplos: K₃ en la esfera, toro con un vértice, etc.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Contracción Iterada\n\n\n\nToma un grafo completo K₄ encajado en una superficie y: 1. Contrae aristas una por una 2. Registra el género después de cada contracción 3. Analiza cómo evoluciona el género\n¿Cuándo la contracción preserva el género? ¿Cuándo lo cambia?\n\n\n\n\n\n\n\n\nTipEjercicio 3: Polinomio de Bollobás-Riordan\n\n\n\nMejora la implementación del polinomio de Bollobás-Riordan para: 1. Manejar correctamente la operación de borrado de aristas 2. Detectar loops e istmos de forma robusta 3. Implementar memoización eficiente\nCalcula el polinomio para grafos pequeños (K₃, K₄, bouquet de círculos).\n\n\n\n\n\n\n\n\nTipEjercicio 4: Base de Homología\n\n\n\nPara un toro con múltiples vértices: 1. Calcula la base de homología usando homology_basis() 2. Visualiza los ciclos fundamentales 3. Verifica que rank(H₁) = 2g + b - 1\nExperimenta con diferentes encajes del mismo grafo y compara las bases."
  },
  {
    "objectID": "capitulos/05-ejemplos.html#resumen",
    "href": "capitulos/05-ejemplos.html#resumen",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "Operaciones: Contracción, reducción y dualidad son transformaciones fundamentales\nHerramientas de Sage: RibbonGraph proporciona métodos poderosos para análisis topológico\nHomología: La base de homología captura los “agujeros” de la superficie\nPolinomio de Bollobás-Riordan: Generaliza el polinomio de Tutte a superficies\nImplementación: Requiere manipulación cuidadosa de permutaciones y recursión\n\nEl polinomio de Bollobás-Riordan es un área activa de investigación con conexiones a: - Teoría de nudos (polinomios de nudos) - Física matemática (modelos de Potts) - Combinatoria enumerativa"
  },
  {
    "objectID": "capitulos/05-ejemplos.html#referencias",
    "href": "capitulos/05-ejemplos.html#referencias",
    "title": "5. Propiedades Adicionales y Polinomios",
    "section": "",
    "text": "Bollobás, B., & Riordan, O. (2002). “A polynomial of graphs on surfaces”. Mathematische Annalen.\nChmutov, S. (2009). “Generalized duality for graphs on surfaces and the signed Bollobás–Riordan polynomial”.\nEllis-Monaghan, J. A., & Moffatt, I. (2013). “Graphs on Surfaces: Dualities, Polynomials, and Knots”.\nSageMath - Ribbon Graphs Documentation"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "",
    "text": "Un enfoque combinatorio para entender encajes de grafos en superficies orientables.",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#sobre-este-proyecto",
    "href": "index.html#sobre-este-proyecto",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "Sobre este proyecto",
    "text": "Sobre este proyecto\nLos sistemas de rotación son pares de permutaciones \\((\\sigma, \\rho)\\) que codifican completamente un encaje celular de un grafo en una superficie orientable. Este proyecto explora la correspondencia biunívoca entre sistemas de rotación y ribbon graphs, establecida por el Teorema de Heffter-Edmonds.\n\nIdea principal\nUn sistema de rotación \\((\\sigma, \\rho)\\) contiene toda la información necesaria para:\n\nReconstruir el grafo subyacente (vértices y aristas)\nDeterminar el orden cíclico de semiaristas alrededor de cada vértice\nCalcular las caras mediante la permutación \\(\\varphi = \\rho\\sigma\\)\nObtener invariantes topológicos: género, característica de Euler, fronteras\nConstruir la superficie completa mediante engrosamiento (thickening)\n\nResultado fundamental: Álgebra de permutaciones ↔︎ Topología de superficies",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#contenido",
    "href": "index.html#contenido",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "Contenido",
    "text": "Contenido\n\n1. Sistemas de Rotación\nIntroducción a los sistemas de rotación como modelo combinatorio de grafos encajados.\n\nDefinición mediante permutaciones \\(\\sigma\\) y \\(\\rho\\)\nSemiaristas (darts) y orden cíclico\nEjemplos básicos con código SageMath\nConstrucción en Sage: RibbonGraph(sigma, rho)",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#herramientas",
    "href": "index.html#herramientas",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "Herramientas",
    "text": "Herramientas\nEste proyecto utiliza:\n\nSageMath 10.7 - Cálculos con RibbonGraph, PermutationGroupElement\nPython 3.13 - Scripts de análisis y visualización\nQuarto - Documentación interactiva con bloques de código ejecutables",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "index.html#referencias",
    "href": "index.html#referencias",
    "title": "Sistemas de Rotación y Ribbon Graphs",
    "section": "Referencias",
    "text": "Referencias\n\nGross, J. L., & Tucker, T. W. (1987). Topological Graph Theory\nLando, S. K., & Zvonkin, A. K. (2004). Graphs on Surfaces\nEdmonds, J. (1960). A combinatorial representation for polyhedral surfaces\nSageMath - Ribbon Graphs Documentation\n\n\n\nJosé Luis León • 2026",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html",
    "href": "capitulos/01-sistemas-rotacion.html",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Queremos codificar encajes celulares de grafos en superficies orientables sin dibujar la superficie, usando sólo datos combinatorios.\n\nEntrada: un grafo abstracto \\(G\\)\nDato extra: un sistema de rotación (orden cíclico local)\nSalida: una superficie orientable donde \\(G\\) queda encajado, más las caras y el género\n\nLa idea es que la información “local” (en vértices) determine completamente la estructura “global” (la superficie).\n\n\n\n\nPara trabajar con sistemas de rotación, descomponemos cada arista del grafo \\(G\\) mediante una partición formal. Insertamos un vértice ficticio (o de paso) en el interior de cada arista, lo que resulta en un conjunto \\(D\\) de semiaristas (también llamadas darts o half-edges).\nEsta construcción garantiza que:\n\nPartición por Arista: Cada arista original queda particionada exactamente en dos semiaristas que comparten el vértice ficticio.\nIncidencia en Vértices Originales: Cada semiarista \\(d \\in D\\) tiene un extremo en un vértice original de \\(G\\) y el otro en un vértice ficticio. Decimos que \\(d\\) está asociada al vértice original donde incide.\nRelación de Adyacencia (Involución): Dos semiaristas son adyacentes si comparten el mismo vértice ficticio. Esto define una permutación \\(\\rho: D \\to D\\) compuesta por trasposiciones (2-ciclos), donde cada ciclo vincula el par de semiaristas que conforman una arista original.\n\n\n\n\n\n\n\nNotaConteo de semiaristas\n\n\n\nSi el grafo tiene \\(E\\) aristas, tendremos \\(|D| = 2E\\) semiaristas en total, donde \\(D\\) es el conjunto de todas las semiaristas.\n\n\n\n\n\nConsideremos el grafo con un vértice y dos aristas.\n\n\n\nVértices: 1\nAristas: 2 aristas\nSemiaristas: 4 (etiquetadas 1, 2, 3, 4)\n\n\n\n\nEtiquetado de semiaristas\n\n\n\n\n\n\n\nUn sistema de rotación sobre un grafo \\(G\\) se define por un par de permutaciones \\((\\sigma, \\rho)\\) sobre el conjunto de semiaristas \\(D\\):\n\n\n\nEs un producto de ciclos disjuntos\nHay un ciclo por cada vértice de \\(G\\)\nCada ciclo describe el orden cíclico de las semiaristas incidentes a ese vértice\nEl orden cíclico refleja cómo las aristas se ordenan alrededor del vértice en la superficie\n\n\n\n\n\nEs un producto de 2-ciclos (transposiciones)\nCada 2-ciclo empareja las dos semiaristas que forman una arista\nEs una involución sin puntos fijos: \\(\\rho^2 = \\mathrm{id}\\)\n\n\n\n\n\n\n\nNotaContexto Histórico y Terminología\n\n\n\nLos sistemas de rotación tienen una rica historia y han sido redescubiertos en múltiples contextos:\n\nOrígenes: Fueron introducidos por Edmonds (1960) y formalizados por Youngs (1963), quien también introdujo sistemas con signo para superficies no orientables. Representaciones similares fueron propuestas independientemente por Jacques, Biggs, y Walsh & Lehman.\nDesarrollo: Tutte y Gross & Alpert extendieron estos sistemas. El encaje celular inducido que revisaremos más adelante es frecuentemente llamado encaje de Heffter-Edmonds.\nSinónimos: En la literatura se encuentran como vortex graphs, constelaciones, mapas combinatorios, fat graphs, ribbon graphs y dessins d’enfants.\n\nNuestra Convención: Adoptamos la notación de SageMath y Lando & Zvonkin, usando el par de permutaciones \\((\\sigma, \\rho)\\) sobre semiaristas y refiriéndonos a la estructura topológica como Ribbon Graph.\n\n\n\n\n\n\n\nRecordando la construcción del ejemplo anterior:\n\n\nVértices: 1\nAristas: 2\nSemiaristas: 4 (etiquetadas 1, 2, 3, 4)\n\nEs importante notar que \\(\\rho\\) está fijo por la construcción del grafo (la elección de qué pares de semiaristas forman cada arista). Por lo tanto, solo podemos variar \\(\\sigma\\).\nComo tenemos 4 semiaristas incidentes al mismo vértice, el número de posibles órdenes cíclicos es \\((4-1)! = 6\\). A continuación listamos todas las posibilidades:\n\n\\(\\sigma = (1, 2, 3, 4)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 2, 4, 3)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 3, 2, 4)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 3, 4, 2)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 4, 2, 3)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 4, 3, 2)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\nCada una de estas elecciones define un sistema de rotación válido. En las siguientes secciones veremos cómo estas permutaciones determinan la topología de la superficie resultante.\n\n\n\n\n\nConsideremos el grafo completo con 3 vértices: \\(K_3\\):\n\n\n\n\nVértices: 3 (A, B, C)\nAristas: 3 (AB, BC, CA)\nSemiaristas: 6 (etiquetadas 1, 2, 3, 4, 5, 6)\n\nAsignación de semiaristas:\n\nVértice A: semiaristas 1, 6\nVértice B: semiaristas 2, 3\nVértice C: semiaristas 4, 5\n\nAristas:\n\nAB: semiaristas 1 y 2\nBC: semiaristas 3 y 4\nCA: semiaristas 5 y 6\n\nPara definir el sistema de rotación, la asignación explícita de semiaristas es necesaria para fijar \\(\\rho\\).\n\n\\(\\rho\\): Queda determinado por los pares que forman las aristas. \\[\\rho = (1, 2)(3, 4)(5, 6)\\]\n\\(\\sigma\\): En este caso, como cada vértice tiene grado 2, existe un único orden cíclico posible para las semiaristas incidentes (\\((a,b)\\) es equivalente a \\((b,a)\\)). \\[\\sigma = (1, 6)(2, 3)(4, 5)\\]\n\nEste sistema describe el encaje estándar de \\(K_3\\) en la esfera (género 0).\n\n\n\n\n\nPara un grafo dado (sin vértices aislados), podemos calcular exactamente cuántos Sistemas de Rotación (que generan superficies orientables) se pueden construir. La fórmula depende enteramente de la conectividad local de los vértices.\n\n\nSi llamamos \\(N(G)\\) al número total de sistemas de rotación para un grafo \\(G\\), tenemos:\n\\[ N(G) = \\prod_{v \\in V(G)} (\\deg(v) - 1)! \\]\nDonde:\n\n\\(\\prod\\): Es el símbolo de producto (multiplicamos el resultado de cada vértice).\n\\(V(G)\\): Es el conjunto de todos los vértices del grafo.\n\\(\\deg(v)\\) (Grado): Es el número de semiaristas que llegan al vértice \\(v\\).\n\\((\\deg(v) - 1)!\\): Es el número de formas de organizar las semiaristas en un círculo (permutaciones cíclicas).\n\n\n\n\n\n\nEl grafo de un vértice y dos lazos:\n\nTenemos 1 vértice con grado \\(4\\).\nCálculo: \\((4-1)! = 6\\) sistemas.\nResultado: Coincide exactamente con la lista de \\(6\\) que vimos anteriormente.\n\nEl Triángulo (\\(K_3\\)):\n\nTenemos 3 vértices, cada uno con grado \\(2\\).\nCálculo: \\((2-1)! \\times (2-1)! \\times (2-1)! = 1\\) sistema.\nResultado: Por eso el \\(K_3\\) es “rígido”; solo puede encajarse de una forma (en la esfera).\n\n\n\n\n\n\nA medida que añadimos vértices y cada uno se conecta con todos los demás, el número de universos topológicos posibles crece de forma estrepitosa:\n\n\n\nGrafo\nVértices\nGrado\nFórmula\nTotal de Sistemas\n\n\n\n\n\\(K_3\\) (Triángulo)\n3\n2\n\\((1!)^3\\)\n1\n\n\n\\(K_4\\) (Tetraedro)\n4\n3\n\\((2!)^4\\)\n16\n\n\n\\(K_5\\) (Pentáculo)\n5\n4\n\\((3!)^5\\)\n7,776\n\n\n\\(K_6\\)\n6\n5\n\\((4!)^6\\)\n191,102,976\n\n\n\\(K_7\\)\n7\n6\n\\((5!)^7\\)\n358,318,080,000,000\n\n\n\n\nNota para la reflexión: ¡Para un simple grafo de 7 vértices, existen más de 358 billones de formas de encajarlo en superficies! La gran mayoría de estas formas resultarán en superficies con muchísimos “agujeros” (género alto), y solo unas pocas tendrán género mínimo (\\(K_7\\) no es planar).\n\n\n\n\n\n\nEl sistema de rotación \\((\\sigma, \\rho)\\) codifica:\n\nEl grafo subyacente\n\nLos ciclos de \\(\\sigma\\) determinan los vértices\nLos 2-ciclos de \\(\\rho\\) determinan las aristas\nPodemos reconstruir \\(G\\) desde \\((\\sigma, \\rho)\\)\n\nEl orden cíclico local\n\nCada ciclo de \\(\\sigma\\) indica cómo se ordenan las semiaristas alrededor de un vértice\nEste orden respeta la orientación de la superficie\n\n\n\n\n\n\nSageMath implementa ribbon graphs directamente desde sistemas de rotación:\nPuedes verificar estos cálculos rápidamente en línea usando SageMathCell.\n\n\nConstruyamos el sistema de rotación más estándar para este grafo:\n# Usamos PermutationGroupElement directamente\nsigma = PermutationGroupElement(\"(1,2,3,4)\")\nrho = PermutationGroupElement(\"(1,2)(3,4)\")\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Objeto creado: {R}\")\nprint(f\"Tipo: {type(R).__name__}\")\n\n# Recuperar las permutaciones almacenadas\nprint(f\"\\nPermutaciones:\")\nprint(f\"  σ = {R.sigma()}\")\nprint(f\"  ρ = {R.rho()}\")\n\n# Contar elementos del grafo\nnum_semiaristas = len(R.sigma().domain())\nnum_vertices = len(R.sigma().cycle_tuples(singletons=True))\nnum_aristas = len(R.rho().cycle_tuples())\n\nprint(f\"\\nEstructura del grafo:\")\nprint(f\"  Semiaristas: {num_semiaristas}\")\nprint(f\"  Vértices: {num_vertices}\")\nprint(f\"  Aristas: {num_aristas}\")\n\n\n\nPodemos etiquetar las semiaristas con cualquier numeración, no necesariamente 1,2,3,…\n# K₃ con numeración consecutiva empezando desde 10\nsigma_k3 = PermutationGroupElement(\"(10,15)(11,12)(13,14)\")\nrho_k3 = PermutationGroupElement(\"(10,11)(12,13)(14,15)\")\nR_k3 = RibbonGraph(sigma_k3, rho_k3)\n\nprint(f\"K₃ con numeración salteada:\")\nprint(f\"  σ = {R_k3.sigma()}\")\nprint(f\"  ρ = {R_k3.rho()}\")\nprint(f\"  Números usados: 10, 11, 12, 13, 14, 15\")\n\n# normalize() renumera del 1 al número de semiaristas\nR_norm = R_k3.normalize()\n\nprint(f\"\\nDespués de normalize():\")\nprint(f\"  σ = {R_norm.sigma()}\")\nprint(f\"  ρ = {R_norm.rho()}\")\nprint(f\"  Números usados: 1, 2, 3, 4, 5, 6\")\n\n# Verificar que la estructura se preserva\nprint(f\"\\nVértices: {len(R_k3.sigma().cycle_tuples())} → {len(R_norm.sigma().cycle_tuples())}\")\nprint(f\"Aristas: {len(R_k3.rho().cycle_tuples())} → {len(R_norm.rho().cycle_tuples())}\")\n\n\n\nPodemos calcular programáticamente cuántos sistemas de rotación existen para un grafo dado:\ndef contar_sistemas(R):\n    \"\"\"\n    Calcula N(G) = ∏(deg(v) - 1)! para un RibbonGraph\n    \"\"\"\n    grados = [len(ciclo) for ciclo in R.sigma().cycle_tuples(singletons=True)]\n    total = 1\n    for g in grados:\n        total *= factorial(g - 1)\n    return total, grados\n\n# Verificar con el Ejemplo 1: Un vértice, dos lazos\nsigma1 = PermutationGroupElement(\"(1,2,3,4)\")\nrho1 = PermutationGroupElement(\"(1,2)(3,4)\")\nR1 = RibbonGraph(sigma1, rho1)\n\ntotal1, grados1 = contar_sistemas(R1)\nprint(f\"Ejemplo 1: Un vértice, dos lazos\")\nprint(f\"  Grados de vértices: {grados1}\")\nprint(f\"  N(G) = (4-1)! = {total1}\")\n\n# Verificar con el Ejemplo 2: K₃\nsigma2 = PermutationGroupElement(\"(1,6)(2,3)(4,5)\")\nrho2 = PermutationGroupElement(\"(1,2)(3,4)(5,6)\")\nR2 = RibbonGraph(sigma2, rho2)\n\ntotal2, grados2 = contar_sistemas(R2)\nprint(f\"\\nEjemplo 2: Triángulo K₃\")\nprint(f\"  Grados de vértices: {grados2}\")\nprint(f\"  N(G) = (1!)³ = {total2}\")\n\n\n\n\n\n\n\n\n\n\n\nTipEjercicio 1\n\n\n\nConsidera un grafo con un vértice y tres self-loops (tres aristas que comienzan y terminan en el mismo vértice).\n\n¿Cuántas semiaristas tiene este sistema?\n¿Cuántos sistemas de rotación posibles existen para este grafo? Usa la fórmula manualmente.\nEscribe en Sage un sistema de rotación \\((\\sigma, \\rho)\\) para este grafo usando PermutationGroupElement.\nUsa la función contar_sistemas(R) del ejemplo para verificar tu cálculo del inciso (b).\n\n\n\n\n\n\n\n\n\nTipEjercicio 2\n\n\n\nExperimentando con numeración y normalización:\n\nCrea un RibbonGraph usando numeración salteada (por ejemplo, usando solo números pares o múltiplos de 5).\nUsa el método .normalize() para obtener la versión canónica.\nVerifica que el número de semiaristas se preserva usando len(R.sigma().domain()).\n¿Qué propiedades del grafo cambian con normalize() y cuáles se preservan?\n\n\n\n\n\n\n\n\n[GGD2011] E. Girondo, G. Gonzalez-Diez, Introduction to Compact Riemann surfaces and Dessins d’enfant, London Mathematical Society, Student Text 79, 2011.\n[LZ2004] S. Lando, A. Zvonkine, Graphs on Surfaces and Their Applications, Springer-Verlag, 2004.\n[Edmonds1960] J. Edmonds, A Combinatorial Representation for Polyhedral Surfaces, Notices Amer. Math. Soc. 7, 1960. (Tesis disponible en UMD)\n[Youngs1963] J. W. T. Youngs, The Genus of a Graph, Journal of Mathematics and Mechanics, Vol. 12, No. 2, 1963. JSTOR",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#motivación",
    "href": "capitulos/01-sistemas-rotacion.html#motivación",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Queremos codificar encajes celulares de grafos en superficies orientables sin dibujar la superficie, usando sólo datos combinatorios.\n\nEntrada: un grafo abstracto \\(G\\)\nDato extra: un sistema de rotación (orden cíclico local)\nSalida: una superficie orientable donde \\(G\\) queda encajado, más las caras y el género\n\nLa idea es que la información “local” (en vértices) determine completamente la estructura “global” (la superficie).",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#semiaristas-darts-o-half-edges",
    "href": "capitulos/01-sistemas-rotacion.html#semiaristas-darts-o-half-edges",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Para trabajar con sistemas de rotación, descomponemos cada arista del grafo \\(G\\) mediante una partición formal. Insertamos un vértice ficticio (o de paso) en el interior de cada arista, lo que resulta en un conjunto \\(D\\) de semiaristas (también llamadas darts o half-edges).\nEsta construcción garantiza que:\n\nPartición por Arista: Cada arista original queda particionada exactamente en dos semiaristas que comparten el vértice ficticio.\nIncidencia en Vértices Originales: Cada semiarista \\(d \\in D\\) tiene un extremo en un vértice original de \\(G\\) y el otro en un vértice ficticio. Decimos que \\(d\\) está asociada al vértice original donde incide.\nRelación de Adyacencia (Involución): Dos semiaristas son adyacentes si comparten el mismo vértice ficticio. Esto define una permutación \\(\\rho: D \\to D\\) compuesta por trasposiciones (2-ciclos), donde cada ciclo vincula el par de semiaristas que conforman una arista original.\n\n\n\n\n\n\n\nNotaConteo de semiaristas\n\n\n\nSi el grafo tiene \\(E\\) aristas, tendremos \\(|D| = 2E\\) semiaristas en total, donde \\(D\\) es el conjunto de todas las semiaristas.",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#ejemplo-1-un-vértice-dos-lazos",
    "href": "capitulos/01-sistemas-rotacion.html#ejemplo-1-un-vértice-dos-lazos",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Consideremos el grafo con un vértice y dos aristas.\n\n\n\nVértices: 1\nAristas: 2 aristas\nSemiaristas: 4 (etiquetadas 1, 2, 3, 4)\n\n\n\n\nEtiquetado de semiaristas",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#definición-sistema-de-rotación",
    "href": "capitulos/01-sistemas-rotacion.html#definición-sistema-de-rotación",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Un sistema de rotación sobre un grafo \\(G\\) se define por un par de permutaciones \\((\\sigma, \\rho)\\) sobre el conjunto de semiaristas \\(D\\):\n\n\n\nEs un producto de ciclos disjuntos\nHay un ciclo por cada vértice de \\(G\\)\nCada ciclo describe el orden cíclico de las semiaristas incidentes a ese vértice\nEl orden cíclico refleja cómo las aristas se ordenan alrededor del vértice en la superficie\n\n\n\n\n\nEs un producto de 2-ciclos (transposiciones)\nCada 2-ciclo empareja las dos semiaristas que forman una arista\nEs una involución sin puntos fijos: \\(\\rho^2 = \\mathrm{id}\\)\n\n\n\n\n\n\n\nNotaContexto Histórico y Terminología\n\n\n\nLos sistemas de rotación tienen una rica historia y han sido redescubiertos en múltiples contextos:\n\nOrígenes: Fueron introducidos por Edmonds (1960) y formalizados por Youngs (1963), quien también introdujo sistemas con signo para superficies no orientables. Representaciones similares fueron propuestas independientemente por Jacques, Biggs, y Walsh & Lehman.\nDesarrollo: Tutte y Gross & Alpert extendieron estos sistemas. El encaje celular inducido que revisaremos más adelante es frecuentemente llamado encaje de Heffter-Edmonds.\nSinónimos: En la literatura se encuentran como vortex graphs, constelaciones, mapas combinatorios, fat graphs, ribbon graphs y dessins d’enfants.\n\nNuestra Convención: Adoptamos la notación de SageMath y Lando & Zvonkin, usando el par de permutaciones \\((\\sigma, \\rho)\\) sobre semiaristas y refiriéndonos a la estructura topológica como Ribbon Graph.",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#ejemplo-un-vértice-dos-lazos",
    "href": "capitulos/01-sistemas-rotacion.html#ejemplo-un-vértice-dos-lazos",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Recordando la construcción del ejemplo anterior:\n\n\nVértices: 1\nAristas: 2\nSemiaristas: 4 (etiquetadas 1, 2, 3, 4)\n\nEs importante notar que \\(\\rho\\) está fijo por la construcción del grafo (la elección de qué pares de semiaristas forman cada arista). Por lo tanto, solo podemos variar \\(\\sigma\\).\nComo tenemos 4 semiaristas incidentes al mismo vértice, el número de posibles órdenes cíclicos es \\((4-1)! = 6\\). A continuación listamos todas las posibilidades:\n\n\\(\\sigma = (1, 2, 3, 4)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 2, 4, 3)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 3, 2, 4)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 3, 4, 2)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 4, 2, 3)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\\(\\sigma = (1, 4, 3, 2)\\), \\(\\rho = (1, 2)(3, 4)\\)\n\nCada una de estas elecciones define un sistema de rotación válido. En las siguientes secciones veremos cómo estas permutaciones determinan la topología de la superficie resultante.",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#ejemplo-2-triángulo-k₃",
    "href": "capitulos/01-sistemas-rotacion.html#ejemplo-2-triángulo-k₃",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Consideremos el grafo completo con 3 vértices: \\(K_3\\):\n\n\n\n\nVértices: 3 (A, B, C)\nAristas: 3 (AB, BC, CA)\nSemiaristas: 6 (etiquetadas 1, 2, 3, 4, 5, 6)\n\nAsignación de semiaristas:\n\nVértice A: semiaristas 1, 6\nVértice B: semiaristas 2, 3\nVértice C: semiaristas 4, 5\n\nAristas:\n\nAB: semiaristas 1 y 2\nBC: semiaristas 3 y 4\nCA: semiaristas 5 y 6\n\nPara definir el sistema de rotación, la asignación explícita de semiaristas es necesaria para fijar \\(\\rho\\).\n\n\\(\\rho\\): Queda determinado por los pares que forman las aristas. \\[\\rho = (1, 2)(3, 4)(5, 6)\\]\n\\(\\sigma\\): En este caso, como cada vértice tiene grado 2, existe un único orden cíclico posible para las semiaristas incidentes (\\((a,b)\\) es equivalente a \\((b,a)\\)). \\[\\sigma = (1, 6)(2, 3)(4, 5)\\]\n\nEste sistema describe el encaje estándar de \\(K_3\\) en la esfera (género 0).",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#el-big-bang-combinatorio-cuántos-encajes-existen",
    "href": "capitulos/01-sistemas-rotacion.html#el-big-bang-combinatorio-cuántos-encajes-existen",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "Para un grafo dado (sin vértices aislados), podemos calcular exactamente cuántos Sistemas de Rotación (que generan superficies orientables) se pueden construir. La fórmula depende enteramente de la conectividad local de los vértices.\n\n\nSi llamamos \\(N(G)\\) al número total de sistemas de rotación para un grafo \\(G\\), tenemos:\n\\[ N(G) = \\prod_{v \\in V(G)} (\\deg(v) - 1)! \\]\nDonde:\n\n\\(\\prod\\): Es el símbolo de producto (multiplicamos el resultado de cada vértice).\n\\(V(G)\\): Es el conjunto de todos los vértices del grafo.\n\\(\\deg(v)\\) (Grado): Es el número de semiaristas que llegan al vértice \\(v\\).\n\\((\\deg(v) - 1)!\\): Es el número de formas de organizar las semiaristas en un círculo (permutaciones cíclicas).\n\n\n\n\n\n\nEl grafo de un vértice y dos lazos:\n\nTenemos 1 vértice con grado \\(4\\).\nCálculo: \\((4-1)! = 6\\) sistemas.\nResultado: Coincide exactamente con la lista de \\(6\\) que vimos anteriormente.\n\nEl Triángulo (\\(K_3\\)):\n\nTenemos 3 vértices, cada uno con grado \\(2\\).\nCálculo: \\((2-1)! \\times (2-1)! \\times (2-1)! = 1\\) sistema.\nResultado: Por eso el \\(K_3\\) es “rígido”; solo puede encajarse de una forma (en la esfera).\n\n\n\n\n\n\nA medida que añadimos vértices y cada uno se conecta con todos los demás, el número de universos topológicos posibles crece de forma estrepitosa:\n\n\n\nGrafo\nVértices\nGrado\nFórmula\nTotal de Sistemas\n\n\n\n\n\\(K_3\\) (Triángulo)\n3\n2\n\\((1!)^3\\)\n1\n\n\n\\(K_4\\) (Tetraedro)\n4\n3\n\\((2!)^4\\)\n16\n\n\n\\(K_5\\) (Pentáculo)\n5\n4\n\\((3!)^5\\)\n7,776\n\n\n\\(K_6\\)\n6\n5\n\\((4!)^6\\)\n191,102,976\n\n\n\\(K_7\\)\n7\n6\n\\((5!)^7\\)\n358,318,080,000,000\n\n\n\n\nNota para la reflexión: ¡Para un simple grafo de 7 vértices, existen más de 358 billones de formas de encajarlo en superficies! La gran mayoría de estas formas resultarán en superficies con muchísimos “agujeros” (género alto), y solo unas pocas tendrán género mínimo (\\(K_7\\) no es planar).",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#interpretación-geométrica",
    "href": "capitulos/01-sistemas-rotacion.html#interpretación-geométrica",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "El sistema de rotación \\((\\sigma, \\rho)\\) codifica:\n\nEl grafo subyacente\n\nLos ciclos de \\(\\sigma\\) determinan los vértices\nLos 2-ciclos de \\(\\rho\\) determinan las aristas\nPodemos reconstruir \\(G\\) desde \\((\\sigma, \\rho)\\)\n\nEl orden cíclico local\n\nCada ciclo de \\(\\sigma\\) indica cómo se ordenan las semiaristas alrededor de un vértice\nEste orden respeta la orientación de la superficie",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#construcción-en-sagemath",
    "href": "capitulos/01-sistemas-rotacion.html#construcción-en-sagemath",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "SageMath implementa ribbon graphs directamente desde sistemas de rotación:\nPuedes verificar estos cálculos rápidamente en línea usando SageMathCell.\n\n\nConstruyamos el sistema de rotación más estándar para este grafo:\n# Usamos PermutationGroupElement directamente\nsigma = PermutationGroupElement(\"(1,2,3,4)\")\nrho = PermutationGroupElement(\"(1,2)(3,4)\")\nR = RibbonGraph(sigma, rho)\n\nprint(f\"Objeto creado: {R}\")\nprint(f\"Tipo: {type(R).__name__}\")\n\n# Recuperar las permutaciones almacenadas\nprint(f\"\\nPermutaciones:\")\nprint(f\"  σ = {R.sigma()}\")\nprint(f\"  ρ = {R.rho()}\")\n\n# Contar elementos del grafo\nnum_semiaristas = len(R.sigma().domain())\nnum_vertices = len(R.sigma().cycle_tuples(singletons=True))\nnum_aristas = len(R.rho().cycle_tuples())\n\nprint(f\"\\nEstructura del grafo:\")\nprint(f\"  Semiaristas: {num_semiaristas}\")\nprint(f\"  Vértices: {num_vertices}\")\nprint(f\"  Aristas: {num_aristas}\")\n\n\n\nPodemos etiquetar las semiaristas con cualquier numeración, no necesariamente 1,2,3,…\n# K₃ con numeración consecutiva empezando desde 10\nsigma_k3 = PermutationGroupElement(\"(10,15)(11,12)(13,14)\")\nrho_k3 = PermutationGroupElement(\"(10,11)(12,13)(14,15)\")\nR_k3 = RibbonGraph(sigma_k3, rho_k3)\n\nprint(f\"K₃ con numeración salteada:\")\nprint(f\"  σ = {R_k3.sigma()}\")\nprint(f\"  ρ = {R_k3.rho()}\")\nprint(f\"  Números usados: 10, 11, 12, 13, 14, 15\")\n\n# normalize() renumera del 1 al número de semiaristas\nR_norm = R_k3.normalize()\n\nprint(f\"\\nDespués de normalize():\")\nprint(f\"  σ = {R_norm.sigma()}\")\nprint(f\"  ρ = {R_norm.rho()}\")\nprint(f\"  Números usados: 1, 2, 3, 4, 5, 6\")\n\n# Verificar que la estructura se preserva\nprint(f\"\\nVértices: {len(R_k3.sigma().cycle_tuples())} → {len(R_norm.sigma().cycle_tuples())}\")\nprint(f\"Aristas: {len(R_k3.rho().cycle_tuples())} → {len(R_norm.rho().cycle_tuples())}\")\n\n\n\nPodemos calcular programáticamente cuántos sistemas de rotación existen para un grafo dado:\ndef contar_sistemas(R):\n    \"\"\"\n    Calcula N(G) = ∏(deg(v) - 1)! para un RibbonGraph\n    \"\"\"\n    grados = [len(ciclo) for ciclo in R.sigma().cycle_tuples(singletons=True)]\n    total = 1\n    for g in grados:\n        total *= factorial(g - 1)\n    return total, grados\n\n# Verificar con el Ejemplo 1: Un vértice, dos lazos\nsigma1 = PermutationGroupElement(\"(1,2,3,4)\")\nrho1 = PermutationGroupElement(\"(1,2)(3,4)\")\nR1 = RibbonGraph(sigma1, rho1)\n\ntotal1, grados1 = contar_sistemas(R1)\nprint(f\"Ejemplo 1: Un vértice, dos lazos\")\nprint(f\"  Grados de vértices: {grados1}\")\nprint(f\"  N(G) = (4-1)! = {total1}\")\n\n# Verificar con el Ejemplo 2: K₃\nsigma2 = PermutationGroupElement(\"(1,6)(2,3)(4,5)\")\nrho2 = PermutationGroupElement(\"(1,2)(3,4)(5,6)\")\nR2 = RibbonGraph(sigma2, rho2)\n\ntotal2, grados2 = contar_sistemas(R2)\nprint(f\"\\nEjemplo 2: Triángulo K₃\")\nprint(f\"  Grados de vértices: {grados2}\")\nprint(f\"  N(G) = (1!)³ = {total2}\")",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#ejercicios",
    "href": "capitulos/01-sistemas-rotacion.html#ejercicios",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "TipEjercicio 1\n\n\n\nConsidera un grafo con un vértice y tres self-loops (tres aristas que comienzan y terminan en el mismo vértice).\n\n¿Cuántas semiaristas tiene este sistema?\n¿Cuántos sistemas de rotación posibles existen para este grafo? Usa la fórmula manualmente.\nEscribe en Sage un sistema de rotación \\((\\sigma, \\rho)\\) para este grafo usando PermutationGroupElement.\nUsa la función contar_sistemas(R) del ejemplo para verificar tu cálculo del inciso (b).\n\n\n\n\n\n\n\n\n\nTipEjercicio 2\n\n\n\nExperimentando con numeración y normalización:\n\nCrea un RibbonGraph usando numeración salteada (por ejemplo, usando solo números pares o múltiplos de 5).\nUsa el método .normalize() para obtener la versión canónica.\nVerifica que el número de semiaristas se preserva usando len(R.sigma().domain()).\n¿Qué propiedades del grafo cambian con normalize() y cuáles se preservan?",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/01-sistemas-rotacion.html#referencias",
    "href": "capitulos/01-sistemas-rotacion.html#referencias",
    "title": "1. Sistemas de Rotación",
    "section": "",
    "text": "[GGD2011] E. Girondo, G. Gonzalez-Diez, Introduction to Compact Riemann surfaces and Dessins d’enfant, London Mathematical Society, Student Text 79, 2011.\n[LZ2004] S. Lando, A. Zvonkine, Graphs on Surfaces and Their Applications, Springer-Verlag, 2004.\n[Edmonds1960] J. Edmonds, A Combinatorial Representation for Polyhedral Surfaces, Notices Amer. Math. Soc. 7, 1960. (Tesis disponible en UMD)\n[Youngs1963] J. W. T. Youngs, The Genus of a Graph, Journal of Mathematics and Mechanics, Vol. 12, No. 2, 1963. JSTOR",
    "crumbs": [
      "Inicio",
      "1. Sistemas de Rotación"
    ]
  },
  {
    "objectID": "capitulos/03-invariantes.html",
    "href": "capitulos/03-invariantes.html",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Una vez que tenemos un sistema de rotación \\((\\sigma, \\rho)\\), podemos calcular todos los invariantes topológicos de la superficie resultante sin necesidad de visualizarla. Los cálculos se hacen directamente sobre las permutaciones.\nLos invariantes principales son:\n\nNúmero de vértices (\\(V\\))\nNúmero de aristas (\\(E\\))\nNúmero de caras (\\(F\\))\nCaracterística de Euler (\\(\\chi = V - E + F\\))\nGénero (\\(g\\))\nComponentes de frontera (\\(b\\))\n\n\n\n\nComo vimos en el capítulo anterior, las caras del encaje están determinadas por los ciclos de la permutación: \\[ \\varphi = \\rho \\sigma \\]\nEl número de caras \\(F\\) es simplemente el número de ciclos disjuntos en \\(\\varphi\\). Este dato es la pieza faltante para conectar la combinatoria con la topología.\n\n\n\n\nSageMath calcula automáticamente todas las caras:\nfrom sage.graphs.ribbon_graph import RibbonGraph\nfrom sage.all import PermutationGroupElement\n\n# Ejemplo: toro\nsigma = PermutationGroupElement('(1,3,2,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Obtener las caras (componentes de frontera)\ncaras = list(R.faces())\nprint(f\"Número de caras: {len(caras)}\")\nprint(f\"Caras: {caras}\")\n\n# También podemos usar boundary()\nfronteras = R.boundary()\nprint(f\"Componentes de frontera: {fronteras}\")\nSalida:\nNúmero de caras: 1\nCaras: [[1, 4, 3, 2]]\nComponentes de frontera: [[1, 4, 3, 2]]\n\n\n\n\nUna vez conocemos \\(V\\), \\(E\\) y \\(F\\), calculamos la característica de Euler:\n\\[\n\\chi = V - E + F\n\\]\n\n\n\n\\(V\\) = número de ciclos de \\(\\sigma\\)\n\\(E\\) = número de 2-ciclos de \\(\\rho\\) = \\(|D|/2\\) (donde \\(|D|\\) es el número de semiaristas)\n\\(F\\) = número de ciclos de \\(\\varphi\\)\n\n\n# Ejemplo\nsigma = PermutationGroupElement('(1,3,2,4)')  # 1 ciclo → V = 1\nrho = PermutationGroupElement('(1,2)(3,4)')   # 2 ciclos → E = 2\n# D = 4 semiaristas\n\nR = RibbonGraph(sigma, rho)\n\nV = R.num_vertices()             # 1\nE = R.num_edges()                # 2\nF = len(list(R.faces()))         # 1\n\nchi = V - E + F\nprint(f\"χ = {V} - {E} + {F} = {chi}\")\nSalida:\nχ = 1 - 2 + 1 = 0\n\n\n\n\n\nPara superficies orientables cerradas (sin frontera), la relación es:\n\\[\n\\chi = 2 - 2g\n\\]\nDe donde: \\[\ng = 1 - \\frac{\\chi}{2} = \\frac{2-\\chi}{2}\n\\]\n\n\nPara superficies con frontera, la fórmula se generaliza:\n\\[\n\\chi = 2 - 2g - b\n\\]\ndonde \\(b\\) es el número de componentes de frontera.\nDe aquí: \\[\ng = \\frac{2 - \\chi - b}{2}\n\\]\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Sage calcula directamente\ng = R.genus()\nb = R.number_boundaries()\n\nprint(f\"Género: {g}\")\nprint(f\"Componentes de frontera: {b}\")\n\n# Verificar con la fórmula\nchi = R.num_vertices() - R.num_edges() + len(list(R.faces()))\ng_calculado = (2 - chi - b) // 2\n\nprint(f\"Verificación: g = (2 - {chi} - {b})/2 = {g_calculado}\")\nSalida:\nGénero: 1\nComponentes de frontera: 0\nVerificación: g = (2 - 0 - 0)/2 = 1\n\n\n\n\n\n\n\n# Sistema con frontera\nsigma = PermutationGroupElement('(1,2,3)')\nrho = PermutationGroupElement('(1,2)')\nR = RibbonGraph(sigma, rho)\nprint(f\"Género: {R.genus()}\")\nprint(f\"Fronteras: {R.number_boundaries()}\")\n# Resultado: g=0, b=1 (Disco)\n\n\n\n# K₃ con encaje planar\nR = RibbonGraph('(1,6)(2,3)(4,5)', '(1,2)(3,4)(5,6)')\nprint(f\"Género: {R.genus()}\")\n# Resultado: g=0 (Esfera)\n\n\n\n# Un vértice con 3 self-loops\nR = RibbonGraph('(1,2,3,4,5,6)', '(1,2)(3,4)(5,6)')\nprint(f\"Género: {R.genus()}\")\n# Resultado: g=1 (Toro con 1 frontera si b=1, o Toro cerrado si b=0?)\n# Verifiquemos: V=1, E=3. Si F=1 -&gt; 1-3+1 = -1. Imposible para cerrada.\n# Debe ser superficie con frontera.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEjemplo\n\\(\\sigma\\)\n\\(\\rho\\)\n\\(V\\)\n\\(E\\)\n\\(F\\)\n\\(\\chi\\)\n\\(g\\)\n\\(b\\)\n\n\n\n\nToro\n\\((1,2,3,4)\\)\n\\((1,2)(3,4)\\)\n1\n2\n1\n0\n1\n0\n\n\nCilindro\n\\((1,2,3)\\)\n\\((1,2)\\)\n1\n1\n2\n0\n0\n2\n\n\nK₃ plano\n\\((1,6)(2,3)(4,5)\\)\n\\((1,2)(3,4)(5,6)\\)\n3\n3\n2\n2\n0\n0\n\n\nBouquet 3\n\\((1,2,3,4,5,6)\\)\n\\((1,2)(3,4)(5,6)\\)\n1\n3\n4\n2\n0\n4\n\n\n\n\n\n\nPodemos crear una función para calcular todos los invariantes:\n\ndef calcular_invariantes(sigma, rho):\n    \"\"\"\n    Calcula todos los invariantes topológicos de un sistema de rotación.\n    \"\"\"\n    # Asegurar que son permutaciones si se pasan strings\n    if isinstance(sigma, str): sigma = PermutationGroupElement(sigma)\n    if isinstance(rho, str): rho = PermutationGroupElement(rho)\n\n    R = RibbonGraph(sigma, rho)\n\n    V = R.num_vertices()\n    E = R.num_edges()\n    F = len(list(R.faces()))\n    chi = V - E + F\n    g = R.genus()\n    b = R.number_boundaries()\n\n    print(f\"{'='*50}\")\n    print(f\"Sistema de Rotación\")\n    print(f\"{'='*50}\")\n    print(f\"σ = {sigma}\")\n    print(f\"ρ = {rho}\")\n    print(f\"{'-'*50}\")\n    print(f\"Vértices (V):              {V}\")\n    print(f\"Aristas (E):               {E}\")\n    print(f\"Caras (F):                 {F}\")\n    print(f\"Característica de Euler:   χ = {chi}\")\n    print(f\"Género:                    g = {g}\")\n    print(f\"Componentes de frontera:   b = {b}\")\n    print(f\"{'='*50}\")\n    print(f\"Fórmula: χ = 2 - 2g - b = {2 - 2*g - b} ✓\")\n    print(f\"{'='*50}\")\n\n    return {\n        'V': V, 'E': E, 'F': F,\n        'chi': chi, 'g': g, 'b': b\n    }\n\n# Uso\ninv = calcular_invariantes('(1,2,3,4)', '(1,2)(3,4)')\n\n\n\n\n\n\n\n\n\n\nTipEjercicio 1: Crear tu propio ejemplo\n\n\n\nDiseña un sistema de rotación que produzca:\n\nUn bitoro (género 2, sin frontera)\nUna esfera con 3 agujeros (g=0, b=3)\nUn toro con 2 agujeros (g=1, b=2)\n\nVerifica tus construcciones con Sage.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Variaciones del bouquet\n\n\n\nExperimenta con el bouquet de 4 círculos (8 semiaristas):\n\nPrueba diferentes órdenes cíclicos en \\(\\sigma\\)\nCalcula el género para cada caso\n¿Cuál es el género máximo que puedes obtener?\n¿Cuál es el género mínimo?\n\n\n\n\n\n\n\n\n\nTipEjercicio 3: Grafos completos\n\n\n\nInvestiga los grafos completos \\(K_n\\):\n\nVerifica que K₃ tiene género 0\nCalcula el género mínimo de K₄\nBusca en la literatura el género de K₅ y K₆\n\n\n\n\n\n\n\n\nCálculo de invariantes: Se obtienen contando ciclos en las permutaciones, sin necesidad de visualización.\nElementos: \\(V\\) (ciclos de \\(\\sigma\\)), \\(E\\) (ciclos de \\(\\rho\\)), \\(F\\) (ciclos de \\(\\varphi = \\rho \\sigma\\)).\nFórmulas topológicas:\n\nCaracterística de Euler: \\(\\chi = V - E + F\\)\nGénero: \\(g = \\frac{2 - \\chi - b}{2}\\)\n\nSageMath: R.genus(), R.number_boundaries() y R.faces() para el cálculo automático.\n\nEn el siguiente capítulo estudiaremos los teoremas fundamentales que establecen la equivalencia entre sistemas de rotación y encajes celulares (Teorema de Heffter-Edmonds) y las propiedades de los mapas combinatorios."
  },
  {
    "objectID": "capitulos/03-invariantes.html#introducción",
    "href": "capitulos/03-invariantes.html#introducción",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Una vez que tenemos un sistema de rotación \\((\\sigma, \\rho)\\), podemos calcular todos los invariantes topológicos de la superficie resultante sin necesidad de visualizarla. Los cálculos se hacen directamente sobre las permutaciones.\nLos invariantes principales son:\n\nNúmero de vértices (\\(V\\))\nNúmero de aristas (\\(E\\))\nNúmero de caras (\\(F\\))\nCaracterística de Euler (\\(\\chi = V - E + F\\))\nGénero (\\(g\\))\nComponentes de frontera (\\(b\\))"
  },
  {
    "objectID": "capitulos/03-invariantes.html#recapitulación-caras-y-varphi",
    "href": "capitulos/03-invariantes.html#recapitulación-caras-y-varphi",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Como vimos en el capítulo anterior, las caras del encaje están determinadas por los ciclos de la permutación: \\[ \\varphi = \\rho \\sigma \\]\nEl número de caras \\(F\\) es simplemente el número de ciclos disjuntos en \\(\\varphi\\). Este dato es la pieza faltante para conectar la combinatoria con la topología."
  },
  {
    "objectID": "capitulos/03-invariantes.html#cálculo-en-sagemath",
    "href": "capitulos/03-invariantes.html#cálculo-en-sagemath",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "SageMath calcula automáticamente todas las caras:\nfrom sage.graphs.ribbon_graph import RibbonGraph\nfrom sage.all import PermutationGroupElement\n\n# Ejemplo: toro\nsigma = PermutationGroupElement('(1,3,2,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Obtener las caras (componentes de frontera)\ncaras = list(R.faces())\nprint(f\"Número de caras: {len(caras)}\")\nprint(f\"Caras: {caras}\")\n\n# También podemos usar boundary()\nfronteras = R.boundary()\nprint(f\"Componentes de frontera: {fronteras}\")\nSalida:\nNúmero de caras: 1\nCaras: [[1, 4, 3, 2]]\nComponentes de frontera: [[1, 4, 3, 2]]"
  },
  {
    "objectID": "capitulos/03-invariantes.html#característica-de-euler",
    "href": "capitulos/03-invariantes.html#característica-de-euler",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Una vez conocemos \\(V\\), \\(E\\) y \\(F\\), calculamos la característica de Euler:\n\\[\n\\chi = V - E + F\n\\]\n\n\n\n\\(V\\) = número de ciclos de \\(\\sigma\\)\n\\(E\\) = número de 2-ciclos de \\(\\rho\\) = \\(|D|/2\\) (donde \\(|D|\\) es el número de semiaristas)\n\\(F\\) = número de ciclos de \\(\\varphi\\)\n\n\n# Ejemplo\nsigma = PermutationGroupElement('(1,3,2,4)')  # 1 ciclo → V = 1\nrho = PermutationGroupElement('(1,2)(3,4)')   # 2 ciclos → E = 2\n# D = 4 semiaristas\n\nR = RibbonGraph(sigma, rho)\n\nV = R.num_vertices()             # 1\nE = R.num_edges()                # 2\nF = len(list(R.faces()))         # 1\n\nchi = V - E + F\nprint(f\"χ = {V} - {E} + {F} = {chi}\")\nSalida:\nχ = 1 - 2 + 1 = 0"
  },
  {
    "objectID": "capitulos/03-invariantes.html#género",
    "href": "capitulos/03-invariantes.html#género",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Para superficies orientables cerradas (sin frontera), la relación es:\n\\[\n\\chi = 2 - 2g\n\\]\nDe donde: \\[\ng = 1 - \\frac{\\chi}{2} = \\frac{2-\\chi}{2}\n\\]\n\n\nPara superficies con frontera, la fórmula se generaliza:\n\\[\n\\chi = 2 - 2g - b\n\\]\ndonde \\(b\\) es el número de componentes de frontera.\nDe aquí: \\[\ng = \\frac{2 - \\chi - b}{2}\n\\]\n\nsigma = PermutationGroupElement('(1,2,3,4)')\nrho = PermutationGroupElement('(1,2)(3,4)')\nR = RibbonGraph(sigma, rho)\n\n# Sage calcula directamente\ng = R.genus()\nb = R.number_boundaries()\n\nprint(f\"Género: {g}\")\nprint(f\"Componentes de frontera: {b}\")\n\n# Verificar con la fórmula\nchi = R.num_vertices() - R.num_edges() + len(list(R.faces()))\ng_calculado = (2 - chi - b) // 2\n\nprint(f\"Verificación: g = (2 - {chi} - {b})/2 = {g_calculado}\")\nSalida:\nGénero: 1\nComponentes de frontera: 0\nVerificación: g = (2 - 0 - 0)/2 = 1"
  },
  {
    "objectID": "capitulos/03-invariantes.html#ejemplos-de-cálculo",
    "href": "capitulos/03-invariantes.html#ejemplos-de-cálculo",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "# Sistema con frontera\nsigma = PermutationGroupElement('(1,2,3)')\nrho = PermutationGroupElement('(1,2)')\nR = RibbonGraph(sigma, rho)\nprint(f\"Género: {R.genus()}\")\nprint(f\"Fronteras: {R.number_boundaries()}\")\n# Resultado: g=0, b=1 (Disco)\n\n\n\n# K₃ con encaje planar\nR = RibbonGraph('(1,6)(2,3)(4,5)', '(1,2)(3,4)(5,6)')\nprint(f\"Género: {R.genus()}\")\n# Resultado: g=0 (Esfera)\n\n\n\n# Un vértice con 3 self-loops\nR = RibbonGraph('(1,2,3,4,5,6)', '(1,2)(3,4)(5,6)')\nprint(f\"Género: {R.genus()}\")\n# Resultado: g=1 (Toro con 1 frontera si b=1, o Toro cerrado si b=0?)\n# Verifiquemos: V=1, E=3. Si F=1 -&gt; 1-3+1 = -1. Imposible para cerrada.\n# Debe ser superficie con frontera."
  },
  {
    "objectID": "capitulos/03-invariantes.html#tabla-de-ejemplos",
    "href": "capitulos/03-invariantes.html#tabla-de-ejemplos",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Ejemplo\n\\(\\sigma\\)\n\\(\\rho\\)\n\\(V\\)\n\\(E\\)\n\\(F\\)\n\\(\\chi\\)\n\\(g\\)\n\\(b\\)\n\n\n\n\nToro\n\\((1,2,3,4)\\)\n\\((1,2)(3,4)\\)\n1\n2\n1\n0\n1\n0\n\n\nCilindro\n\\((1,2,3)\\)\n\\((1,2)\\)\n1\n1\n2\n0\n0\n2\n\n\nK₃ plano\n\\((1,6)(2,3)(4,5)\\)\n\\((1,2)(3,4)(5,6)\\)\n3\n3\n2\n2\n0\n0\n\n\nBouquet 3\n\\((1,2,3,4,5,6)\\)\n\\((1,2)(3,4)(5,6)\\)\n1\n3\n4\n2\n0\n4"
  },
  {
    "objectID": "capitulos/03-invariantes.html#implementación-función-auxiliar",
    "href": "capitulos/03-invariantes.html#implementación-función-auxiliar",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Podemos crear una función para calcular todos los invariantes:\n\ndef calcular_invariantes(sigma, rho):\n    \"\"\"\n    Calcula todos los invariantes topológicos de un sistema de rotación.\n    \"\"\"\n    # Asegurar que son permutaciones si se pasan strings\n    if isinstance(sigma, str): sigma = PermutationGroupElement(sigma)\n    if isinstance(rho, str): rho = PermutationGroupElement(rho)\n\n    R = RibbonGraph(sigma, rho)\n\n    V = R.num_vertices()\n    E = R.num_edges()\n    F = len(list(R.faces()))\n    chi = V - E + F\n    g = R.genus()\n    b = R.number_boundaries()\n\n    print(f\"{'='*50}\")\n    print(f\"Sistema de Rotación\")\n    print(f\"{'='*50}\")\n    print(f\"σ = {sigma}\")\n    print(f\"ρ = {rho}\")\n    print(f\"{'-'*50}\")\n    print(f\"Vértices (V):              {V}\")\n    print(f\"Aristas (E):               {E}\")\n    print(f\"Caras (F):                 {F}\")\n    print(f\"Característica de Euler:   χ = {chi}\")\n    print(f\"Género:                    g = {g}\")\n    print(f\"Componentes de frontera:   b = {b}\")\n    print(f\"{'='*50}\")\n    print(f\"Fórmula: χ = 2 - 2g - b = {2 - 2*g - b} ✓\")\n    print(f\"{'='*50}\")\n\n    return {\n        'V': V, 'E': E, 'F': F,\n        'chi': chi, 'g': g, 'b': b\n    }\n\n# Uso\ninv = calcular_invariantes('(1,2,3,4)', '(1,2)(3,4)')"
  },
  {
    "objectID": "capitulos/03-invariantes.html#ejercicios",
    "href": "capitulos/03-invariantes.html#ejercicios",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "TipEjercicio 1: Crear tu propio ejemplo\n\n\n\nDiseña un sistema de rotación que produzca:\n\nUn bitoro (género 2, sin frontera)\nUna esfera con 3 agujeros (g=0, b=3)\nUn toro con 2 agujeros (g=1, b=2)\n\nVerifica tus construcciones con Sage.\n\n\n\n\n\n\n\n\nTipEjercicio 2: Variaciones del bouquet\n\n\n\nExperimenta con el bouquet de 4 círculos (8 semiaristas):\n\nPrueba diferentes órdenes cíclicos en \\(\\sigma\\)\nCalcula el género para cada caso\n¿Cuál es el género máximo que puedes obtener?\n¿Cuál es el género mínimo?\n\n\n\n\n\n\n\n\n\nTipEjercicio 3: Grafos completos\n\n\n\nInvestiga los grafos completos \\(K_n\\):\n\nVerifica que K₃ tiene género 0\nCalcula el género mínimo de K₄\nBusca en la literatura el género de K₅ y K₆"
  },
  {
    "objectID": "capitulos/03-invariantes.html#resumen",
    "href": "capitulos/03-invariantes.html#resumen",
    "title": "3. Invariantes Topológicos",
    "section": "",
    "text": "Cálculo de invariantes: Se obtienen contando ciclos en las permutaciones, sin necesidad de visualización.\nElementos: \\(V\\) (ciclos de \\(\\sigma\\)), \\(E\\) (ciclos de \\(\\rho\\)), \\(F\\) (ciclos de \\(\\varphi = \\rho \\sigma\\)).\nFórmulas topológicas:\n\nCaracterística de Euler: \\(\\chi = V - E + F\\)\nGénero: \\(g = \\frac{2 - \\chi - b}{2}\\)\n\nSageMath: R.genus(), R.number_boundaries() y R.faces() para el cálculo automático.\n\nEn el siguiente capítulo estudiaremos los teoremas fundamentales que establecen la equivalencia entre sistemas de rotación y encajes celulares (Teorema de Heffter-Edmonds) y las propiedades de los mapas combinatorios."
  }
]